<!DOCTYPE html><html><head>
<title>Web Dev</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<link href='http://fonts.googleapis.com/css?family=Quando' rel='stylesheet' type='text/css'>
<link href='../BCS.css' rel='stylesheet' type='text/css'>
<script src="../BCS.js"></script>
<script>window.onload = function(){getMarkdown('daBook'); theBook.go(0,0);}</script>
</head><body>
<div id="stuff">dude, javascript must be, like, turned on.</div>

<!-- You should change the title above to be your book title, then put all your BookMarkdown in this one long script block-->
<script id="daBook" type="BookMarkdown">

::B Web Development
::C HTML,CSS,JS
::S Intro

--Download and install Notepad++

You will need an editor if you are going to develop for the web. Notepad++ is simple and free. Just download it from Notepad-plus-plus.org. (If you have a Mac, you have selected to live in your own universe and are thus on your own for finding an adequate generic ASCII text editor.)

== HTML, CSS, JS
Web development is a multi-language affair requiring that you know at least 3 different languages: HTML, CSS, and JavaScript. HTML stands for HyperText Markup Language which is used to hold the basic data of a web page. CSS stands for Cascading Style Sheets which are use to add/control the styling (font choice, color, size, weight, location) of the text and images that are tagged in your HTML file. JavaScript is used to create interactivity on a webpage. Basically interactivity is animation and animation is essentially the art of removing one image from your view and replacing it instantly with a slightly different image.

There are other components used in general web development as well, such as PHP and SQL, but those are involved in creating a database back end back up on a server somewhere that can keep a catalog of information, and track who your customers are etc. We are going to start just at the front end, where your user is going to see and experience things and put off (perhaps indefinately) working on the backend.

::S Testing
==Testing
If you WRITE code you must TEST code! Mistakes happen and you must look to see if you made some mistake. 

Typically when I am developing HTML/Web code what I do is this: I open up one window that is Notepad++, this is my editor and lets me both look at the code I am writing and make changes. Once I save the HTML file that I am creating, I use the RUN command (in the Notepad++ menus) to launch the file in IE to see how it looks. 

Note: I use IE because it is probably the worst/oldest browser and my web code is most likely to fail in that system. The earlier that you can cause your code the fail the faster you can fix it. Old browsers are best for testing because if you look up something on StackOverflow, there is a good chance that someone will show you the newest coolest code for doing the thing that you want to do AND that newest and coolest function that they showed you was NOT implemented in that old browser so that your code won't run on the old browser. If you want your code to run anywhere on anything, you would prefer to test it on some old beat up, old and slow machine (if runtime is acceptable on an old machine than it will probably be fine on a fast new machine). This is certainly not a requirement. Run on whatever machine you have, but as a general principle do your testing in the worst environment that you can find.

If your text editor does not have a RUN command up in the menu, no problem. Launch whatever browser you want to test in, and open the HTML file that you edited and saved. (Note: if you just click on the HTML file that you saved, your browser is selected for you as a default. If you want to run on a particular browser you must launch the browser and load from there)This will let you look at the HTML in the way that your user will finally see it. In general, I never close that browser window. So typically I have two windows open, side by side, one showing me my code and one showing me the result of running the code. 

Now, if I see something wrong in the HTML output window over in the browser, usually the flaws are something trivial, "oops I forgot to do this". You make the change in your editor window, use CTL-S to save the changes, then click "refresh" over on the browser window to reload your page. Then you can see the results of the change. You use the two windows to go back and forth between your code and the results of running your code, with a minimum of resizing, moving, opening and closing of windows. This is known as the Edit Test Crash loop.
 
Certainly while going through this tutorial, you will probably want a third window open as well that lets you read this text. Or alternatively, since this can be viewed in the browser, you can have this on one tab, and switch to the other tab to see output. Of course the more screen that you can afford and hook up to your computer the easier it is to achieve immersion. :) 

In many of the examples that I give, I will tell you to type in the code, but you can of course just copy code samples from this window, paste them into your editor, save the HTML file and refresh your browser window to see that it works as expected.

::C HTML
::S Intro

==HTML
The basic idea of HTML is markup. (HTML = HyperText Markup Language) What this means is that you add extra marks to a bunch of text that mark sections of the text to indicate whtat they are: So for example here is some text that you probably know what some of the chunks are. Here is some unmarked up text that you may know.

  Tom Sawyer by Mark Twain 
  "TOM!" 
  No answer. 
  "TOM!" 
  No answer. 
  "What's gone with that boy, I wonder? You TOM!" 

Now I will add some markup to tell you that this is a book with a title, and author and chapters ...

  <book><title>Tom Sawyer</title> by <author>Mark Twain</author>
  <chapter><q>TOM!</q>...</chapter></book>  
  
You see I have marked the starting point and the ending points of sections of text so that a computer could read the text and find out which part of the text was actually the book title, what part was the author, where the chapters are, where the quotes are etc.

That is the fundamental idea of markup, extra text that tells you what you are looking at. You may occasionally hear the word, "Metadata". The book itself would be the data that the user will see, and the markup is extra stuff that will NOT show up in the book, but which tells us something about that data.

Of course the purpose of that markup was so that we could write computer tools that would help us layout and create texts. The computer could see, "Oh, this is the book title here, it should be centered and in a big bold font and I can actually put that text in small caps on the top of every odd numbered page..." The notion was that if you marked up the sections you could then make layout decisions based on the semantics of the markup.

When this idea was copied over into HTML, they screwed it up in a big way. They did NOT understand this idea of separating layout decisions from semantic identification and they created tags like &LT;make this italic&GT;, &LT;color this green&GT;, &LT;use a big font here&GT;. As a result the tags that you will see in HTML and that I will be showing in minutes actually have very little to do with this fundamental idea of markup. All they really share is the gross syntax, that was borrowed from an earlier markup language, SGML. 

These problems were recognized soon after people started using HTML and many of the problems were soon fixed with the introduction of CSS, which will be seeing in the next chapter. I just wanted to point out that part of the reason that you need to know about 5 different languages in order to understand how the Web works it is because the history of the web and nearly every other computer system ever made consists of building something, deciding it was not quite right, keeping some of what was built and adding some more stuff onto it. That is just the nature of writing code.

Next up, we will start in on the actual syntax of HTML.

::S Tags 
==Tags
Most markup tags come in pairs, but some stand alone. The ones in pairs act like parenthesis, (having an open and a close - marking off the text that lands between them). The solitary ones act like the comma, It is a single mark, a separator, that just indicated a place. 

0. &LT;FOO&GT; - this is an open tag with the name FOO
2. &LT;/FOO&GT; - this is the tag that closes the previous open tag
2. &LT;BAR/&GT; - this is a self-closing tag that stands alone
3.

Tags are required to be properly nested. So &LT;FOO&GT;&LT;BAR&GT;&LT;/BAR&GT;&LT;/FOO&GT; is valid but &LT;FOO&GT;&LT;BAR&GT;&LT;/FOO&GT;&LT;/BAR&GT; is NOT.

Time for an example, a very minimal HTML file. Copy and paste this into notepad, save it as FirstHTML.html and run it.

--FirstHTML.html
  <html>
  <head></head> <!-- this is a comment. It doesn't show up on the page. -->
  <body>
    Look, My first HTML file.
  </body>
  </html>

This tag structure is standard with HTML, HEAD, and BODY. The entire thing is being tagged as HTML - so it starts and ends with HTML open and close. Inside the HTML section there are two sub-sections, one named HEAD that holds header information (that will mostly not be visible to the person viewing the web page) and the second section is named BODY and contains the body of the text that the user will view. 

You will see that the comment that I put in did not show up on the screen. Comments start with the string OpenAngleBracket-Bang-Dash-Dash and end with the string Dash-Dash-CloseAngleBracket. You can pretty much put comments any place you want in your HTML file, they are their for your benefit. I will not be using them in this course since this entire book is a very extended commentary on what my example code does.

::S Text Flow
==Text Flow
The white space, (that would be SPACE, TAB, LINE_BREAK), that you use in your HTML is mostly ignored, (not entirely, just mostly). A single space between letters IS important. It splits the words in your document, so you can't just put spaces anywhere, BUT after you have one space, it doesn't matter how many or what kind you put, they will all be flowed back into a single space. So open up your first HTML example and edit the text so that it is spaced out differently, like this:

--SecondHTML.html 
  <html><head>      </head>
         <body>Look, 
  My second HTML file is very
  
  similar to the first one.</body></html>
  
Save it run it. You should see no change. The important and somewhat irritating part of text flow is that in HTML you LOSE all your Line Breaks, and as a result when you want paragraphs back into your text you must put them back in with tags. 

So to power you through some of the very common tags, B is for Bold, I is for Italic, P is for paragraphs and just to show you the most common self-closing tag, &LT;BR/&GT; is the tag to insert a line break. (And just so you know, tag names are NOT case sensitive - my normal preference is for lower case but I uppercased many here to make them stand out for you. I have also used REALLY BAD formatting - lots of useless white space to emphasize the freedom that you have because of text flow - after this example I will stop fooling around and attempt to use layout that helps you see what is going on rather than just sprawling just because I can). Save and run the example and take a close look at the difference between a simple line break and a genuine paragraph break.

--ThirdHTML.html 
  <html><head></head>
  <body>
  <p>Look, Paragraph 1 is <B>bold</B>!</p><p>Paragraph 2 is <i>italic</i></p>
  
  <p>
  The third paragraph,<BR/>
  has some
  <BR/>line breaks
  
  </p><p>
  See how paragraphs are NOT just line breaks - they format with a blank line separator.</p></body></html>
  
++H1 Heading
==H2 Heading
--H3 Heading
HTML defines some tags, H1, H2, H3, H4, H5 for five different sizes and levels of headings, I have given examples of the first 3 of those just above. It is possible to use CSS, which we will be covering in the next chapter to alter the actual size and look of those headings, but the defaults are that H1 is big and H5 is small.

Go ahead and insert a heading of your choice into the third HTML example and notice that much as you would expect, Headings do break the flow and stand on a line by themselves.
  
::S Entities
==Entities
Since HTML uses Angle Brackets to mark tags, You now need a way TELL your browser that you DON'T want a particular Angle Bracket to be treated as the start of a tag but to be a LITERAL Angle bracket. Without this feature I would not be able to tell you "the way that you indicate a passage is bold is with bold tags like &LT;B&GT;this is bold&LT;/B&GT; The fact that you are SEEING those tags means that the HTML system did NOT see them and treat them like tags.

This "escape" mechanism is done with "Entities". There are whole bunch of them and you can look them up, I will only mention the essential few. Entities are basically represented as Ampersand-EntityName-SemiColon, i.e. &amp;FOO;

--The Essentials - LT, GT, AMP, NBSP
So the important Entity names are LT for LessThan which is the Open Angle bracket (<b>&LT;</b>), GT for GreaterThan which is the Close Angle bracket (<b>&GT;</b>), and AMP which is the entity for Ampersand (<b>&AMP;</b>) 

In the same way that HTML commandeered the use of Angle Brackets for Tags, it also commandeered the Ampersand for creating entities. This means that if you want a literal angle bracket or a literal ampersand to show up in your document you must use entities. So when you see a single ampersand like this: &amp; in a document, it means that the HTML document actually had the entity: &amp;amp; written into it.

There is one other entity that I consider to be essential. It is the "non-breaking space" character, named "NBSP". This is used in those rare cases where you want to tell the system which is normally flowing text that you have included a space between two words but that you do NOT want the flow system to insert a line break in between those two words. For example you might want to force Mr.&nbsp;Smith to show up on one line rather than live with something like Mr.<br/>Smith which can be awkward to read. 

--The Inessential
Of course, once they had the mechanism for entities, they could build all kinds of them so &amp;copy; is the entity that encodes the copyright symbol that looks like this: &copy; and if you want math symbols, there are a bunch of those, and arrows and dingbats and whatever. Look 'em up if you need em. Just search for HTML Entity Table or unless they have moved it, here is a link <a href="https://dev.w3.org/html5/html-author/charref">HTML Entity Table</a> (of course, if you click that link right now, you move out of this book and who knows if you'll be able to return to this exact point :)

--By the numbers
At the time that the browsers were being developed Unicode was not quite yet a standard but it was getting there, so they built in a simple numeric scheme to allow the entity mechanism to get any Unicode character onto the screen. So for example the Russian Cyrillic YA character, (the backwards R that is pronounced, YA), &#x042f;, which happens to have the hexadecimal code 042f in the Unicode standard would be entity encoded like this: &amp;#x042f;

Of course those numeric tags were what you did back in the day when web pages, which could DISPLAY all the Unicode characters, were actually being edited as ASCII English Characters with these disgusting entity encoded characters making the raw files absolutely unreadable if what you were doing was trying to present Russian text. However, now days, the web html files themselves can actually be Unicode documents. Now when you want a Russian, or a Chinese character you just type it into your HTML document directly and save your HTML file as UTF-8 and NOT as ASCII text and then you DON'T need to use numeric entity encoding at all. 

::S !DOCUMENT and TITLE
==Other Head Elements
That minimal HTML file that we used in the first several examples works in modern browsers because it was historically correct, but is considered today to be a little deficient. As I write this people are currently being encouraged to start their files with a doc tag that is NOT actually HTML, it is a tag so that some system OTHER than the HTML display system can see that this file is an HTML file. The magic line that you start with these days is:

  <!DOCTYPE html>

A few years ago they insisted that you start with

  <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
  
or with
  <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
  
Needless to say there is NO WAY to remember garbage like this - and you shouldn't even try to remember it because it keeps changing. You just had to look it up. It is a shorter string now in HTML5 but I still look it up because the web committees keep changing the standards. Those earlier ugly lines were because of earlier ugly code that wanted you to tell it where to go to look up information that would tell you which version of HTML you wanted the browser to use in order to read your HTML. So from now on, I will start all my examples with a !bDOCUMENT mark - but do take note: while it LOOKS like an HTML tag it is NOT. There is NO corresponding closing tag. The html in your document didn't start until after that DOCUMENT mark. The html needs to be balanced in open and close tags. The DOCUMENT mark was created by fools who thought that they were doing you a favor to make it LOOK like an HTML tag with surrounding angle brackets. Anyway, moving right along.

==Title
One of the tags that belongs in the HEAD section of your document is the title. The title tag just marks a small chunk of text that you want to show up NOT in the document that you are creating but rather up in the TABs at the top of your brower that lets you switch back and forth between several open pages.

==UTF-8
I worked in a language lab for several years and printing web pages teaching foreign languages with different character sets is what we did. As I mentioned before, this is much easier if you keep your text is an UTF-8 file. However if you do that, it is polite to tell the browser that it is reading a UTF-8 file that MIGHT have special characters. To do this you use a meta tag, you will see it in the next HTML example that I have named HTML_TEMPLATE. I have called it "Template" because I am moving ever closer to a single file that will contain ALL the stuff that you TYPICALLY use in any HTML file and thus you can always start up a new HTML page by making a copy of the template file.

--Template.html
  <!DOCTYPE html><html><head><meta charset="utf-8">
  <title>TEMPLATE</title>
  </head><body>
  Don't forget to change the title on this page when you edit it!
  </body></html>

If you are using only ASCII characters in your document you won't need this meta statement BUT since ASCII is a subset of UTF-8 there is nothing wrong with claiming that your document is UTF-8 so I just include this line in my template and leave it in for every HTML file that I create.

I guess I should point out that the meta tag that I typed was not just a single name like every other one that I have showed you so far. It is a tag that had some extra words in it. Those extra words defined an attribute and that is the next thing to discuss.

::S Attributes
==Attributes
Occasionally a tag needs to have extra information associated with it. There is a tag named TABLE that is used to create ... wait for it ... a table. I am not going to show you a table quite yet BUT when you build a table you may or may NOT want to include a border on that table. If you do include a border you probably want to decide how thick the lines should be for that table. Possibly you want a background color for that table. Where does all that information go? None of that extra information belongs as part of the document text that the user will see, so that information is packed into the tag itself. The basic format is this:

  <TAGNAME AtName1="value of first attribute" AtName2="value of Att2" somethingElse="sweet">

Different tags support different attributes. Some attributes are VERY tag specific, supported only by a few tags, others are VERY GENERIC supported by nearly any tag. I don't do enough writing of HTML to remember them all. I just remember enough to look up what I need. The W3Schools site is a good reference for some of this tag information. I would encourage you to go though one of their online tutorials (After you have read this FAR SUPERIOR presentation of course :). Here is one of the very specific ones but it is an important one because it is used for a HyperLink which is of course what the web was designed to do - give you links that you can click on to go to another web page.

  Here is what a link to <a href="https://www.amazon.com/">the Amazon web site</a> looks like.
 
Add that line to the body of your HTML Template, run it and verify that it gives you a link that takes you to amazon. Links are defined using the A tag (which stands for Anchor - I know, Silly name!) and the important attribute is HREF, which stands for Hyperlink REFerence i.e. the address of where you want to go. Notice that what the user sees on the page is NOT the actual URL for amazon but rather just the text "the Amazon web site" which we wrapped between the open and close A tag. The user sees the text that you want them to see, not the actual URL (Uniform Resource Location - the address of an internet file, typically a web page). 

I looked for a cat photo, found an address and created an image tag. Note, an image tag is a self-closing tag. It stands alone and mostly it is just a single attribute, the location (a URL), for the source of the image. You could have other attribute that would change the size of that image. I am not teaching you image tags here, I am just showing you what attributes look like and some of the VERY common examples where you MUST use attributes. So drop this cat into the body of your Template and enjoy the cat.

  <img src="https://cdn.pixabay.com/photo/2016/12/06/03/46/cat-1885511_960_720.jpg"/>
  
Well, technically I should say, "Enjoy the cat if it is still there." If I was really creating a site, I would generally NOT want to link to some jpg on some site that may vanish or move any day and thus break my site. Typically in site building, if I needed images, I would put copies of the images in a directory that I OWN, and then make my SRC attributes point to that directory so that I would know that those images links would work. Of course referring to another cite is simply academic citation, whereas making a copy could easily be a copyright violation. SUX2BU!

==Summary
At this point we have covered almost all of the syntax for HTML. Yes it really is that easy. There are TAGS - open, close, and self-closing. There are ENTITIES for special characters. Tags can contain ATTRIBUTES which are in the form name="quotes around some string of text". And there is some unsightly non-html DOCUMENT bullshit up at the top of the file.

That is HTML SYNTAX. What it all means, and how best to use it to create documents is a bigger problem, but congratulate yourself it you have made it to here, this is the first real milestone, you have basically learned the syntax of HTML.

Next up, I am going to show you just a few more tags like for things like lists and tables and just a few more attributes to change the way that things look, and then we will be done with HTML. Yes, there is certainly much more that you could learn, and I do recommend reading an online tutorial at some point to see some of the things that I am omitting but we are almost done with the HTML that we will need for this course.

::S Lists and Tables
==Lists
Lists in HTML come in two flavors, lists with bullet points in front of the items, known as Unordered Lists and lists with numbers in front of the items known as Ordered Lists. Easiest just to show you.

0. apple
2. banana
2. cherry
3.

That was an Unordered List which uses the tag UL and each item on the list has its own tag, LI, standing for List Item

  <UL><LI>apple</LI><LI>banana</LI><LI>cherry</LI></UL>
  
  You can write it on one line like that, or you can use multiple lines like this:
  
  <UL>
    <LI>apple</LI>
    <LI>banana</LI>
    <LI>cherry</LI>
  </UL> 

Now to make that into an ordered list with numbers you change exactly 2 letters. Just change the UL tag names (both open and close) to OL. Same three fruit but now with numbers.

Those list items do NOT need to be simple words, you can in fact put several paragraphs into a single list item and you can put lists into list items. For example:

  <OL>
    <LI>apple
      <p>Ripe apples come in several different colors
        <UL><LI>Green - Granny Smith</LI><LI>Yellow - Golden Delicious</LI><LI>Red - Winesap</LI></UL>
      </p><p> See - no problem with long complicated list items.</p>
    </LI>
    <LI>banana</LI>
    <LI>cherry</LI>
  </OL> 

Again, I am expecting you to copy and paste that little snippet of HTML into one of your example files, save it and run it to see what it looks like.

==Tables

Tables have even more structure than a list and thus even more tags. Basically you Tag the table itself with TABLE, you tag each Row with TR, you tag each data item across the row with TD, and you are allowed to have a header of lables at the top of the table by using a TH tag on the individual items instead of the TD tag.

  <TABLE>
    <TR><TH>Color</TH><TH>Type</TH><TH>Price</TH></TR>
    <TR><TD>Green</TD><TD>Granny Smith</TD><TD>$1.19</TD></TR>
    <TR><TD>Yellow</TD><TD>Golden Delicious</TD><TD>$2.35</TD></TR>
    <TR><TD>Red</TD><TD>Winesap</TD><TD>$.57</TD></TR>
  </TABLE>
 
Well that was ugly, lets put a border around it. Add this attribute to the TABLE tag.
 
  border="1"
  
Change the border value to 5 and see what happens. Can you put a table in a table? One copy and one paste will tell you. I copied the table code from above and plopped it in right after Granny Smith. How about paragraphs? This was my experiment:

  <TABLE border="1">
    <TR><TH>Color</TH><TH>Type</TH><TH>Price</TH></TR>
    <TR><TD>Green</TD><TD>Granny Smith  <TABLE border="1">
    <TR><TH>Color</TH><TH>Type</TH><TH>Price</TH></TR>
    <TR><TD>Green</TD><TD>Granny Smith</TD><TD>$1.19</TD></TR>
    <TR><TD>Yellow</TD><TD>Golden Delicious</TD><TD>$2.35</TD></TR>
    <TR><TD>Red</TD><TD>Winesap</TD><TD>$.57</TD></TR>
  </TABLE> </TD><TD>$1.19</TD></TR>
    <TR><TD>Yellow</TD><TD>Golden Delicious<p>this is a test</p><p>can I have paragraphs? I suspect that I can but I do worry about what it will look like if I have a paragraph with lots of text. I mean, how will it decide where it should locate the margins for that text?</p></TD><TD>$2.35</TD></TR>
    <TR><TD>Red</TD><TD>Winesap</TD><TD>$.57</TD></TR>
  </TABLE> 
  
It is very hard to know what some pile of nested HTML structures will look like when your browser lays it out, but it is pretty easy to just type in some HTML and look and see if it did what you wanted.

I would like to point out that the attribute that I added in order to draw the border is OLD school HTML. It was the way that things were done in the STONE AGES. The more modern way would be to use CSS, Cascading Style Sheets, in order to modify the Look and Layout of a table. We will see some CSS in the next chapter. 

::S DIV and SPAN
==DIV and SPAN
There are two tags, DIV and SPAN, that have the interesting feature that unlike the other tags, they do almost nothing. The B tag makes something bold, the IMG tag inserts and image, the SPAN tag by itself does nothing. So why have a tag that does nothing?

Nothing is beautiful! The advantage of nothing is that you can add things to it. It allows you wrap some text with a tag that by itself does nothing BUT that tag has attributes which can affect the material that it wraps. This is the way that you can color something. Drop this into your document.

  Dude, check it out. I can color my text <SPAN style="color:Red">Red</span>. Pretty sweet!
  
That SPAN tag, by itself, did nothing, but that style attribute declared the !ninnerHTML to be colored red. I am going to start using that phrase, innerHTML, to mean the text that was wrapped up by the tag. We don't need this vocabulary right now, but will need that name when we start learning Javascript so I am going to start calling it by name now. 

The DIV tag and the SPAN tag are both empty tags used for hanging attributes onto items and the only difference between SPAN and DIV is this: DIV breaks flow, SPAN does not. The SPAN is for small chunks of text, like a single italicized phrase that fits into a single paragraph. As a result, a SPAN should not contain a LINE BREAK or a paragraph, or a list or a table or any other big text that causes a break in the text flow. DIV, in contrast is a big container that DOES break the flow of text, and can contain just about anything including other DIVs - so a Division in your document can contain multiple paragraphs, with tables that themselves contain lists. DIVs are big, huge even, however SPANs are small.

::S Summary
==Summary of HTML
The Syntax of HTML is very simple, you have tags; open, close, and self-closing. Those tags can contain attributes - which are name="value" pairs - that are mostly specific to a particular tag, and you have entities - which are &amp;name; - which allow you to represent special characters and in particular allow you to represent the literal LESS_THAN, GREATER_THAN, and AMPERSAND characters that were commandeered by HTML for its own use. 

Here is a sample HTML line that used all 3 of these elements.

  <TAG att1="some value" att2="99">innerHTML is an image &copy; 1984 <img src="foo.jpg"/> and this text.</TAG>

We mentioned some specific tags:

0. HTML, HEAD, BODY, TITLE, META - for the structure of the entire document
2. B, I - for Bold and Italic
2. H1, H2, H3, H4, H5 - for different sized headings
2. P - for Paragraphs
2. A - Anchored text for Hyperlinks to other pages
2. IMG BR - the two self-closers I mentioned for Images and Line-Breaks
2. UL, OL, LI - for Unordered Lists, Ordered Lists, and List Items
2. TABLE, TR, TH, TD - for Table, TableRow, TableHeader, TableData
2. SPAN, DIV - to mark small and large sections of the document with particular attributes.
3.

::C CSS
::S Intro
==Cascading Style Sheets - CSS
CSS was added to HTML in order to allow better separation of responsibility. It allows one person to create the text and mark sections for emphasis and allow a different person (probably a graphic artist) to manage the color, the size, and the layout. 

The problem that CSS was designed to solve was essentially this simple thing: Suppose you have a large WEB site with hundreds of pages. Many of those pages had headings. Suppose you put attributes in those headings to make them all RED, giving your site a nice consistent look. Your new boss comes in and wants the site changed. Red is too glaring, can't you make them all TEAL instead? Yes, of course but, because all the pages were created directly using the color RED, you must now open and edit hundreds of pages. What CSS basically lets you do is allow you to give a variable name like HeadingColor and use that in all your headings and then define a style sheet, a dot CSS file, which your HTML will reference, and then you set the value of HeadingColor to RED in that one single CSS sheet. Now, when you want to make the change, you change one one value in that CSS file and since all the pages reference that CSS file that change ripples across the entire site.

Of course this only works IF your site was designed from the start to use CSS to color your headings instead of hard wiring each page to get a particular layout. Hence the general advice: Try to build your HTML documents without making any making any particular decisions about typeface, size, color, margins, etc. Instead just give the elements in your document style-names and define the particular look in a CSS style sheet.  

The best way that I can show you the range of effects that you can get with good CSS styling is to point you at a site that was created to show what a good CSS artist can do by having one single well marked up HTML document which they then display using 8 different CSS style sheets.

So go look at the Zen Garden of CSS, click on all the different examples, (there were 8 examples when I linked to it) look at what you can do, then come back here and forget most of what you saw. You can forget it because I am NOT going to show you how to become a CSS master. I am not a graphics artist and I will not teach you how to be one, but I have worked with artists and I know how you can build your HTML so that you CAN work with a good graphics artist. What I am teaching you is a general pattern know as "separation of concerns" - put the content in the HTML, put the layout, size, color in the CSS. Go take a look at the garden then come back here.

<a href="http://www.csszengarden.com/">The CSS Zen Garden</a>

::S Syntax

==CSS Syntax
The syntax of CSS is even easier than that of HTML. In general it looks like this:

  selector {propertyName: value; anotherProperty: value;}
  
A specific example could look like this:

  p {color: red; text-align: center;}

That particular style line does the following: The !nselector tells you WHAT elements are going to be styled. The selector here was a stand alone letter, p, which refers to ALL text that was wrapped with a P tag, i.e. all the paragraphs in your document. Inside the braces after the selector is a semi-colon separated list. Each item in the list is a name-value pair. This style list had two pairs, one told you to color the text in every paragraph red and the other pair said to make the paragraphs all center aligned instead of the default left alignment.

Now in order to see this styling in action take one of the HTML examples that you have produced that has some paragraphs in it and ADD a CSS STYLE section up in the HEAD section. So add these three lines into the Head section, and watch it color your paragraphs.

  <style>
    p {color: red; text-align: center;}
  </style>

==CSS Location
There are actually 3 places that you can place CSS styling. You can place the style commands directly in a tag. You have already seen this when we showed you the SPAN tag that defined a color change.

  Dude, check it out. I can color my text <SPAN style="color:Red">Red</span>. Pretty sweet!

Basically you can take ANY tag, add a "style" attribute and the "value" of that attribute is any legal CSS list of properties and their values. That style needs no CSS selector, and it needs no braces, because it applies ONLY to the innerHTML of the tag that holds that style attribute.

The next place, which is further away than an individual tag, is known as an "Internal Style Sheet". That is what we did when we placed a "style" section to color the paragraphs up in the HEAD of the HTML document. It is an "internal" style because it works only on this page. 

The selector is now needed to define which tags in the entire document will get that particular style. And it should come as no surprise that I can add styling for several different types of elements in that single style section. For example:

   <style>
    p {color: red; text-align: center;}
    h1, h2, h3 {color: green;}
  </style>  

That will now color the paragraphs red and will make the first 3 types of headers all green. Notice in this second example I used a more complicated selector that referenced three different headers all with a single style list.

The third place that we can locate CSS, and the place that is appropriate for any large multi-page website, is to create an "External Style Sheet" for that you would create save the CSS in a stand alone file:

--foo.css
  p {color: red; text-align: center;}
  h1, h2, h3 {color: green;}
  
and then, in any HTML file you can REFER to that external sheet by adding a single line up in the HEAD of that HTML document which links to that style sheet.

  <link rel="stylesheet" type="text/css" href="foo.css">

And you can include as many external references, links, to as many different style sheets as you wish. (I can never remember the particulars of the format of the above link statement - I typically define a single macro in notepad++ that will spew out a generic HTML file that will have that reference to an external sheet and then I go edit the word foo to give the sheet a genuinely useful name. Just so you know - javascript can also be placed either internally directly in the HTML file or in an external script file. Once we have introduced javascript, I will show you the generic HTML template that I use whenever I start off an HTML project one that links to both an external CSS file, and to an external javascript file and has some other useful goodies as well.)

I have glossed over an important item in that link command. I just put the name of the css file, foo.css, into the link tag as the href attribute. I did not tell you where to put the foo.css file. The way I have written it, the css file must be in the same directory as the html file. When the browser is resolving references, it distinguishes full addresses like "https://www.amazon.com/" and local addresses (on the same machine that the html file came from). One of the easiest problems that can arise when building any multi-page chunk of code is that the references point to the wrong place - "Hey the css file CLEARLY says that the headers should be green and the headers are still black. Did I get the selector wrong? No, it's just H1. Did I spell the name of the file wrong? No, it really is foo.css. Did I misspell 'green'? No,... OH the file is in the wrong directory!"

Getting file paths to line up so that the system properly finds all the components that it needs is a source of bugs, and thus it is good to TEST it. Testing just involves building a minimal html page that has something simple like a single header &lt;H1&gt;This should be green&lt;/H1&gt;, building a simple single line css file that colors the headers green and see that you can get them properly linked. The secret to debugging is to ALWAYS be testing.

I have also glossed over another potential bug. I told you that one of the purposes of CSS was to eliminate placing layout decisions directly in your HTML, othewise you might find yourself having to edit hundreds of pages that all made direct reference to the color red. The same thing is true with the location of your css file. If you built your hundred page site and every page refers to a single css file, you now only need to edit that one css file to change the layout. Now where did I put that css file? Did I put it in the same directory with all the html pages? What did I name it? Humm.. I really should have put my css files into a separate directory so I could easily find them. I'll just move them now. Humm.. If I move the CSS files, that means I need to edit the link references in all hundred of my HTML pages. Maybe I'll just leave everything where it is.

A decision about the directory structure that holds your project, whether made consciously or unconsciously typically lasts a long time because as the project gets bigger it becomes harder and harder to change, because the references were all coded using the original directory structure. I won't tell you that you MUST keep your css in its own directory, and all images in another. That is overkill for a small project, and I am assuming that I am teaching this course to folks that are NOT working in a professional HTML shop and are indeed just building small projects where a single directory is in fact very convenient. What I do encourage though is that you play with building different folders to hold your stuff and convince yourself that you CAN in fact build links to any plausible directory structure that you might need.

::S Selectors
==CSS Selectors

In all the examples that I have showed you so far, the selector was just a tag name in the document and it applied to all those tags, like all the paragraphs or all the headers or tables. I never actually use that form in any of the css that I do. Instead I tend to use ID and CLASS selectors. Here is how they work.

You are allowed to put attributes named "id" and or "class" onto any tag in an HTML document. The value for the id can be any single name, like FrontCard or CorrectAnswer - the only requirement being that the id value should be UNIQUE for the entire HTML document. There should be only ONE SINGLE TAG that has that name. Class attributes are also just names, but the Uniqueness description is dropped. You can have many tags that all share the same class AND any single tag may belong to several different classes. For example:

  <h1 id="Top">...</h1> <h1 class="intro important">...</h1>

In this example there is one unique heading in the entire document that is singled out for special treatment (presumably because it is at the very top of the document), so we give it an id. It is UNIQUE. Other heading may get a special size because they are "introducing" new topics. Some headings may get a special color because they are "important". I have showed a heading that lands in both the 'intro' and the 'important' class. I could have any number of heading that are in either one or in both of those classes.

The style sheet to go with the above HTML could look like this:

  .intro {font-family: "Times New Roman", Times, serif;}
  .important {color: red;}
  #Top {font-size:2.5em; color: blue;}


The # in front of a name in the selector means that the selector is for an ID, the dot in front of the selector means that the name is a CLASS name.

==Contradictions
The C in CSS stands for "Cascading" this is simply a description of how conflicts are resolved. What if the intro styled the element to be 14 pixels high but the important styles it to be 20 pixels. Who wins? The answer is that it is styled by "the last style element" So in this case intro was first, important was last, so important dominates over intro. Furthermore, if this "class" styling was defined in an external sheet, and your HTML page links to that external sheet, but also has an internal sheet, the internal sheet dominates over the external sheet. You can redefine a class style for this single page. And even closer, if a single tag has a style element, that element takes precedence over anything in either an external sheet or an internal sheet.

==Combinators
The time that I spent doing HTML was entirely spent building WEB sites from scratch, and as a result I have had the luxury of adding id and class elements to all of the HTML that I build so that I can make allowances for how I want things styled. Other folks, that may need to style legacy pages, where they did NOT create the pages typically need to write style sheets that look for particular tags or particular combinations of tags. As I said, I don't use any of these and won't use these in this class, but it is good to know that they exist.

0. li, p // the comma splits these two, both list items and paragraphs will get styled.
2. li p //the space means "descendant", any p that sits somewhere inside a list item.
2. li>p // the &gt; means "direct child", so P in LI - YES, P inside DIV inside LI - NO.
2. div+p // + means "Adjacent sibling", so this would find a P that comes immediately after a DIV
2. div~p // ~ means "any sibling", so any p that shares a parent with a div
3.

==More Information
I strongly recommend that you visit the W3Schools site and look though their CSS intro at this point. It is good to know what is available even if you don't have any need for it at the moment. I have already covered everything that I will need for this class, but it would be good for you to at least take a glance to see some of the things that I am skipping over.

Here was my test code 
 
--test.html
  <!DOCTYPE html><html><head><meta charset="utf-8">
  <title>CSS TEST</title>
  <link rel="stylesheet" type="text/css" href="test.css">
  </head><body>
  <H1>this should be green</H1>
  <H1 id="TOP">this should be red</H1>
  Have a nice day!
  </body></html>
  
--test.css
  #TOP {color: red;}  
  h1 {color: green;}
    
::S Summary
==CSS Summary
We have shown you almost nothing about CSS, just enough so that you can add some color to items on your page, and that is all that I intend to use in this course. The important point being that if you are artistically inclined and want your presentation to look nice, you should include some attributes in your HTML that hint at all those places where you might want to decorate with colors or font changes. If you want the !nfirst_occurance of a new vocabulary word to stand out, it doesn't ultimately matter whether you painted it purple or made it big and bold, the CSS can't color it unless it was marked with some attribute like &lt;span class="new"&gt;first occurance&lt;/span&gt; so that the css can find all those new words in the class 'new' and decorate them in some way. The color and size that you choose is ultimately inconsequential, however the structure of your markup is key to enable CSS to work its artistic magic. 

Neither HTML and CSS are 'computer languages' in the traditional sense. Between them they constitute a 'Page Layout' Language, just a way of arranging words and images on a page. What comes next is Javascript which IS a more traditional computer language. HTML and CSS pretty much give you static pages. Yes, when you resize the window, the text will rearrange itself and flow to fill the window, but other than hypertext links which let you jump between pages, the pages don't allow the user to change them. That is the purpose of javascript, to allow the user to click on things and have the page notice that click and then update the page based on what the user wants. It is the javascript that allows decision making and animated interactivity. That is the primary focus of this course. 


::C Programming
::S Intro
==Intro to Programming
I am going to do something different from the way that people normally teach a programming language. Instead of teaching you how one single language works and systematically going through every single feature of that language, I am going to teach 3 of them all at the same time and not strive for complete coverage in any of them. With Human spoken languages, with their complex grammars and the necessity of learning over 2000 vocabulary words to gain decent proficiency teaching 3 instead of 1 would be a bad way to teach.

But programming languages are IMHO different. Their grammar is much simpler and the total vocabulary more like 100 words rather than several thousand. Also since computer languages borrow heavily from one another, the languages are much closer together than human languages tend to be. However, the primary reason that I have for teaching 3 is this: Typically when you are learning a foreign language and you are taught that the Russian word for "dog" is "sobaka" this is merely a memorization issue. You already know what a "dog" is and how to tell the difference between that and a "cat" or a "chair". You already KNEW the meaning of the words that you had to memorize in that foreign language. Whereas when I want to show you how to "declare a static variable" in the language C The concepts themselves are probably foreign. You don't know (as a noob) what "static" meant, what "declare" meant, and possibly even what "variable" meant. 

In beginning programming, most of the teaching/learning load is conceptual rather than just memorizing syntax and vocab. I think that I can better highlight the concepts by looking at them in different languages. In general, the concepts tend to be the stuff that is quite similar between languages and the only real differences are syntactic ones. I want you to learn the vocabulary of the concepts and NOT just the vocabulary of the way that this particular language happened to name that particular programming concept.

Certainly, in this course I will focus on javascript. That is the language that is built into the browser and works with the HTML and CSS that I have showed you so far, but I will be giving you examples and contrasting what you are learning here with examples from C and Java as well.

In some sense, the chapters that came before this one, the chapter on HTML and on CSS, were REALLY just the base material that you needed to know in order to get javascript to run. IF I were seriously going to teach you C and Java at the same time, I would need to spend time here giving you just as much background on what you need to do in order to get Java or C to run. If you are REALLY interested in learning those other languages you can/should read the first couple chapters of the books that I have written on Java and C where I give that introductory material for those languages, or you can just stay here, learn javascript and just believe that what I tell you about the other languages is correct rather than testing them directly.

==Computer Structure
Computers are machines that have !nMemory which is just a large array of slots where you can store numbers. They also have a !nCPU, a Central Processing Unit, which has things like addition circuitry and multiplication circuitry that allows you to do !nprocessing (mathematical calculations) on those numbers. The CPU usually also has a very small set of memory slots called !nRegisters. There may be only 4 or 8 registers and typically the importance of the register is that they are directly wired to some calculation circuit so for example when you execute an ADD instruction on the CPU it may automatically add register A to register B and leave the result in A. So before you execute an ADD you must first load a number from some place in general memory into register A and a second number from general memory into register B. All computers work this way, they !nfetch things from general memory into particular registers, perform some calculation, and then !nstore the result back out to some place in general memory. The work is all fetch, calculate, store.

The !ntype of the numbers that those machines can store are typically !nintegers (if you don't remember, integers are whole numbers, like 0, 1, 2, 3, ... but both positive and negative numbers, so -17 is also an integer). And just for the record. While we tend to think of the number sitting in a slot as !nsigned integers, the memory slots don't actually care what is shoved into them. It is the CPU that distinguishes as to whether the number is signed or not. So for example there will be two kinds of multiply circuits on the machine, one to do signed multiplication and a different circuit to do Unsigned multiplication. 

When I say that those numbers are kept in a large array, what I mean is that the slots where you store the numbers have !naddresses which are themselves non-negative numbers (zero and on upward). This is just like houses on a street where you can talk about house number 17, (17 would be the address of the house) and that house/slot could hold any single number like maybe 536.  

Because the slots have a finite size the numbers that you can fit into a single slot are also limited. You describe the size of a single slot by telling how many digits that slot can hold. Because computers work in !nBinary numbers (those are number in base 2) instead of !nDecimal numbers (those are number in base 10 which is the way that we usually write them - ten fingers = 10 digits, oh duh, old latin word for "finger" is "digit") we tell you the size of the slot in !nbits which was a word that means "Binary Digit" = "Bit". So if I talk about a 16 bit machine, or a 32 bit or a 64 bit machine. What I am telling you is HOW big a number can fit in a single slot. Rule of thumb, 10 bits is about 3 decimal digits, so a 16 bit machine can hold 10 + 6 bits which is about 3 + 1.5 decimal digits you would guess that a 16 bit machine could hold a number about as big as 50,000. In reality, the limit for a 16 bit machine is about 64,000. Similarly a 32 bit machine can hold about 9 digits so around a billion (actually about 4 billion) and a 64 bit machine can deal with numbers on the order of 16 billion billion (about 18 decimal digits) 

Engineers have abbreviations that allow them to talk about large and approximate numbers. They use !nK for !nKilo to mean a thousand so 12K means around 12,000 (notice: the number ends with one block of 3 zeros, which are decimal digits - the same 3 that are approximately 10 bits). They use !nM for !nMega meaning about a million so 23,000,000 would be 23M (that is 2 rounds of 3 trailing digits - or about 20 bits). They use !nG for !nGiga to mean a billion (3 rounds of 3, like 4,000,000,000) So the range of a 32 bit number is about 4Gig. The next number up is !nT for !nTera which we would call a trillion (4 rounds). Next is !nP for !nPeta (5 rounds). !nE for !nExa (6 rounds) and there are other names further up. My memory tops out a Peta, I had to look up Exa. Anyway, those names for big numbers are typically used to describe HOW MANY SLOTS you have in your memory. "One Megabyte", means one million slots each of which is 1 !nbyte long (and a byte comes from the age of the dinosaurs, it is a slot that is 8 bits long). It takes two bytes to make up a single 16 bit slot, it takes 4 of them to make up a single 32 bit slot. So if you have a "megabyte" of 32 bit memory you have room for a quarter million 32 bit numbers.

Since the slots of memory in your machine sit at addresses, if you want to talk about the millionth memory slot, I mean if you want to store that address, one million, in a slot, well, you can't be doing that on a 16 bit machine that can only store numbers about as bit as 64 thousand. Similarly, since 32 bits can only hold numbers as big as 4 billion, it means that if you have more that 4 billion slots, (4Gig), of memory you won't be able to address them all, so one of the reasons to have 64 bit machines is so that you can have more that 4G of memory.

Anyway, all of this was primarily to point out that the stats that people quote when they are talking about machines often include those two important numbers - How many slots (8 Gigabytes) and the slot size (a 64 bit machine).

==Early Languages
Evey single machine has a thing called !nMachine_Language. That language is different for each different CPU because the machine language is the way that you move numbers from memory into the different computation circuits that a CPU has. Because each different type of CPU has different circuits, they have different !nmachine_instructions. Those instructions are just lists of numbers, and the CPU typically has a special built in memory slot called !nIP for !nInstruction_Pointer. That memory slot holds the address of memory that has the next machine instruction. When it is running, the CPU fetches the instruction that is sitting in the slot that IP is pointing to, decodes and executes that instruction (typically fetch, calculate, or store), bumps up IP (which effectively moves to the next instruction) and it just keeps on going. 

So machine code is just a long list of numbers which are instructions that tell the computer what to do.

Machine language, being a list of numbers is very hard for a person to read and understand. You won't remember that 17 means, "use register BX as a pointer, so the value sitting in BX is an address of a slot in memory, go fetch the value of that memory and put it in DX". So typically every computer has a language known as !nassembly_language that is a very simple mapping that uses letters (instead of numbers) to represent what the machine code number is doing, so for example in Assembly code that machine instruction of 17 might be "MOV DX,[BX]" which tells you you are Moving into DX the thing out in memory that is pointed to by BX. There is a piece of code called an !nassembler that reads files containing your assembly code and converts them into the list of numbers that the machine needs,

Assembly code, being a direct one to one mapping of machine instructions is very efficient for any machine, but being tied to a single machine is NOT portable between different machines. That is what !nhigh_level_languages do. C, Java, and Javascript are all high level languages. They give you machine independence but they do it in 3 different ways.

==High Level languages
C is what is known as a !ncompiled language. There is a chunk of code called a !ncompiler that will read a file written in C and translate it (much like the assembler did) into a list of number that is machine code for a given machine. Because the compiler is producing machine code for a given machine you typically must have a different compiler, one for each different machine. So you will have one compiler that knows how to compile for an Intel CPU, you will have a different C compiler that knows how to compile to a Cray super-computer etc.

Java is also a compiled language. However instead of having dozens and dozens of different Java compilers, one for each different machine, They (Sun, the original developers of the Java Language) built a single compiler that produced machine code not for a real machine, but for a fictitious imaginary machine, a virtual machine. This virtual machine was made to be fairly generic containing things that were very typical of actual different computers. With any luck, a single instruction for this virtual machine could be translated into a single or just a couple instructions on any actual machine. 

This one instruction at a time translation is called an !ninterpreted_language. So what Java did was to compile Java into an interpreted language for a Virtual Machine. Then for each different actual physical machine you build a specific interpreter (called a JVM for Java Virtual Machine) for that specific machine. The Java design still requires that you build something different for each different physical machine but what it consolidated was all the work on the front end that reads the actual Java instructions. That makes it easier for them to add new things to the Java language, because that means you only change the one single Java compiler to read that new feature and compile it to run on the Virtual Machine and then all the JVMs can just stay the same.

Javascript is essentially an interpreted language. They don't use a virtual machine. Instead it is built into each browser and sadly this means that it is NOT actually a single language. The Google browser implements Javascript one way, the Microsoft browser does it another way. Every new release changes the language a bit. So it goes. Fortunately the constant pressure for stability (you never know which browser your user is going to use to look at your web site so web site creators do NOT want to use features that work on one browser but NOT on another) had put pressure on the companies to set up standards committees and to follow what the standards recommend so the differences are not as great as they once were.

Because javascript is built into the browser it is a rather peculiar language. It has a strange output model because it is intended to work hand in hand with HTML and the Document that is being presented in your browser. In order to prevent web pages from crapping all over your personal files, javascript runs in what is called a SANDBOX, and has NO ability to read or write to any files on your machine (unlike any REAL computer language). So javascript is quite a bit different from C and Java. But on the other hand, it borrowed many other notions from Java which borrowed them from C so there is actually much in common between them all.

==Data Processing
The hardware of a computer has two main components, memory that stores data and a CPU with processing circuits that can perform calculations on that data. Nearly every computer language reflects that duality with notions that are usually known as !nVariables (which are named slots that hold some kind of data) and !nFunctions (which are named lists of instruction that take in certain data items a input called !nArguments and usually produce some output result known as a !nreturn_value). In many ways, this duality in programming languages strongly resembles the duality expressed in human languages which tend to be primarily nouns (which are data items) and verbs (which are actions).

What a programmer is typically doing in writing code is making decisions on how to structure the data so that it holds the information that you want to process in a way that makes it easy to find and get to the chunks that you need at any given time and to write the functions or processes that will do the manipulations of the data that you want to be able to do. All of these tasks are centered around naming and organization. You name the variables that hold your data, and you name your functions so that you can tell what each one does so that you can use them in the proper order. In some sense, writing code for some task is like building a little private language that is perfect for talking about the one task that you need to do.

Just for the record here is the list that I am using to cover the essential voacbulary that you will see in this programming course. I will occasionally repeat this list marking off what we have already covered as a measure of progress.

 !bAddress, And, !bArgument, Array, Ascii, Assignment, Base, !bBinary, !bBit, Bitwise, BlackBox Test, Blocks, Boolean, Braces, Break, !bByte, Call, Case, Char, Class, Comment, Concatination, Conditional, Conditional Expression, Constant, Constructor, Continue, Control Structures, Declaration, Default, Delimiter, Double, Dynamic Memory, Escape, Expression, Extends, Factory method, Fetch, Field, Filter, Float, For, !bFunction, Garbage Collection, Generics, Global, Guard, Hash, Hexidecimal, If, Implements, Increment, Index, Inheritance, Integer, Literals, Local, Loop, Main, Member, Memory Model, Modulus, Objects, Operator, Or, Order, Output, Parameter, Parentheses, Pointer, Polymorphism, Precedence, Primitive Type, QuotedQuotes, Radix, Real, Record, Recursion, Refactor, Return, Scope, Self, Stack, Static Memory, Store, String, Struct, Structure, Switch, Syntax, This, Tree, Types, Unit Test, User defined Type, Unicode, UTF-8, !bVariables, Visibility, While, WhiteBox test, Xor

::S Javascript
==Javascript
Javascript is a scripting language that is built into all the browsers. The word 'scripting' is generally added to a computer language to indicate that it is intended for light use and thus may lack some of the features of a larger more nuanced language. The typical thing that is left out of scripting language is sadly some of the error checking that help programmers more quickly find bugs. The theory being that scripts are small and if you make mistakes, you can just look over your code and fix it, no need for extra stuff to insure that the code is working correctly.

The language Javascript has almost NOTHING to do with the language Java. The name came about because Sun was promoting Java as being the language of the Web and the folks building the browsers in the early days decided that they should just let Sun pay their marketing bills. They would call their language Javascript (instead of calling it B or something like that) and let people be confused that the browser was using the same language, "Oh, yeah, I think I've heard of Javascript, that's the language of the web, right?", when in fact the javascript compiler can not read Java code at all. They are completely different languages.

Interestingly enough around the same time, when Microsoft decided that they needed to include Java as one of the languages that they offered, they followed the Java specification so that their compiler could run real Java code. They also decided that there were a few places where they could improve the java language so they added in some extra features that didn't conflict with the Java standard and named their language Java++, (similar to C++ being an extension of C - C++ is C with some extra stuff). Well Sun did not like that. They were worried that people would use those extensions that Microsoft had added and would start to think that the extensions were actually part of the Java language. Microsoft was trying to STEAL their language! Lawsuits were threatened so Microsoft agreed to change the name to J++. Sun was still unhappy. That name was still too close. "OK, Fine!" Microsoft said, "we won't use that name either. We will call the language C# which is sort of C++++, it is more than C and more than C++, and has nothing to do with Java, will that work?" That was apparently OK so there you have it. C# is practically idential to Java to this day, whereas Javascript, which seems to share a family name is actually quite different. So much for truth in advertising.

==HTML Script Section
In order to include javascript into an html page, similar to the way you can have either internal or external CSS sheets, you can have either internal or external javascript. I will start you off with internal javascript which allows you to keep everything in a single HTML page and is appropriate for all these small examples and small projects, but once we start working on real projects we will always use a separate external javascript file which is the method I prefer. Also, doing things in separate files allows me to skip over the tedious repetitive DOCTYPE, Meta, Head, Title, Style, Script etc tags that are required in the HTML document but which tell you nothing informative about the javascript. 

So for now, add this script section to the Head of one of your example HTML files

<div style="background-color:#eee;">&nbsp;&nbsp;&LT;script&gt;<br/>&nbsp;&nbsp;&nbsp;&nbsp;alert("Hey, look, an alert!");<br/>&nbsp;&nbsp;&LT;/script&gt;</div> 

save the HTML, refresh the page and watch the alert.

I want you to notice the timing. The script is up in the Head before you get to the contents, the Body, of the HTML. When you refresh the page you should see that the contents of your browser goes blank, because you have not yet loaded the page. The dialog pops up, and the screen should still be blank because you are paused up in the HEAD of you HTML document. Then, after you click on the dialog, which dismisses the alert, the page should load and you see the contents.

It is NOT required that Javascript be installed up in the Head section of the HTML. You can in fact put script tags in the body. Just to see that, move the script down from the Head into the middle of the Body section, in fact put it between two words and see that the alert comes up while the body is only half painted. (Note: this demo does not appear to work when running chrome on my MacBook, it did work as advertised running on IE on my Windows PC.)

<div style="background-color:#eee;">&nbsp;&nbsp;&LT;body&GT; this is &LT;script&gt;alert("wait for it...");&LT;/script&gt;sweet!&LT;body&GT; </div> 

I am NOT recommending that you do this. Code should be up in the Head section. I just want you to be aware that the browser that is reading and interpreting your HTML is doing things in order and that timing can matter. One of the mistakes that you can make, (of course you WON'T make this mistake after I point it out) is that if you try to start using your javascript to alter what is out on the page BEFORE you have even finished loading the page, your code won't be able to find what it is looking for. You could, of course, install your code at the bottom of the Body section, which means it runs after the browser has seen the body. However it is better to have your code up in the Head, or even in another file and use a different trick (I'll show you in a moment) to delay the code from running until the Body has actually finished loading.

==External javascript
The preferred way to manage your javascript is to keep it in a separate javascript file, and then reference that external file from your HTML file. So put the single line javascript command into a file and give it a js extension.

--test.js
  alert("Hey, look, EXTERNAL javascript!");
  
And then put this link into the Head section of your example HTML file

<div style="background-color:#eee;">&nbsp;&nbsp;&LT;script src="test.js"&gt;&LT;/script&gt;</div>

Do note that the JS file does not contain ANY HTML tags. In particular it does NOT contain the script tag. That tag is HTML. The JS file is pure javascript and will contain NO Tags and NO Entities. Javascript is a different language entirely from HTML.

As I said earlier, I will present ALL the javascript that I show you as if it is in an external file, meaning I will NOT show it with SCRIPT tags wrapped around it. You are of course free to wrap it in tags and make it internal to a single HTML file if you wish OR you can make it external. The Javascript does not care and I don't care. What you do on your project is your choice.

The fact is for the next several examples all I will be showing is small bits of javascript code and I expect you to just copy and paste my examples into the script section of a single file to test them all out. Here is a template that you can use for that.

--sweet.html
<div style="background-color:#eee;"><br/>&nbsp;&nbsp;&LT;!DOCTYPE html&gt;&LT;html&gt;&LT;head&gt;<br/>&nbsp;&nbsp;&LT;script&gt;<br/>&nbsp;&nbsp;alert("Dude!");<br/>&nbsp;&nbsp;&LT;/script&gt;<br/>&nbsp;&nbsp;&LT;title&gt;Examples&LT;/title&gt;&LT;/head&gt;&LT;body&gt;sweet!&LT;/body&gt;&LT;/html&gt;</div> 

::S Comments
==Comments
All language have some notions of !ncomments. Most code is of course instructions for the computer. However Humans read and maintain code and sometimes what the programmer wants to do is put in side information that is NOT for the computer but is something for another human to read. These are generally things of the sort, "K will NEVER be bigger than 1000 so I don't need to test for that here."

There are two basic formats for comments, end of line comments and multi-line comments

==End of Line Comments
All 3 of our languages copied from C, which uses // (two slashes) as the first !ndelimiter for the comment, (the closing delimiter is of course the end of the line hence the name).

  alert("dude!"); // all of this is comment I can include code, aler("foo"); and it WON'T execute!
  
You can use this end of line delimiter to turn off a line of code. This is actually a VERY common usage. When you are debugging you often want to look at some value that is being generated so you may put in a line like this:

  alert("foo = " + foo); // I want to see the value of foo here
  
Later, when you have seen the value and seen that things are working as expected you COULD delete the line, but you may find yourself working on this code again and may once again want to look at that internal value SO you just leave the line in and COMMENT it out like this:

  // alert("foo = " + foo); // I want to see the value of foo here

Now instead of half the line being a comment, the whole line is a comment and the alert doesn't run

==Multi-Line Comments
All 3 of our languages also copied C for their multi-line comments. They use slash star, /* , as an opening delimiter and then use a star slash, */ , as a closing delimiter. So if you want to write paragraphs of discourse on what your code does, just start with /* and close with */ and everything between is effectively turned off.

  /* I could write lots of stuff
  right here to tell you what this next batch of code
  is doing, and then do it */
  alert("dude!");
  
Similar to what we mentioned above, one of the most common usages of the multi-line comment has NOTHING whatsoever to do with actual commenting. Instead it is used during debugging to disable large blocks of code, just wrap the code with delimiters and turn that large block off while you test something.

The language Java has one additional form of comment known as JavaDoc comments. It looks just like a regular C-style multi-line comment except that the opening delimiter has one extra star, it starts with /** instead of /*

The comment is EXACTLY the same as a regular multi-line comment except that the Java system includes a separate program named JavaDoc that reads java code, and it ignores ALL the code, and it ignores ALL the normal comments BUT it notices the multi-line comments that have that one extra star on the front and it EXTRACTS all those comments, wraps them in HTML and builds them into a website with the notion that you will be encouraged to massively document your Java code and then using the JavaDoc tool AUTOMATICALLY generate all the documentation about how your java code works.

It is not a bad system and much of the documentation for Java Libraries of external Javascript code is produced in this way.

All CS professors and industry wags encourage you to use lots of comments because they are there to help others understand your code. And helping other is good karma and socially responsible and all that crap. I will say the same thing. I just did it. Use lots of comments.

There. Now that I have discharged that social obligation I will tell you the truth. I don't use comments very much in my code. You will not see many here. The primary reason is simple. This entire BOOK is comments on how the code works and what it does. It does not need extra commentary in the code. 

However, if I am honest, I don't for the most part write comments in my code even when I am NOT writing tutorials with copious documentation like this. The reason is that in maintained code someone wrote the code and wrote documentation explaining the code. Then someone came in and "fixed" the code or "altered" it to do something else. Typically those fixes do NOT make it into the documentation so the comments no longer describe what the code is actually doing. When doing maintenance it is a mistake to believe that the code does what a comment says it does. So I consider comments to be only of limited historical value when trying to understand code. I prefer the notion that is sometimes called "self-documenting" code. The idea is to choose the names of your functions and variables so well that it is OBVIOUS what you code is doing at every single step.

In reality, I do write lots of documentation and explanation for my code, BUT I prefer to have it in stand alone documents like this one and NOT intermixed down inside the code. 

::S Alert
==Alert
That single line of javascript that we have used so far: 
  alert("Hey, look, an alert!"); 
  
Had some data which was a !nString - that would be the text characters inside the quotes - (that string had no name, it was an anonymous constant string, a !nliteral String) and we 'passed' that string into a function (the string was an input or an !nargument to the function) which was named alert. The semi-colon punctuation on the end of the statement is required. It is how you tell the computer that you have ended a line of code - (code can sprawl across multiple lines and you need to tell the computer when you are actually finished with a single complicated instruction.)

So the !nsyntax of that statement is function name followed by an argument list - which has parentheses as delimiters for the argument list - followed by a semi-colon. The particular argument list happend to be a list with a single item (if the function needed more items they would be coma separated) and that item happened to be a literal string which was delimited with quotes. 

I will not be writing sentences like the above very often it is tedious and generally not as clear as the code itself. None the less, there is a name for what I was doing. It is called, !nparsing, the expression. In this case the expression was a single line of code and when I parse it, I am telling you what each individual chunk of the line meant, what all the words were and what the punctuation was and what it all meant. Notice that the word "alert" showed up twice in that line. The first time, it was the name of a particular function in javascript, the second time, it did not have that meaning AT ALL! The second occurrence was just some random text inside a quoted string and as far as the programming language was concerned it meant NOTHING - just a pile of letters. So the syntax of that single expression was this:

  function-name(argument-List);
  
and argument-List happened to be
 
  quoted-String-Literal

Now that alert function, which is built into javascript, is a function that takes a single message, a single string of characters, and stuffs it into a dialog box and pops it up on the screen AND the process that was running, i.e. the code that had the alert function in it, stops running until the user clicks on the OK to dismiss the dialog.

This function alert, is VERY useful to the programmer because it does those two things, 1 it shows you something and 2, it stops and waits while you look at it. It is almost of NO use to an actual user of a web site because it STOPS and WAITS. We will use it ALL THE TIME to show you what is going on. You will use it all the time when debugging your code and then you will rip out all the alerts and almost never use them in finished code.

::S Variables
==Variables
A !nvariable is a named slot where you can store something, and once you have stored something there you can of course fetch that value back out and use it.

Most languages (C and Java included) associate something called Type with a variable. We will cover type in more detail in the next section.

The language that DO associate type with variables usually have some form of what is known a !ntype_checking, simply meaning that when you put some data into a slot the system first checks that the data value that you are stuffing into the slot matches the type of the slot.

Javascript (and Python) being scripting languages are NOT type checking languages.

==Declaration
The statement that defines a variable name is called !ndeclaration. Because type checking languages need to know what type the variable is, that is part of the declaration for one of those languages. Here is a declaration of an integer variable the way that you would do it in C and it Java. The statement is IDENTICAL in those two languages

  int x;  // Java and C: declares a variable to be named 'x' and to be of type integer
  
In the language of Javascript that statement looks like this:

  var x; // Javascript: you DON'T declare the type of a variable, you just declare its name

==Assignment
Once a variable has been declared you may then store a value into it. That act of 'storing' into a variable is called !nassignment. All 3 of our languages do assignment the same way using the = symbol.

  x = 3;
  
Note: when doing assignment the variable name (the name of the storage slot) is ALWAYS on the Left Hand Side, (LHS) of the = sign, the RHS (Right Hand Side) is always the value that you want to store into that variable. You would NEVER write 3 = x; (wow! It pains me to write that here in the text - it is just WRONG!)

==Simultaneous Declaration and Assignement
All three of our languages allow you to in one single statement to both declare a variable and to assign its initial value. They look like this:
  
  int x = 3; // Java and C: declares x to be int AND assigns it the value 3
  var x = 3; // Javascript: declares x and assigns it the value 3

==Variable Usage
When you want to !nfetch the value out of a variable, you just use the variables name so

  var x;
  x = 3;
  alert(x + 2); // should be 5

Note: The only reason that I mentioned LHS and RHS in a previous comment about assignment is that there is an obscure (to beginners) error message that comes out of C sometimes that uses those abbreviations, LHS and RHS. Noobs have NO IDEA (and why would they?) what the error message is even talking about. The observation is this: If I write the expression x+2 on the RHS of an assignment OF COURSE you want to FETCH out the value sitting in x. If I write x+2 in an alert as I did above, of course, I want to FETCH out the value sitting in x. BUT when I put x on the LHS of an assignment, I intend to STORE into x. I do NOT want to fetch the value in that case, I am actually going to OBLITERATE the old value and write it over with a new one. The point is this: in an assignment statement the variables that you see in the statement do different things on the different sides, the LHS is a STORE and variable name is being used to represent the ADDRESS of the slot x, on the RHS the variable is being used to FETCH a value from x and thus the variable name represents a VALUE, not an address. 

The obscure C error message is trying to say that LHS in an assignment MUST eventually be an ADDRESS. (C basically allows you to build more complicated expressions that essentially turn into addresses - Java and Javascript don't have as much flexibility and so don't get into the trouble that causes C to warn the programmer of this error.) 

Anyway, a statement like this:

  x = x + 5;
  
Is really using the variable name x in two different ways. This statement fetches out the old value of x (RHS), adds 5 to it, and stores the result back into x (LHS), thus incrementing x by 5.

==Incrementing
That last operation, updating a single variable, happens often enough that all the C-like languages (C, Java, Javascript and others) have an abbreviation of that statement so that you don't need to type the variable name twice.

  x += 5; // this is IDENTICAL to x = x + 5. It adds 5 to the variable x
  
This increment instruction (combining an operator with an assignment) is done the same way with all the math operators

  x *= 2; // double the old value of x and store it back into x
  x -= 1; // decrement x by 1
  x /= 3; // divide x by 3

We will see more about variables later but first you need to know more about the Types of things that variables can hold. 

::S Types
==Types
Every language had the notion of !ntype for its data. We divide the world of types into just two kinds, !nprimitive_types, which essentially resemble actual differences in the hardware systems of your computer and more complex types which we will call !nuser_defined_types.

==Primitive Types
Most languages have an !ninteger type for signed whole numbers. Most languages have a !nreal type for floating point or numbers with a decimal point. (In the stone ages, some computers did NOT have hardware for directly implementing floating point so if you wanted it it was essentially a user defined type - in fact one of the earliest projects that I had at Microsoft was to build a software emulator for computers that did NOT have floating point hardware). Nearly every language has a type for holding !ncharacter data (the primitive type holds ONE single Character - it is related to (but is NOT) a string because a string is a list of several characters and that does not typically fit in ONE SINGLE MEMORY SLOT so a String is considered to be a user-defined type even though Strings are already built into every language). Nearly every language also has a type for logical data called !nBoolean (Named after George Boole, a mathematician that worked on logic in the 1800s). So there are your primitives, and here is some code to show each of those 4 basic categories:

  alert("Character data: " + "5");
  alert("Integer data: " + 5); 
  alert("Floating point or Real data: " + 5.7);
  alert("Logical data: " + (2<3));

I told you that alert wants to take in a single arugment that is of type String which is will write out into a dialog box. What I have actually done in these 4 example is to first evaluate an !nexpression using a plus !noperation and those experessions all create the single String that alert is looking for. 

==Literals
In the very first example I had two Strings, one was "Character data: " and the other was "5". You can tell that they are both strings because they both have quotes around them. Quotes are the delimiter for String !nLiterals. The plus operation for two Sting literals is to perform the action of !nconcatination. It just appends the second list of characters onto the first to create a single longer String.

All the other examples worked because of a "behind the scenes" function which is known as !nType_coersion. When you try to add an integer to a string, the language realizes that those two types are not compatible so it "coerses" the integer up to a string type - basically changing the number 5 into the string consisting of the single character "5" and then plus can append the two strings.

The last example, the logical, was an even more complicated expression. The sub expression, (2&lt;3), involved two numbers and the operator &lt; which of course means less than. An operator like plus, '+', combines two numbers and produces a single number, so 2+3 will be the single number 5. The operators, less than, greater than, less than or equal, greater than or equal, is equal to, etc are all 'comparators', they are 'Mixed mode operators'. They take in two numbers, compare then and produce a result that is either true or false. The statement 2 is less than 3 has a Boolean value - it must be either true or fales. It happens to be true, and that is what the Boolean Type is. A Boolean is a single binary value that is either true or false, so all the comparators are operators that take in 2 numeric inputs as arguemtns and return one Boolean output value. It was that boolean output that got coersed up to a String value and then added (concatinated) to the string "Logical data " in that last example.

It should be no surprise that every primitive type has some way in characters to write a specific member of that type, and that is what you use when you want to create one of those types.

Integers are of course just written the way that you would expect, 347, -17, 0 etc. 

Real numbers have two formats. In one format you just write the number with a decimal point, so 0.0 is the REAL number zero, whereas 0 is just the INTEGER zero. 0.023 is a real number and so is -157.68. The second format for Reals is one that is familiar to engineers that are working with numbers in a large dynamic range so a number like 27 billion = 27000000000, has 9 zeros at the end, can be written 27e9 which means 27 * 10^9. 27 billionths would be 27e-9 and of course those number could be written with decimal points as well like 27.0e9 

Booleans, having only two values, true and false, are written just like that, all lower case. As a result those two words are usually !nreserved_words or !nkeywords in the language and you can not use those words as names of variables or functions. (C differe here - it does NOT use the words true and false - it thinks that 0 is false and any non-zero value is true - C does not know the different between and integer and a Boolean) I could have just used the word true in the javascript example

  alert("Logical value: " + true);
  
But you MIGHT have made the mistaken assumption that I could just write

  alert("Here is a word, " + dude); // this thinks that dude is a variable name so fetchs, coerces, and contatenates
  
Characters and Strings are wrapped in quotes AND here is one of the big language differences. In C and Java, they reserve the single quote character to be a delimiter for A SINGLE CHARACTER which is a primitive. So in C and Java 'A' and 'a' are both valid but 'AB' is NOT. Both C and Java use double quotes as the delimiter for Strings so "AB" is legal and so is "A", which happens to be a String but it just happens to be a string with only one character. In fact "" is a legal and often used character in all the languages, it is a null string with no characters at all.

Both C and Java (being earlier industrial strength languages) are obsessive about giving YOU the programmer control over the storage of all the information. A single character 'a' can fit in a single slot of memory, however a list of characters (even if it is only one) does NOT fit into a single slot you need to reserve multiple slots so that you can both keep track of ALL the characters in the string AND ALSO the length of that string so you can know how much memory you need for the string. So C and Java use different dilimiters so that you, the programmer, can tell it whether you meant the single primitive !nchar type 'a' or whether you meant the list of characters "a"

Javascript, being a scripting language for light use, does not bother with that distinction so what they did is different. They IGNORE characters as an individual data type and ONLY have String type. Javascript uses both delimiters, single quotes and double quotes, for strings. So in Javascript 'a' and "a" are both just Strings that happen to be a single character long.

==Quoted Quotes (ESCAPE)
There is one gotcha that shows up when you use delimiters like quotes to tell the system that you are entering a literal string. What if you want your actual text string to inclued the character quote? If I try to write a string like this:

  alert("Hey, my buddy said, "No Way"!"); // this is WRONG!
  
The trouble is that the first quote in front of the H started the string and the second quote in front of the N ended the string and the javascript compiler/interpreter expects to see a plus sign or  maybe a comma or some other syntactic element. It has moved out of String reading mode when it saw the second quote. So we need some way to tell the system that we WANTED that second quote to be treated as a literal quote value rather than being treated as a delimiter.

The way that the C language decided to do this (and nearly everyone afterword copies the C method, including BOTH Java and Javascript) was to introduce the character backslash \ as an !nescape character. When the string reader sees the backslash it means "treat the next character you see as a literal character and NOT as some sort of delimiter". So if I want quotes in a string I must ESCAPE them.

  alert("Hey, my buddy said, \"No Way\"!"); 
 
The two literal quote characters are now escaped so there is now one single string.

By the way, if you didn't try running my wrong example where I did not escape the quotes. Do give it a try. What you should see is that the alert never happens. THIS IS ABSOLUTELY THE MOST WRETCHED FEATURE of Javascript! Javascript by design fails silently. If you tried to put a string like that into either C or Java, the compiler would spit out an error message: "Hey you have an illegal String definition on line 37". You get to fix it before it ever runs. But the decision was made that since javascript is built into a browser and showing pages to ignorant users out on the web, they would be SCARED if the web page showed them an error message because of bad code, so Javascript, bless its little black heart, fails silently! When javascript sees a string that it can't read, or anything eles that it can't read, it just stops working. No error indications at all. No idea of where the mistake happened. Yer code was wrong so NO HELP FOR YOU! One single comma in the wrong place, one missing semi-colon and nothing works! Your code used to work just fine, you make a couple changes and now nothig works. So you know you made a simple mistake. Do you remember every single line that you touched with your editor? Can you find that mistake?

Javascript is without question the worst programming language that I have ever worked in (and I have worked in over 30 languages in my career). It is not that the language is so bad it is that the tools to help developers get the code right were just missing. Now having said that, the world had gotten MUCH better since the early days. NOW there are debuggers build into most browers, so when you javascript is not working it STILL fails silently but you as a developer can open up the debugger, rerun the page and make the debugger take you to the places where the code has problems.

One of the things that you CAN do and should do to minimize this problem of having the system break because of one minor change is to ALWAYS be running and testing your code. Type in a line - test it. Does it still run? Good type in one more line, run it, still good? Slow but steady.

Anyway, sorry for the digression, back to escape characters. 

The fact is, as soon as you introduce an escape character like \ into your string builder code you have created a new problem. You have effectively elevated the backslash up into being a new kind of delimiter, so what do you do if you wanted a literal backslash to show up in your string? You guessed it, you use the backslash to escape a backslash. So if you want a single backslash to show up in your string you type in two of them. If you wanted two you type in four.

  alert("Here is a string with a single backslash \\ and a single quote \"");

C also added, and everyone followed, the notion that they could use the escape character to enter special characters like NewLine and Tab and otherwise difficult to enter characters. \n is used to put in a line separator, \t is used to put in a tab character.

  alert("line 1 line 2");
  alert("line 1\nline 2");  

Last comment on escape. While Javascript did copy the C style escape character for building their strings they DO have an option that was NOT available to either C or Java programmers. Because they have TWO different delimiters for creating strings you can sometimes AVOID escapes by selecting the right delimiter

  alert('Hey, my buddy said, "No Way"!'); // illegal Java and C, but fine in javascript
  
This feature is actually used all the time in javascript. Remember way back in the discussion about HTML that the format for attributes inside of tags uses double quotes

  <a href="http://www.amazon.com">amazon</a>
  
If you are using C or Java and need a string like that you need escapes on the quotes that delimit the attribute value, but in javascript, you just use single quoted to delimit the string and escapes are not necessary. Because most Javascript is used to create HTML on the fly and because quotes are quite frequent in HTML Javascript programmers get in the habit of always using single quotes for their string literals.

==User Defined Types
I will defer this topic till just a bit later. All modern languages allow you to define your own types to hold your data in a format that makes sense for whatever it is that you are doing with your code. C, Java and Javascript all use slightly different methods for user-defined types.

==Types in the Different languages
I have already mentioned that Javascript essentially blows off the character type and only knows about Strings. Java also blew off some of the types that show up in C. Basically C, an old language from the 1970s, was very obsessive about keeping track of how much storage everything takes. This was appropriate for its historical time frame. Back then memory was VERY DEAR so much programming was about minimizing memory consumption. Also the hardware was must more varied, different main frames, different mini computers, different phone switches. The world has coalesced considerably to just a few micro processor architectures. 

In any case both C and Java have several integer types that differ only by size. short (16bits) int(either 32 or 64 depending on the machine) long(64bits). C but NOT Java also contains unsigned types, so C has unsigned short, unsigned int, unsigned long. (Unsigned arithmetic is available down in the machine language of nearly all machines and C gives you access to it, Java chooses to hide that feature). C defines a char type which is one byte long. Java Having been define AFTER the introduction of !nUnicode characters (an international standard for characters that includes all of the Russian alphabet, all the Chinese characters etc - and as a result is MUCH MUCH larger than will fit in a byte) includes both a byte character type so that it can interface with C data and also a char type that can hold any Unicode character.

Both C and Java have several floating point types, namely float and double. The names are sad, carried over from the days of FORTRAN. Float of course was meant to imply floating point numbers. Double, in the days of FORTRAN, meant -"those regular floating point numbers are so small they only hold a couple of digits and we need more accuracy for this calculation so we are willing to spend TWICE the storage space for this more accurate DOUBLE PRECISION number." The names are unfortunate because now days on modern microprocessors, the floating point is all done on hardware that by default works on a precision that is greater than what any machine did in double precision back in the old days of FORTRAN. So now days people just use "double" all the time as the name of the type for ANY floating point operations.

==Type Checking
Javascript (and Python) being scripting languages PRETEND that they don't have types, or rather you don't !ndeclare types for any of your !nvariables.

Languages like Java (and C and C# and C++ and Modula and Pascal...) do type checking. What is means is that when you create a variable (a named slot for holding some data) you at the same time tell the compiler what type of data you are allowing that variable to hold. In Java you tell the system that the variable x can hold an int and then Java will NOT let you put a boolean, or a char or anything other than an integer into slot x. Javascript on the other hand does not care what type you put into a variable but that does not mean that the data that you put into that variable does not have a type, it just means that you have no restrictions on the types that can go into a variable slot.

Type checking in a language is essentially an error detection/prevention system. Javascript does not have that system.

==Polymorphism
This word came into fashion with the introduction of !nObject_Oriented_Programming, but it refers to something that has been going on in languages for a long time. I just wanted to call your attention to it. !nPolymorphism is just the notion that a single function with a single name can behave in different ways if it is working on different types.

This has been true of nearly all operators (which are just functions in a different notation) ever since FORTRAN which was the first high level language written in the 1950s. I will give you an example with the + operator and I hope it reinforces your understanding of the importance of Type.

I already mentiond that + means concatenation when the two arguments are strings, so 'fred'+'bob' produces a new string 'fredbob'.

  alert('fred'+bob');

I have pointed out coercion - any primitive type is coerced up into a string when combined with a string.

  alert('t'+5);
  
BUT it should be no surprise that if the two arguments to + are both integers, plus adds the two integers and produces an integer result.

  alert(2 + 3); // alert was looking for a string so it coerces the integer result of the sum up to a string
  
The operator + is polymorphic. With integers it does numerical addition, with strings it does concatenation. 
  
So what does '2'+'3' produce? Write your own code and check it out. How about 5+'5'? How about '5'+5+5 or 5+5+'5'? Try all of these.

We are now into the realm of understanding Expressions and Operators which is our NEXT section. The point here being that you can't really understand expressions (which use operators to combine values) if you don't understand that values come in different types.  

::S Expressions and Operators
==Operators
An operator is actually just a function. Like all functions it takes in some argument values and based on those values it calculates a result and returns that result. The ONLY thing that makes an operator different from a function is the way that we choose to notate an operation. You are already familiar with operators because that is the way that we normally write down simple math. If you want to write down "2 times the quantity of 3 plus 4" you write

  2*(3+4)
  
Or, looked at differently, that long pile of English up above is the way that we "read" that fairly simple math !nexpression.

I am going to assume that you already know some algebra and are not going to have trouble reading simple math notation BUT in the interests of REMINDING you how that notation works and in order to CONTRAST it with the function notation that we will be using later I am going to take a BRIEF excursion through some Linguistic Theory. Oh BOY!

The operators that we use in mathematic and that we will be using in our programming languages tend to have some restrictions. Unlike functions that can take in any number of arguments, operators tend to work on either one or two arguments. We call the ones that take exactly TWO arguments !ndyadic operators and those that take in exactly one !nmonadic operators. As examples addition, +, is dyadic as is multiplication, *. Negation, -, is monadic. You apply negation to a single number like 2 to get -2. That monadic operator, negation, was applied in !nprefix notation. Meaning that you put the operator in FRONT of its argument. An example of a !npostfix monadic operator from math is, factorial. 4! is read "four factorial" and it means the number 1*2*3*4, the product of all the numbers up to four. Factorial is NOT used in computer languages, but 'increment, written with ++, is a monadic operator used in all C-Like languages. If x is a variable then x++ is that same variable incremented by 1. (more on incrementation later!)

So Monadic operators work on a single argument and so the only way to write them is either in prefix or in postfix notation. Usually the operator only supports one single notation, so for example negation MUST be applied in prefix form. In C, the operator ++ LOOKS like it can be applied in either prefix or postfix form. It is perfectly legal to write ++x and x++, however in reality there are two different operators, PRE-Increment that you apply in prefix notation and POST-Incrementation that you apply in postfix form. Two different operators (the behave differently) each with a fixed way that you apply them. They just LOOK like the same operator used in two different ways. The same sort of thing happens with dash, -. As an operator it can be used monadically to mean negation like in the expression -x. Or it can be use dyadically to mean subtraction in an expression like x-y.

Dyadic operators, which work on two arguments are typically written BETWEEN their two arguments, 3+4, 7*2, 8-6. This format is known as !ninfix notation. The operator sits IN between it arguments, it is INfix notation.

Linguistic theory tells us that we could in fact use all three notational variants for dyadic operators.

  3 + 4; // this is traditional math notation using infix for ANY dyadic operator
  + 3 4; // this is prefix notation, and the computer language LISP favors this way of writing
  3 4 +; // this is postfix notation, the language FORTH prefers this format
  
Most of what you will see in the C-Like languages is INFIX when you are dealing with operators. However, it is useful to understand that there are other notation and that there are actual reasons WHY one notation might be better than another in certain circumstances.

Certainly the main reason for using infix for operators is that nearly ALL of the operators in our computer languages are MATH operators and so we use something that MOST RESEMBLES traditional math notation to represent the math that is being done on our computers.

==Trees
I am going to draw the parse trees associated with 3 math expression (recall parsing is the business of figuring out the syntax, and meaning of a chunk of text - it is what the compiler must do with every bit of text that you type in as code). I am going to look at the expressions: 3+4, 2*(3+4), and 2*3+4. I am doing this to emphasize the difference between the way we must calculate those last two expressions, "two time the QUANTITY 3 plus 4" vs "two times three plus 4" the first one evaluates to 14, the second to 10.

<img src="ExpressionTrees.png"/>

Computer Scientists draw their trees with the 'root' at the top and the 'leaves' at the bottom, they are interested in hirearchy, simple at the top, branching complexity going down.

In this case, math expression, the leaves are values, and those values flow upward through the internal nodes (which are operators) calculations are performed and results pass on up the tree until the root, which is the LAST operation performed return a final result for the whole tree.

So the first tree, 3+4, those two values flow up the tree and the + returns the value 7. In the tree below that, we can't evaluate the * until we know the value of the + so the 3 and the 4 flow upwards to the + which evaluates to 7. Now that we know the + is 7 we have the two values for the * and 2*7 is 14. That tree evaluates to 14. In our final tree, the + is delayed while we evaluate the *. The * is 2*3 which is 6 and that flows up with the 4 to let the + evaluate to 6+4 which is 10.

The thing that I am pointing out with the trees is that the trees are unambiguous about the order of the operations. There are NO Parentheses in a tree. The structure of the tree tells you what to do. OR looked at the other way, it was the Parentheses that TOLD you what structure you needed in the Tree. It was the Parentheses around the (3+4) that told you that you needed to do that addition BEFORE you did the final multipy by 2. It was the Parentheses that forced the tree structure. Parsing, by definition, is the act of creating a "parse tree" from a sentence. Linguistic folks dealing with human languages are typically using parsing to "diagram sentences" but it is exactly the same theory that is used for dissecting math notation.

==Precedence
Math notation, and the computer languages that COPY math notation, involves the notion of !nprecedence. You MAY (or may not) remember your teachers telling you that you "do multiplications BEFORE you do additions". What that means is this: when you seen the expression

   3 + 4 * 2

You do NOT do it in the order written. You are supposed to do that AS IF was parenthesized like this:

  3 + (4 * 2)
  
If you wanted the addition done first you MUST use parentheses to force that.

The idea is that multiplication takes PRECEDENCE over addition. It is a stronger operator. It binds more tightly to its arguments than addition.

What you were probably NOT told is WHY mathematicians choose to use that rule. The basic reason is that it makes it easier to write polynomials without Parentheses.

   A*x^2 + B*x + C = 0
   
By making exponentiation the highest precedence, all the raising x to some power happens first, then you multiply those powers by the coefficients and lastly you add the terms. If all ops were equal precedence and just done from left to right you would need to parenthesize thusly:

  A*(x^2) + (B*x) + C
  
Which seems to highlight and call attention to terms that are not in any way special. The parentheses detract from actual hierarchy of the calculation which is that it is a sum of terms (meaning that whatever holds the terms together - multiplication) must be of higher precedence than the addition that is combining the terms.

So basically we use precedence of operators to eliminate parentheses in an expression. And then immediately, if the precedence is not right for a single calculation that we want to do then we require you to put in parentheses to make it right. Here is a simple assignement statement:

  x = 2 + 3;
  
We want the precedence of = (assignment) to be VERY LOW so that the addition happens first and only the final result is stored into x as the last step.

C (and Java and Javascript) does allow you to do things like this:

  x = 2 + (b = 5);  // assign 5 to b, add 2 to 5, store 7, into x. Two assignments, one single expression.

==Expressions
Finally expressions are what we have been writing here all along. Any pile of operators and values (and parentheses to override operator precedence) which evaluates to some final value IS an !nexpression. You use expressions all the time in programming. All the alerts that I have shown you so far typically had expressions as arguments. The most common alert is something like this:

  alert("foo is " + foo); // the value of foo is displayed with an identifying string prepended

Back to a question from an earlier section. Given the polymorphic meaning of +, concatenation for strings, addition for integers and given the behind the scenes coercion of types up to strings, and given the precedence of operators what does the expression 5 + 5 +'5' evaluate to? Does it first add the two integers at the front to 10, then it sees a sting so it coerces the 10 to a string and then appends 5 to get 105, or does it look ahead, see the string coerce right from the beginning?

My answer is - I don't know for sure (I do have a pretty good guess) - and more importantly I don't care. I know the things that I know, the things that I use all the time, BUT anytime I don't know for sure, I parenthesize and force the behavior that I want. Basically I KNOW what (5+5)+'5' will do (105) and I KNOW what 5+(5+'5') will do (555) so why would I write an expression that it is NOT clear which expression I actually want. It is indeed a judgement call!

==Prefix and Postfix notation
One last sidebar comment on these alternate notations that are NOT the traditional Infix math notation:

Prefix notation was described to me when I was studying Logic in Math Grad School and was called "Polish" notation. The reason being that Polish Logicians preferred using that notation when they were writing their logic formulas. WHY? Because UNLIKE Infix, it does NOT require parentheses to override bad precedence choices. You can FORCE a particular parse tree by just rearranging the order in which your operators occur. I will write the two expression that I showed way back with the tree pictures.

  2*(3+4) // in prefix is * 2 + 3 4   in postfix 3 4 + 2 *
  2*3+4   // in prefix this is + * 2 3 4  in postfix  2 3 * 4 +
  
The prefix * 2 + 3 4 means of course, "multiply 2 by what you get when you add 3 and 4". The prefix + * 2 3 4 means, "add the result when you multiple 2 by 3 to 4". The polish logicians liked "Polish" notation because by eliminating parenthesis from the formal language that they were using for describing logic, they could simplify the proofs about what a logic language could or could not do. Notice: they didn't care that it made the logical language itself harder to read, no one actually reads that logic language, the logic language was invented to represent formally what you could or could not say so that you could then prove results about the limitations of logical languages.

The postfix notation, was developed later by folks doing computation and was also known as "reverse Polish". It turned out to the the BEST notation for actually calculating the value of an expression. Almost for sure the C compiler and the Java compiler, run their parser on the expression that you wrote in infix, used the parentheses to figure out the correct tree shape and the translated that tree into reverse polish when they do their code generation. It works like this:

Here is a reverse polish string: 

  3 4 + 2 * 
  
To evaluate, when you see a value, push it to a stack. When you see an op, remove the top two values from the stack, perform the op, push the result onto the stack. 

So I see the number 3, well that is a value so push it onto a stack. My stack is now 3. I see the number 4, another value another push to the stack. My stack is now 3 with 4 on top. Next I see a plus. Well plus needs two arguments. There they are, the top two on the stack pop them off, add them, 3 and 4 is 7 so push 7 onto the stack. The stack is now 7. Next I see a value 2 so push it onto the stack, Stack is now 7 whith a 2 on top. Next is multiply. Pop the 7 and the 2 off the stack, multiply to get 14, push the 14. All done. Your final result is on the stack.

The trouble with the prefix notation is that it puts the operators FIRST. "Oh, first we do a multiply" You see that you need to do a multiply but you HAVEN'T seen the numbers yet that you need to multiply. Postfix on the other hand puts all the leaves in front of the operators. As a result the very moment that you see an operator in the post fix string, you know that you have JUST finished collecting the very last value that you needed in order to evaluate that op.

Postfix is the 'execution' friendly notation, it is the best way to actually calculate the value of an expression, but it is NOT easy to read or to write. (I mentioned the language FORTH - a simple computer language still in use - it does EVERYTHNG in reverse polish) 

We humans seem to like INFIX notation. We do better with 3+4+5 then we do with 3 4 5 + +.

I know, I know. Too much theory. Too much talks. You just want to write code. More examples. Less talk. I hear and obey.

::S Functions
==Functions
There are many functions, like alert, that are already defined in javascript ready for you to use, but we are going to focus now on how to build your own functions. Suppose you want a function that will allow you to square a numbers. You want to be able to pass in a number like 5 and have it give you back the number 25 which is 5 squared, 5*5. Here is how we do it:

  function square(n){return n*n;}

The name of the function is 'square'. The keyword, 'function' was used to tell javascript that we are defining a function. The '(n)' that came immediately after the function name is the 'argument list'. When you pass values into a function they take on the names that were in the argument list, so if I !ncall the function like this:

  square(5);

While the function is 'running', the value 5 that was passed in lives in a temporary (a !nlocal) variable that is named, n. What this mean is that in the guts of the function, that would be the stuff in between the braces {return n*n;}, I can use the name n and that will represent the value that was passed into the function. The keyword 'return' is used to mark a value that will get passed back to any expression that used this function. In the code we wrote we said that we should return n times n which is n squared. So here is the code that will define and then use a square function.

  function square(n){return n*n;}
  alert("5 squared is " + square(5));
  alert("237 squared is " + square(237));
  var x = 4; // I can store a value in a variable
  alert("4 squared is " + square(x)); // I can pass a variable value into a function
  alert("5 squared is " + square(x + 1)); // the arithmetic happens before it goes to the function
  
==Variable Scope
One of the notions that seems mysterious to noobs but quickly becomes natural is the difference between !nGlobal and !nLocal variables. IF I declare a variable OUTSIDE of a function definition it is GLOBAL. It is in some sense available to any function at any time. On the other hand if a variable is declared either INSIDE a function OR if it is in the argument list that defined a function is it LOCAL to the function. Local means that variable only makes sense while you are inside that function.

  var s = "dude"; // global string assigned the value 'dude'
  function showString(s){
    alert("Showing String: " + s);
    s = 'sweet'; // changing s (which is LOCAL because it was defined in the argument)
    alert("after change S is " + s); // showing the change
  }
  function showGlobal(){alert("Global S is " + s);} // s was NOT defined in the function so it uses GLOBAL s
  alert('OK, here we go');
  showString(s); // pass global into function show it and change it BUT
  showGlobal(); // Global s is still 'dude', ShowString changes a local s NOT the global s

I COULD have changed the value of GLOBAL s from down inside a function. Because that ShowGlobal routine did NOT declare s anywhere inside the function definition, than any use of s in that function is refering to the GLOBAL variable. If I changed s with an assignment in that function I would have changed GLOBAL s.

The reason that I call this to your attention is this: Functions almost always want to work ENTIRELY with local variables. In general you do NOT want your function messing up some variable in the outside world. "What happens in Vegas STAYS in Vegas". Generally the isolation is good. The variables declared inside a function are like scratch paper, used temporarily during the calculation but then thrown away when the function returns. Function that do NOT do EVERYTHING locally are given a special name, "a function with SIDE EFFECTS". 

The primary utility of local variables is that by declaring a variable in a function it allows you to reuse variable names without worrying if someone on the outside or even in any other function at all used that name.

The generic term for this notion is !nScope. The Scope of a variable is essentially identifying which code can SEE and access a variable and which code can't see and access a variable. I have made it look like there are only two levels of scope for variables, GLOBAL and LOCAL. Our three languages do in fact have some other levels of scope, but they are IMHO unimportant. One of them is known as BLOCK level scoping and I will mention it when we get to loops.

One of the nasty bugs that you will eventually make is when you FORGET to declare a variable inside a function. In that case the variable that you wanted to be local is now global. Your function now has unintended side effects in the outside world and tracking that down can be difficult in a big project.

==Language Differences
C and Java use an ever so slightly different syntax when they define a function. Because they are type checking, just like with variables you MUST tell the compile what TYPE of value the function is going to return. So here is the square function defined in all three languages:

  function square(n){return n*n;} // javascript 
  int square(int n){return n*n;}  // C
  public int square(int n){return n*n;} // Java

As you can see, both C and Java needed to identify BOTH the type that would be returned and the types of the input variables. Also Note that the return TypeName that started the C and Java statements told those languages that this statement was DECLARING something, and the argument list in the parentheses told it that it was defining a function so C and Java do not need a keyword, 'function', like javascript does. 

Java had ONE other word that is NOT present in C. Java has one extra notion, !nVisibility, missing in both C and javascript, similar to GLOBAL and LOCAL variables, Java wraps both variables and functions up into things called a !nClass. You may think of a Class as being a bit like a country. Every person has a country. Every function and variable in Java has a Class. The boundaries between classes are there to enforce a separation of concerns. Any variable or function must decide and declare whether OTHER classes can see or use that variable or function. If you declare a function public then anyone in any other country/class can see and use it, OR you can declare it private, in which case ONLY functions in your own class can see and use that private function. The utility is that a class can have parts exposed to everyone and other parts that are "under the hood" which can only be seen and controlled by the class itself.

==Return
One of the key words that ONLY makes sense inside a function is 'return'. Return will exit the function and pass back a single value to the outside world. It is possible to write functions that do NOT return anything. I did it earlier when I wrote a ShowString function. That function ONLY had alerts in it. It did no computation and passed nothing back. (That function had 'side effects' - performing output by calling alert is technically a side effect - it changed something in the outside world, namely your computer screen, that was NOT a local variable.)

In javascript this is easy, you just don't use a return statement. In C and Java you can also just not use a return statement BUT in C and Java you still MUST declare a return type. So they invented a special return type named 'void' that means returns nothing.

Just to stuff some more vocabulary at you. In the OLD days of Fortran and Basic, they went to pains to distinguish functions that returned values (which they called functions) and functions that did NOT return values which they called !nsubroutines - very much a MATH bias - in math functions return values). Nowdays we would use the term !nvoid_function instead of the term subroutine. And in fact now the term subroutine and the term function are pretty much used interchangeably because that old distinction has been lost to time. Also, just for the record, you have seen me use the term, "when you call a function.." I don't use the phrase "when you use a function...". The word CALL also came from the stone ages of FORTRAN. When you created a FUNCTION, a good proper VALUE RETURNING entity, well you could just use it in an expression like X = SQUARE(5) + 3 because it returned a value. BUT if it was a subroutine, OMG! it doesn't produce a value, you better NOT use that subroutine in an expression. So what can you actually DO with a subroutine? You can CALL it. So the Fortran statement for invoking or using or launching a subroutine was CALL SUBNAME(ARG1, ARG2). They used CALL as a keyword to invoke subroutines. Ever since that day programmers, even those who have NEVER even heard of FORTRAN, will "call this subroutine to do this" or even "call this function..." something that NO Fortran programmer would ever do. You can't CALL a function, it returns a value. So this is a case where the English language as used by programmers is extracted from a language that almost no one usese anymore. Programmer's just hear other programmers talk about 'calling' a function and never think twice about why the word is call. When you get right down to it, why do you 'return' from a function? Is it just because the keyword that was selected over a half a century ago was the word 'return'?

==Arguments
The square function took in only a single argument. If you have more, you declare them with a comma separated list. As you would expect, javascript just lists names, C and Java list both name and type.

  function msg(a, b){return b + 2*a;} // javascript function with two arguments
  int msg(int a, String b){return b + 2*a;} // C or Java (Java does not REQUIRE that you say 'public' or 'private')

You can also define a function that has no arguments at all - which we did when we wrote showGlobal. You just define the function with an empty argument list, ().

==Signature
The list of arguments (and their types) and the name of a function collectively are called the !nsignature of the function. So that function above, boo, that I defined for C or Java would have a signature of int boo(int, String).

The definition of a function has ALL the details about the function, the names of the arguments, how it actually works etc. 

The signature, on the other hand, is an abbreviated view of the function. It is the view that the outside world has of that function. In order to call the function boo, I clearly needed its name. I needed to know the what arguments to pass in, an int and a String, I did NOT need to know the names of those arguments - after all the names are just the names of LOCAL variables that ONLY make sense in the interior of the function. And the actual implementation of the function is also up to the function, not up to the outside world.

C uses the notion of function signature for the purpose of !nInterface. Part of the way that the C compiler checks that you interfaced properly with some function is that it looks whether the way that you called the function boo, matched the interface for boo.

Java uses the notion of function signature for the same purpose as C, but also has an additional feature. In java I am allowed to have TWO different functions that share a common name. I can have boo(int, String) and boo(int, int) and it is easy in a type checking language to tell which one I mean, boo(5,5) was the second, boo(5,'5') was the first.

Javascript doesn't do any of that, but the name, !nsignature, persists across all languages because even if the language does NOT check that the interfaces match between the way that you defined a function and the way that you called it, the Programmer NEEDS to know the interface or the signature of any function that they call.

I have introduced the word 'interface' here and made it sound like interface and signature are identical concepts. They are ALMOST identical concepts. Java has elevated the word, 'interface', up to a specific technical meaning that I will get to later. The two notions are SO close however that in casual conversation most programmers use those words almost interchangeably.

To reiterate, a function's signature is just the minimum documentation that you need to know to call that function, it's name and the types of its arguments.

==Pig Latin
Just for fun I am going to write another function for you as an example. It will use some concepts that you don't yet know BUT you may be able to read this code anyway. The idea is simple, "here is a string of english" and we will write a function pigString that will convert it to pig-latin "ere-hay is-way a-way ing-stray of-way english-way".

The primary reason is to show you that Javascript contains LOTS of built in tools for processing strings and text and I don't want you to give you the impression that the ONLY computations that we ever do are just fiddling with numbers. That is the BOREING part of programming. String processing is far more interesting!

Before I write the code for you, I will tell you the basic plan of attack. You hand me a string which is one big long list of letters. I need to split it into words (and I do that by looking for the space character that comes between each word. Once I have a list of words, I need to convert each word one at at time into the pig-latin form of that word, which I will do with a function that I will call pigWord. Those words then need to get glued back together into a single string of text which I can then alert out.

Converting a single word to pig-latin requires that I find the first vowel that shows up in a word. You break the word into a front section before the first vowel and a back section which starts at the first vowel, if the front section is empty you return back-way and if the front is NOT empty you return back-front+'ay' so 'is' turns into 'is-way' and 'his' turns into 'is-hay' (and technically for my code a wrod like 'mr' which has no vowel, turns into '-mray').

So yes, in the code you will see two functions, a high level one 'pigString' and a low level one 'pigWord', you will see me splitting a string of text into words, you will see me looping though every word on the list, converting them one at a time and gluing them all together into a single result and then alerting that out.

  function pigString(str){
    var words = str.split(' '); // split into words
    var result = ''; // start up a local variable with nothing in it that will eventually hold final result
    for(var i in words){  // this for is a loop that fetches each word from the list to a local var words[i]
      result += pigWord(words[i]) + ' '; // append each pig-word (and a space) to the growing result      
    }
    return result;
   }
  
  function pigWord(w){
    var regexp = /([^aeiouy]*)(.*)/  // this regular expression captures all non-vowels and then everything else
    var capture = regexp.exec(w); // capture is now a list with two captures, front=capture[1] and back=capture[2]
    if(capture[1] == ''){return capture[2]+'-way';} else {return capture[2]+'-'+capture[1]+'ay';}
  }
  
  var english = 'here is a string of english';
  alert(english);
  alert(pigString(english));
  
Check it out!

==Next up

I really only need to cover about 3 more things in this chapter on generic programming (and yes, the above code used all three of them!)- 1) IF statements that choose between two blocks of code, 2) loops and arrays for processing lists of items one at a time, and 3) regular expressions for searching through text. 

When we have covered all the language basics, we will switch into project mode where we will start using the tools that I have showed to you to start building projects and applications.
  
==Progress

Here is the list of vocab once again with the words that we have covered highlighted:

 !bAddress, And, !bArgument, Array, Ascii, !bAssignment, Base, !bBinary, !bBit, Bitwise, BlackBox Test, Blocks, Boolean, Braces, Break, !bByte, Call, Case, !bChar, Class, !bComment, !bConcatination, Conditional, Conditional Expression, Constant, Constructor, Continue, Control Structures, !bDeclaration, Default, !bDelimiter, !bDouble, Dynamic Memory, !bEscape, !bExpression, Extends, Factory method, !bFetch, Field, Filter, !bFloat, For, !bFunction, Garbage Collection, Generics, !bGlobal, Guard, Hash, Hexidecimal, If, Implements, !bIncrement, Index, Inheritance, !bInteger, !bLiterals, !bLocal, Loop, Main, Member, Memory Model, Modulus, Objects, !bOperator, Or, Order, !bOutput, !bParentheses, Pointer, !bPolymorphism, !bPrecedence, !bPrimitive_Type, !bQuotedQuotes, Radix, !bReal, Record, Recursion, Refactor, !bReturn, !bScope, Self, Stack, Static Memory, !bStore, !bString, Struct, Structure, Switch, Syntax, This, !bTree, !bTypes, Unit Test, User defined Type, Unicode, UTF-8, !bVariables, !bVisibility, While, WhiteBox test, Xor
 
::S Conditionals
==Conditionals
We are now goin to look at the !nif statement, which is also called a !nconditional or sometimes a !nguard. The syntax is identical in all of our languages:

  if(booleanExpression){block1;}else{block2}
  
This statement chooses between EXACTLY 2 blocks of code, block1 or block2 based on the result of the booleanExpression. A !nblock of code is any pile of code, one statement, or many statements contained between two braces. IF the booleanExpression is true than the system executes block1 OTHERWISE it executes the 'else' block which is block2.

==Normal Indenting
Now the fact is, while I have written this on one line, very few programmers actually do that. The reason is just a stylistic difference. Most beginners are taught to ALWAYS indent code that is within a block - So that same generic thing that I wrote above would look like this using normal indentation practice:

  if(booleanExpression){
    block1;
  } else {
    block2;
  }

IF you do this indenting correctly, what you should find is that ANY line having a CLOSE Brace, }, is OUTDENTED, i.e. on a line with less indenting that the line just before it, AND if you scan up the page from that close brace moving past all the indented code, you should find that the first line that is indented EXAXTLY the same amount as the close brace is the line that contained the OPEN brace corresponding to the close brace. 

Do look back at the example and see that this is true. IF you scan up from the close brace on the else line, the if line is the one that vertically aligns with that close brace, and indeed the if line ENDS with the open brace that opened the first block. Similarly, the very final close brace vertically aligns with the 'else' line and indeed the else line ENDS with the open brace for the second block.

The PURPOSE of indenting in this way is so that you can easily and quickly visually scan some code and LOCATE the pairs of braces that match one another. You NEED to be able to do this, because typically the blocks in your code are parts of conditionals like these and in the same way that the conditional can skip over an entire block you as the programmer need to be able to SEE where those block are so that you in your logical thinking about where the code might go can skip over entire blocks.

The indenting rule that I personally use is the same as the one that everyone else uses with only one exception. IF the block is so short (exactly one statement of possibly two short ones) you MAY put it all on one line. Note that this still accomplishes the desired purpose of indenting, you can instantly locate the open brace associated with any close brace. The normal indenting practice means that the ONLY place that you find a close brace is as the first character of an OUTDENTED line. My exceptional case allows you to END a line with an close brace that is the same line that opened that block.

The style that I use is what javascript coders do all the time. C and Java zealots will look at this coding style and conclude that javascript programmers are just uncultured pigs that don't know better. I am in fact a Java programmer that had to write Javascript for about 5 years and have modified my style accordingly.

The ACTUAL Style rule that I pass on to all my students is this. If you have a job, they are paying you to write in what ever style they dictate. THAT is the proper style! On the other hand if you don't have a job, COOL. Do whatever works for you and your crowd. Anyone, working or not, SHOULD be flexible enough to handle ANY stylistic variant that they get exposed to. This is NOT to discount the importance of style. Style is a communication skill not terribly different from driving on the RIGHT HAND SIDE of the road. If EVERYONE does it the same way Chaos and accidents can indeed be avoided. BUT the fool that tells you that you MUST drive on the RIGHT because ABSOLUTELY EVERYONE with a brain does, has just not yet traveled abroad. 

==Else is NOT required
You are allowed (and it it quite common) to have a conditional that does NOT have the else block. It would look like this:

  if(boolean){
    block;
  }
  more code here
  
When you see a block like that. Once again, if the boolean is TRUE, then you do the block, If False then you skip the block. In either case you continue at the line, 'more code here'

The IF ELSE statement chose between two alternatives. This more abbreviated block has a single block that is either executed or not. It is this form that essentially led to the alternate name for a conditional statement calling it a "guard". The way you think about it is this. You may have a chunk of code that it is not safe to execute unless certain conditions are true. For example you might have a chunk of code that will safely remove an element from a list of elements BUT it is NOT safe to run that code if the list is Completely empty! So what you do is GUARD that remove element code. You write something like this:

  if(list is not empty){ remove element from list; }
  
The "remove element block" has been "guarded" by the boolean expression. This is just a nomenclature difference. 

==ELSE IF
So an if without and else, has a single block that MIGHT run (if the condition allows it). An if with an else has two blocks EXACTLY ONE of which will run. What if you have 3 or more blocks and you want to run exacly one of those block? There is a structure that performs that task. It looks like this:

  if(boolean1){
    block1;
  } else if(boolean2) {
    block2;
  } else if(boolean3) {
    block3;
  } else if(...) {
    ...
  } else {
    final block if ALL of the booleans were FALSE;
  }
  
The way that this structure works is that THE FIRST BOOLEAN expression that is true, allow the corresponding block to run AND ALL OTHER BLOCKS are ignored. So the ONLY way that you get block 4 to run is if boolean4 was TURE AND boolean1, boolean2 and boolean3 were all FALSE.

There is no magic to this structure. If you need it you uses it. In my experience you need this ONLY very rarely. You will use a single IF all the time, and IF ELSE is fairly common, but ELSE IF is rare.

==Switch Case Default
There is a completely different structure for achieving EXACLY the same things as a long ELSE IF chain, called a Switch statement. I have used this structure when I am writing compilers and no where else. It was introduced in the language C and has thus survived into all the C-like languages which include both Java and Javascript so I will introcued it but I don't expect you to use it.

The reason it is convenient for compilers is this: when you are doing language processing - reading a computer language that is - you are typically marching across a string that was the code that you are trying to interpret and you are looking at each character in turn. If the character was a '+' you will be doing addition, if it was '*' you will be doing multiplication, if it was ...

The Switch statement looks like this:

  switch(numeric or character expression){
    case 3: 
      block of stuff to do if the numeric expression had the value 3;
      break; // this statement is required so you EXIT the switch and DON'T fall into the next case
    case 17:
      block of stuff to do if the numeric expression had the value 17;
      break;
      ...
    default;
      stuff to do if NONE of the above cases captured the value of the numeric expression
  }

There is no ordering requirement on any of the cases. It is doing exactly the same thing as the ELSE IF structure looking from block to block trying to find one where the guard, in this case a number (or a single character) allows a block to run. All this statement saved you was from writing

  var x = some number;
  if(x == 3){
    block3;
  } else if (x == 17){
    block 17;
  } else if ...
  ...
  } else {
    final else block;
  }

The notion is that it is easier to read "case 17:" than to read "} else if (x = 17){". This notion of having a marginally better syntax has been called, "syntactic sugar", just sweeten up the syntax by a tiny bit. In the days that C was developed, writing compilers was one of the main things that people did with computers. The need for this sugar has pretty much gone away.

==Boolean Expressions
Every one of the conditionals and guards that I have been showing is ENTIRELY dependent on a boolean expression that evaluates to either TRUE or FALSE. I have mentioned previously that all the numerical "comparison" operators for numbers like 2&lt;3 or like x&gt;=5 are boolean expressions. Those operators take in two numbers and output a boolean.

We also have several Boolean operators that take in one or two booleans and produce a single boolean output.

==NOT
The first simple boolean operator is monadic. It works on a single boolean variable. NOT flips the value of a boolean so if x is TRUE, the NOT x is FALSE. If x is FALSE, the NOT x is true. The way we write NOT in code is with the prefix operator !. So in code you can have a single boolean x and not x is !x. You can apply ! to any boolean, including some other expression so (x&lt;2) is true if x is less than 2 and so !(x&lt;2) is true only if x is NOT less than 2. (Of course, there is another way to say the same thing: (x&gt;=2)).

One of the numeric comparison operators that is very important is testing for EQUALITY. Sadly, we used the equal sign to mean 'assigne a value to a variable' so x = 3; does NOT mean test if x is actually 3. The symbol that C used and that nearly everyone copied is ==, a double equal sign. So x == 3 IS the way that you test if x is actually 3. x == 3 IS a boolean expression with a true or false value.

I said "sadly" because thousands of programmers every day, forget this, or accidentally type in one equal sign when they wanted 2 (or the other way around). And as a result code like this:

  if(x = 3){ do something with x;}
  
fails because instead of tesing if x was 3, it stored the value of 3 into x obliterating whatever was there and then, because 3 is non-zero, it treats the expression x = 3 as a boolean that is true, so it does something with x which is IN FACT 3 as expected.

So this code typically runs just fine and is smashing values to 3 because it was doing an assignment instead of a test. It is just a source of bugs. Very easy to make that mistake.

C seleceted == to be the operator to mean EQUALS, and having selected ! to mean NOT, they selected != to mean NOT EQUALS. So you don't need to write !(a == b) you can just write (a != b). Both mean a does not equal b.

==AND and OR
The other two very common boolean operators are for Logical AND and Logical OR. The meanings of these two operators is nearly but not completely identical to the way that we use them in English.

The definition of AND is identical. The Operator that C uses for Logical AND is &amp;&amp;, a double ampersand. When you say, "the sky is blue AND the wind is blowing" you place the operator between two expressions and you are claiming that BOTH of them are true. In other words if A is true and B is true then the expression A AND B is true. If either A or B (or both) is false then the expression A AND B is false.

Logical OR is in some sense the opposite of AND. Logical OR is nearly always true. IF A is true or if B is true (or both) than A OR B is true. The ONLY time A OR B is false is when BOTH A and B were false. English certainly uses this form of the word 'or'. So English usage lines up with the computer Logical definition but the English language sometimes uses a different interpretation of the word, 'or', which is know as Logical Exclusive OR. The difference is this: Regular Logical OR is true when A is true or B is true or if both are true. Exclusive OR is true if A is true or B is true BUT NOT BOTH!

When in English we say, "I am going to go to the park or I am going to go to the store." Technically it is a bit ambiguous! Do you think it implies that I am going to do Either A or B BUT NOT BOTH. Am I listing EXCLUSIVE alternatives or INCLUSIVE alternatives.

Fortunately, when working with computers, we don't much care what is meant by slightly ambiguous language in English. We just use well defined Logical operators and they do what they do. In C the operator that was selected for Logical OR was ||, the double pipe. The operator that was selected to mean Logical Exclusive OR was ^, the up arrow. 

So now that you have those operators, NOT AND OR XOR EQUAL NOT-EQUAL, you can do things like range testing.

  if(a>=3 && a<=7){alert("a is in the range from 3 to 7 inclusive.");}
  
==Shortcut execution
The two logical operators, OR and AND, have a special feature which is known as !nshortcut_execution. What this means is this: Suppose I see an AND expression like A AND B. Suppose I start processing that in order, "Well in order to be true both A and B need to be true so let me fetch out the value for A ... which is FALSE", at this point since A is false, I Don't even need to look at B. The entire and expression is FALSE. That is the shortcut. When you evaluating a Boolean Expression with AND or OR, IF from the value of A alone you can predict the final result of the boolean expression then DON'T bother evaluating B.

This sounds like it is just a simple little efficiency thing but it is NOT. It is a way of making it possible to AVOID writing extra guards into your code. Suppose you need code like this:

  if(A){  // Before we do ANYTHING first check A
    if(B){  // We ONLY check B IF we already know that A is true (perhaps B crashes if A was false)
      C; // finally now that we have checked both A and B we can perform C
    }
  }

The short cut AND allows you to write that code like this:

  if(A && B){C;}

You see, if A was false, B never runs and C never runs, same as the nested conditionals above.

Perhaps a more important view point is this: the short one line of code really is identical with the top line. ANY time you use that AND operator or that OR operator it will be shortcutting and is thus EQUIVALENT to a more deeply nested conditional structure. It means you you did NOT evaluate BOTH A and B and based on that guard you do or don't do C. Instead you evaluated A and based on that you May or May not have evaluated B, and then either did or did not do C. 

I will give a more concrete example after we look at arrays which is where this shortcutting is very useful to avoid 'array out of bounds errors'.

==DeMorgan's Law
Back when George Boole was writing down rules for logic, one that he included was known as DeMorgan's Law. It is a convenient thing for you to know how to do this LOGIC manipulation. DeMorgan simply observed these equivalances:

  NOT(A AND B) == (NOT A) OR (NOT B)
  NOT(A OR B) == (NOT A) AND (NOT B)
  
This looks a bit like the distributive law of algebra, when you change the multiplication of a sum into a sum of products. However the important thing to notice is the NOT turns ORs into ANDs and turns ANDs into ORs.

Why does that matter? It is just an AID to help you as a programmer work out your logic. Let me take that same expression that I had above when I looked at a value a to see if it was in the interval between 3 and 7. 

  if(a>=3 && a<=7){  
    block to execute if a is IN the interval;
  } else { // <- what is the logic here when you run this block - it is NOT(a>=3 && a<=7)
    block to execute if a is NOT IN the interval;
  }
  
Now maybe you can easily process the english 'a is NOT in the interval' and maybe you can't. If you can't, DeMorgan is a help. The first block happened when the expression (a&gt;=3 &amp;&amp; 3&lt;=7) was true, the second happened when that expression was FALSE. Well if the expersson was FALSE than NOT(a&gt;=3 &amp;&amp; 3&lt;=7) is true. Now we use DeMorgan to move the NOT inside the parentheses. That gives us NOT(a&gt;=3) || NOT(3&lt;=7). You see, I flipped the AND to an OR. I can then continue to move the NOT inside the comparison expressions, I mean NOT(a&gt;=3) is the same as (a&lt;3). So using DeMorgan I can confidently state that IF we are in the code in the second block that I KNOW that either a was less than 3 OR it was greater than 7. And yes, that is exactly what it means to NOT be IN the interval from 3 to 7.

Trust me, there will be cases where your logic gets complicated and you will want to be able to simplify  a logic expression and that is where DeMorgan helps. It gives an algebraic way to manipulate expressions that containg NOT, OR and AND.

::S Arrays and Loops
==Arrays and Loops
Arrays and Loops go together like Peanut Butter and Chocolate. Arrays are a data structure, a way to store data, whereas loops are a !ncontrol_structure, a way of reusing blocks of code. (We have seen other 'constrol structures' - the if statement, the switch statement, the return statement all involve going somewhere other than the very next immediate statement).

==Array
The array is our first Compound data structure. An Array does NOT fit in a single slot in the computer architecture. I hesitate to use the word, "list" to tell you that an Array is a "list of numbers" but that is exatly what an array is, it is a numbered list, starting at the number zero and moving on up. So if x is an array of integers than x[0] is one single integer and x[1] is the next integer in the list and x[2] is the next and so on. When you create an array variable like x, you actually create a whole bunch of them, one for each number or !nindex.

The only reason that I hesitate to use the word list is that in CS, we actually use the word list for a DIFFERENT way of storing data that also has this same property of keeping a bunch of elements in order. In English we use the words list and array almost interchangably. In CS we also use them ALMOST interchangably but not EXACTLY. Both words in CS imply this structure of ORDER, one element after another. In both structures you will have a[0] be the first element and a[1] the second element and a[17] the eighteenth element (note because we started at zero the numbers are off by one) The difference in CS is that an Array is "Random Access" and a List is "Serial Access". Access methods imply a time difference. When you say that something is random access you mean that you can access (i.e. read and change) the millionth element just as easily as the first element. ALL elements have equal access times. Serial Access, means that in order to get to the millionth element you have to go to the first, then the second, then the third, then the fourth,... and a million accesses later you are at that millionths element.

This random vs serial access notion exacly matches the difference between disc and tape. If you have EVER watched a videotape in your life (i.e. you are old as the hills and twice as dusty) then you know that you MIGHT have to rewind the tape if you want to start at the beginning or FAST FORWARD if you want to get to someplace near the end. Disc, you just start where you want to start.

==Declaration of an Array
The declaraction statement for arrays is different in each language. Java and C share the feature that the size of the array is fixed at the time you create it. If you want space to hold 250 elements then you tell it that at creation time. Javascript on the other hands can and will resize the array for you as you use it (which of course comes with a performance penalty)

  int x[250];  // this is the way that you allocate a list with 250 slots in C
  int[] x = new int[250]; // this is Java
  var x = []; // this is javascript which doesn't care about the size since it will adjust
  
Once you have an array allocated, the languages agree on how you fetch and store items in the array, you simply supply an index for a particular element. So x[3] is the element at the 4th slot of the array x and you can put that expression into some other expression to fetch out that value OR you can put that expression on the Left Hand Side of an Assignment to store a value:

  x[3] = -9;
  x[4] = "Hello";
  
Notice: Java and C BOTH require that you supply your array with a type. Then they type check that array. If you try that second statement, where you try to put a String into an integer array, both C and Java will GAG! They will whine about a type voilation before you even try to run the code. Both C and Java support only !nhomogeneous array - the entire array is all one single type of element. Javascript on the other hand supports !nhetrogeneous arrays, you can store any legal single thing into any single slot. (Yes, there is a performance penalty for this - if the theme is not clear OLD languages when machines were SLOW were all about giving control to the programmer so that they could insure that their code would run fast - modern languages worry more about giving the programmer access to features that they MIGHT want and if they are too slow, well so what.)

The language Java does a thing called 'runtime array index testing' meaning that if we allocated that array with 250 elements and we try to read element 251, Java will throw and error, i.e. stop the program and tell you, "hey, you have an array index that is out of bounds,". (you are paying a performance penalty by checking the index before you use it in Java.) In C, if you do the same thing, try to read element 251 in an array with only 250 slots - you don't know what will happen. Possibly C will access memory that is not in the array and your program will keep working without telling you anything, Possibly the program will crash and your OS will shut it down, and of course possibly the array out of bounds happended in the OS code itself and it runs amok and bad stuff happens and you eventually get the blue screen of death. (You see, C, is the MOST EFFICIENT language. It wastes NO time testing anything. If you want to test, you should test it yourself!). 

Javascript, on the other hand, must do something different. IF the actually array only had 250 elements in it and you wanted the one at 251, well, you must need a larger array, so javascript will take the number that you asked for, like 251, round it up to some number, maybe 400, allocate a new array that is bigger than the old one, copy the entire old one into the new space and hey, now you have an array with 251 elememts in it. "Now what was that you wanted me to do with 251?"

Javascript can dynamically resize its arrays. Now this lovely feature means that if you make a mistake and instead of asking for the item at slot 251, you accidentally ask for the item at slot 2billion and 51, well, it must allocate some 2 billion slots and copy values over and try to give you what you want. Javascript can still crash if you try to get something that it just can't give.

==Shortcut Booleans
I mentioned previously that I would show an example where shortcuts were useful. Shortcuts were added to the C language because of the observation that if you try to access an array with an invalid index, the machine might crash. So if I had you an index, i, and you want to test if a[i] == 3, you must first check that i is a legal index. So you might well need code like this:

  if(i>=0 && i<N){ // first check that i is a legal index for the array a
    if(a[i] == 3){  // once we know i is valid we can fetch and test a[i]
      C; // and now we can finally do C
    }
  }

And that is simplified by shortcutting to

  if(i>=0 && i<N && a[i]==3){C;}
  
First we test the bounds and the shortcutting prevents us from ever looking at a[i] if i was NOT valid.

In many ways shortcutting was C's syntactic sugar to make it LESS bulky to properly guard array access, but it was so useful it just became the standard way to do the logical boolean operators in nearly every language since C.

==Loops
All three of our languages support the same two fundamental looping structure, the for loop and the while loop. The for loop is actually just syntactic sugar sprinkled onto a while loop so I SHOULD tell you about the simple while loop first. BUT I won't. The reason that I am going to start on the for loop is because MOST OF THE TIME you will be using that for loop to walk over a single array and THAT is what the syntactic sugar is for, to let you do this one simple thing. Probably 90% of the loops that I write are for loops so we will start there:

Suppose I have an array, with 100 elements (that would range from x[0] to x[99] - I am going to keep stressing this - ALL modern computer languages have this OFF by 1 feature. The LENGTH of the array is 100, the COUNT of the number of elements in the array is 100, the SIZE of the array is 100, WHAT IS THE LARGEST LEGAL INDEX? It will be 100-1 i.e. 99) Suppose I want every single element to be set to the number 5. I MUST DO 100 assignment statements:

  x[0] = 5;
  x[1] = 5;
  x[2] = 5;
  ...
  x[99] = 5;
  
WOW, that's a lot of typing even with copy and paste. There must be a better way, and there is. What I really want of course is something more like the English, "for every legal value of i (that would be i from 0 to 99) I want x[i] to be 5". And that is indeed what our for statement does. Here it is in ALL three languages:

  for(var i = 0; i<100; i++){x[i] = 5;}  // this is javascript. note: I declare i to be a var
  for(int i = 0; i<100; i++){x[i] = 5;}  // this is both C and Java, I declare a TYPE for i, it is int.
  
What is going on is this: The generic form for the for loop is:

  for(initial value; test expression; increment){block;}
  
In the particular for loop I showed you, i, the index we will be using inside the loop, starts with i = 0. The for loop ALWAYS tests the boolean expression before it starts the block. The second expression GUARDS the block. Our guard requires that i be less than 100 (Oh how convenient, the last LEGAL index, 99, is LESS than the SIZE of the array which is 100). The third expression, the increment is an expression that says bump up i by 1. So first time throug the block, i is zero (which is less than 100) then it bumps it to 1, tests that i is still less than 100 so it runs again with i = 1 so we will be storing into x[1], next time we store into x[2] ... when i is 99, the block runs again storing into slot 99. We then bump i up to 100 and the guard fails. The loop exits and we move onto the next line that comes immediatel after the for block.

Suppose I wanted the array NOT initialized all to 5. Suppose instead I want each element in the array to hold the value of its index, meaning I want x[3] to hold the value 3 and x[17] to hold the value 17;

  for(var i = 0; i<100; i++){s[i] = i;}
  
As I said, 9 times out of 10 IF you have an array, you needed to initialize the entire thing, which probably required a for loo just like this one. Then you did something with the array, which probably required a for loop to go through each element in the array and do something with that element. Then you want to show all the elements so you needed another loop to go through all the elements and pull them out and assemble some kinds of string. For loops practically exist in order to play with arrays, and arrays exist to hold items that are all different and independent (for every different taxpayer ...) and yet they are all processed by the same code in the same way (...compute the tax for taxpayer[i], print out a notice for taxpayer[i] records, ...)

==While loop
The while loop is simpler than the for loop. It looks like this:

  while(boo){block;}
  
It works like like the English implies that it would, "while this boolean expression is true, perform the block."

Notice that with a while loop it is INCREDIBLY easy to write an infinite loop.

  while(2<3){alert("Dude!");}
  
Since 2 is always less than 3 this loop will just run again and again and again...

  var x = 2;
  while(x < 17){alert("Dude!");}
  
This will also run forever. NOTHING inside the block is changing the value of x. So x started out less than 17, forever remains less than 17, the block runs again and again and again...

  var x = 2;
  while(x < 17){alert("Dude!"); x++;}
  
Finally, a loop that DOES change the value of x inside the block. This will alert dude out 15 times and then x will finally be 17 and it will stop. And yes for the record it is EXACTLY what is meant by the for loop that looks like this:

  for(var x = 2; x<17; x++){alert("Dude!");}
  
The three fields of the for loop decode EXACTLY into some initializing statement that runs before the entire loop starts, a boolean expression that goes into a while statement, and an increment that runs at the end of each pass through the block that is almost ALWAYS an increment to make sure that SOMETHING changed so that the boolean expression can detect when it is time to stop the loop. The definition of a for loop is the while loop that represents it.

==Continue and Break
There are two commands that are ONLY valid inside of a loop. They are used when you discover something interesting in the middle of processing a loop.

Sometimes you are in the middle of a calculation that is going on in the loop block and you realize as a result that you are done with what you needed to do for this single element and you could/should in fact increment to the next value and press on with the loop. The instruction that does that is 'continue'

I will not try to cobble together some example that might or might not make sense. If I EVER need it in a project later, I will show you. The contiue statement is alsmos always in a guard, for the simple reason that you are cutting short the normal passage through all of the code in the block and usually the ONLY reason that you would decide to blow off all the rest of the code in the block is because you did some boolean calculation that told you that it was safe to continue so almost always it looks like this:

  if(boo){continue;} // if boo is true, skip the end of loop block, go to the increment, and probably loop again

The other command, break, is also something that is used to escape from a loop when you detect something, though in this case instead of just blowing off this single pass through the loop block, you are blowing off the loop altogether.

One of the places that this tends to get used is when you are searching an array to see if it contains an element. If you find it, you don't need to continue going on though the rest of the array, you can break as soon as you see what you are looking for.

Just like the continue the break command is almost always in some guarded statement.

==Array Length
In the Language C, when you create an array of a particular size. It is your job as the programmer to REMEMBER how you created that size. Here is some C

  #define N 250
  int x[N];
  for(int i = 0; i<N; i++){x[i] = 5;}  // every element of x set to 5
 
The N that showed up in the for Loop to limit the size of the array was because I as the programmer REMEMBERED that I defined x as being N long. The truth is that in C that variable x does NOT know how long it is. You are responsible for knowing the lenghts of your arrays.

In the language Java, an array x, is just a Tiny bit smarter than a C array. Java arrays KNOW their size. (And they needed to know becasue they couldn't test for array out of bounds errors if they did not know!) So in Java we can write code like this:

  int N = 250;
  int[] x = new int[N];
  for(int i = 0; i<N; i++){x[i] = 5;}  // every element of x set to 5  SAME AS C ...
  for(int i = 0; i<x.length; i++){x[i] = 5;}  // ..OR I can ASK x how long it is. Basically x.lenght is a var
 
In Java I can ask an array how long it is and use that lenght as the limit for my loop.

In Javascript the arrays can resize themselves. The actual lenght depends on how much stuff you wrote into it. If I started with a loop that wrote 5 into the first 10 slots, then the lenght of the array is 10. If I then write into slot 17, the array is expanded up to have 18 elements (the last one is at index 17) so the length is now 18. I javascript you MUST use the length feature of the array to find out how big it is when you want to write a for loop.

  var x = [];
  for(var i = 0; i<10; i++){x[i] = 5;}
  x[17] = 17;
  var str = '';
  for(var i = 0; i<x.length; i++){str += ' ' + x[i];}
  alert(str); 

Run this and look at all those undefined variables between 10 and 17!

==Hashes and Maps
Javascript arrays have another feature that is completely non-existant in both Java and C. I am going to skip the details now and cover it later, but I will mention it so that you are aware of it. The language Ruby calls this feature "Hashes", the language Java, calls them HashMaps or just Maps, C doesn't have them directly but C++ most likely has them. (Just for the record there is a data processing technique named "hashing" and that process is most often used to create a data structure known as a "hash table" and that structure is used to implement this feature that is called either a "Map" or a "Hash" or an "Associative Array". We use this associative array feature of javascript all the time so you need to know that. How it works under the hood is of no particular importance but I wanted to pass on the vocabulary since it differs from one language to the next. One typically learns about the actual process of "hashing" in an Algorithms course and there isn't much need in this course to know how to "hash" something.) 

What a hash does, is something very similar to what an array does. It does it in a very different way so the OLD languages, Java and C, considered them COMPLETELY different from arrays, however modern languages, particularly scripting languages, used the familar SYNTAX for arrays to represent the very useful feature of Maps or Hashes.

The new viewpoint is just this: you can think of an array NOT as an ordering, where you have element 1 immediately after element 0, but instead think of them as a form of database, i.e. key value pairs. In an array a 'key' would be a single numeric index like 5 and the value associated with that 'key' would be x[5]. You can think of x, an array, as just a big pile of keys and each different key is associated with exactly one value.

Maps and Hashes are collections of key value pairs. In a language like java you can do something like this:

  Map<String, Int> age = new HashMap<>(); // create a map that goes from String to int
  age.put("Bob", 36); // tell the age map to make the association between bob and his age 36
  age.put("Mary", 17); // tell the map about mary
  System.out.println("Bob's age is " + age.get("Bob")); // fetches bob's age from the map using "Bob" as the key

Well in javascript you can do exactly the same thing with arrays
  
  var age = []; // sure looks like an array
  age['Bob'] = 36; // shove the value 36 into the slot with the key/index of 'Bob'
  age['Mary'] = 17; // mary get a value too
  alert("Bob's age is " + age['Bob']) // fetch Bob's age using 'Bob' as the key
  
Javascript and modern languages realized that array notation could be treated as syntactic sugar to represent storing and fetching things out of Hashes, or Maps.

What I am NOT going to go into detail YET is to get into the grubby details of HOW you get everything back out of a Map. That stuff that I showed you using for loops and the length of the array depended very directly on the FACT that the integer keys in a normal array have a well defined order, one after the other. The keys in an associative array on the other hand might be strings OR ANYTHING ELSE, which don't have a well defined order.

The fact is that Javascript arrays are actually messy beasts that have both a regular array part that you can use like an array with consecutive integer keys AND a map part that you can use like a HashMap and you can use both at the same time. The length property of a javascript array is ONLY a property of the integer keyed array half of the pair and has NOTHING to do with the HashMap half. So if you create an array like we did, stuff in a value for 'bob' and one for 'mary' the length is still 0! - SO hold you questions until we get there.

I just felt that I would be wrong to talk about arrays in javascript and to NOT EVEN MENTION their most modern feature which is that they do dual purposes as HashMaps. We will get into more of the specifics when we get a project that actually needs them.

::S Recursion
==Recursion
I don't want to make a big deal about !nrecursion. Some people do. Some students find the notion difficult. Some academic CS geeks believe that recursion is the ONLY way that you should think about programming.

Recursion is simply the notion that you can call a function from within itself. The simplest example is the mathematical Factorial function. Factorial(n) is defined to be the product of all the integers less than r equal to n, so Factorial(4) == 1*2*3*4. Factorial(1) == 1. And just because it is mathematically convenient, they even give a special definition for Factorial(0) which is defined to be 1 (NOT 0).

When the mathematician write out a "recursive definition" for a function it will look something like this:

  Factorial(n) == 1 if n == 0 otherwise it is n*Factorial(n-1);
  
You see it ALMOST looks like code, and sure enough here is the code that you would write in javascript.

  function factorial(n){
    if(n == 0){return 1;}
    return n*factorial(n-1);
  }

There is no problem with having a function reference itself. It is really not much different from entering a loop. When you started to evaluate factorial(3) you see that it isn't 0 so you need 3* some number which is factorial(2) so you start up factorial again using 2, which was not 0 so you need 2* ... oh we need factorial(1) which needs factorial(0) AH! finally a simple case where we know the exact answer immediately so we can skip the recursion. So factorial(0) return 1, so now factorial(1) can compute its answer (it is 1*1 which is 1) and now factorial(2) can complete its answer (it is 2*1 which is 2) and now factorial 3 can complete (it is 3*2 which is 6) and the function can return that value.

The ONLY thing that is REQUIRED for ALL recursive function is that there MUST be some simple case at the FRONT of the recursive function that simply returns a value WITHOUT making a recursive call. Recursion will turn into an infinite process (and do a thing called, "blow up the stack") if you FORGET to have a simple exit for your function that skips the recursive call.

Recursion is ALL about taking a BIG problem like Factorial(4) and turning it into a SLIGHTLY smaller problem, like Factorial(3). AND as long as the problems that you need to solve keep getting smaller and smaller, AND AS LONG AS YOU FINALLY GET TO A TRIVIAL PROBLEM THAT YOU CAN SOLVE WITHOUT RECURSION then you will eventually exit with a completed solution. Recursion is thus a form of Divide and Conquer, which is a very powerful technique.

The CS geeks that LOVE recursion mostly love it because there is a mathematical theory of computation that shows that everything that you CAN compute could be done entirely with recursive functions. They like the mathematical simplicity of having a single tool that works for EVERY problem. There are even languages, LISP and SCHEME and RACKET for example, that are quite different from other languages in that they are set up to lean very heavily toward using recursion for EVERYTHING and to minimize the use of VARIABLES and data storage. 

We will probably not be using recursion in this course. However, as I said, I do want you to know that there is no problem with having a function call itself, and you should know the word, "recursion".

::S Summary
==Summary
At this point we have covered MOST of the common material of EVERY Programming language. Every Language of which I am aware has these features. Some form of Comments in the code. Some form of variables, which you name. Some form of types with some literal values for the primitive types. Some pile of operators that include the standard math operators, and the comparison operators, and some form of Boolean operators. They all have a way of defining functions, which take arguments, which will be LOCAL instead of GLOBAL. They all return values from function. They all have some form of conditional, an IF statement. They all have something like an array and LOOPS for going over an array.

There is ONE other feature that nearly every language has BUT I have left it out of this chapter on programming in general. I have not yet described compound data structures, known in different languages as "structs", "structures", "objects", "records". I have skipped it to this point because as you can probably guess from the variety of names, different languages tend to differ about the way that they provide for you to define your OWN TYPE of data and how you access that data in your code.

Data Structures is what we will wade into next, but I have made it a chapter of its own because it is the place where the three languages diverge (They all have the same IDENTICAL notion but the syntax is quite different for all the languages).

Once again, here is the list of vocab with the words that we have covered highlighted:

 !bAddress, !bAnd, !bArgument, !bArray, Ascii, !bAssignment, Base, !bBinary, !bBit, Bitwise, BlackBox Test, !bBlocks, !bBoolean, !bBraces, !bBreak, !bByte, !bCall, !bCase, !bChar, Class, !bComment, !bConcatination, !bConditional, !bConditional Expression, !bConstant, Constructor, !bContinue, Control Structures, !bDeclaration, !bDefault, !bDelimiter, !bDouble, Dynamic Memory, !bEscape, !bExpression, Extends, Factory method, !bFetch, Field, Filter, !bFloat, !bFor, !bFunction, Garbage Collection, Generics, !bGlobal, !bGuard, !bHash, Hexidecimal, !bIf, Implements, !bIncrement, !bIndex, Inheritance, !bInteger, !bLiterals, !bLocal, !bLoop, Main, Member, Memory Model, Modulus, Objects, !bOperator, !bOr, Order, !bOutput, !bParentheses, Pointer, !bPolymorphism, !bPrecedence, !bPrimitive_Type, !bQuotedQuotes, Radix, !bReal, Record, !bRecursion, Refactor, !bReturn, !bScope, Self, Stack, Static Memory, !bStore, !bString, Struct, Structure, !bSwitch, !bSyntax, This, !bTree, !bTypes, Unit Test, User defined Type, Unicode, UTF-8, !bVariables, !bVisibility, !bWhile, WhiteBox test, !bXor
 
::C Object Orientation
::S Intro
==Object Orientation
Object Orientatation was a change (some would call it a revolution) in computer languages that "happened" in the late eighties and early nineties. All that means is that the notion spread from the earlier lesser used object oriented languages like Simula67 and Smalltalk72 into languages like C++83 (which was an object oriented upgrade to C, as was Objective C) and Eiffel85 and Java95. As a result instead of being a little used feature of a few specialty languages it moved into being used by nearly all languages. It moved slowly into languages IMHO not because it was so revolutionary (it can be viewed as a rather minor syntax change) but because it was inefficient (it took more space to represent data on the computer and it took longer to call functions). However it was eventually adopted mostly because computers got faster, memory got cheaper, and the old concerns of trying to optimize the efficiency on the computer began to give way to trying to make coding easier on the human programmers. 

In order to best understand what object orientation is, we need to look for just a moment at the way that things used to be in the older languages like C.

C "introduced" a feature (meaning C70, popularized a notion that had been in Algol60) of structures. Structures were noticably absent in the FORTRAN57. A structure is a "small collection of heterogeneous data" essentially a single data record. So for example a person record, or structure could consist of a first name, a last name, and an age. The word, "heterogeneous" was used in the definition that I gave above to emphasize that unlike "arrays" that are "homogeneous", all data of the same type, the structure could use different types of data for the little chunks, Strings of text for the first and last name, and an integer for the age. In C for example the way that you would create that Person structure is like this:

  typdef struct Person Person;  // this was C slang for "I will write 'Person' when I actually mean 'struct Person'
  struct Person{char* first; char* last; int age;};  // char* is C slang for String
  // and then when you want to declare and assign initial values you could do this
  Person x = {"Fred", "Flintstone", 39}
  // and if you wanted to change Fred's age to 40 you would write this
  x.age = 40;

From the Language point of view (meaning what you see on the surface of the programming language as opposed to what happens under the hood to make it work) what you have done is expanded your name space. You used to have variables named only with single words, x, foo, temperature, and now you can have compound names, x.age, temperature.maximum, names with dots in them refering to substructures. Note that you immediately start thinking about a Person as a single type of object that just happens to have sub-components unlike primitive types which don't have sub-components. Old languages like FORTRAN, having no structures, essentially only had primitive types of data, integers, floats and characters. The ability to define structures essentially greatly expanded the notion of what Types actually are - they are all the primitive types and all the types that the programmer chooses to define. 

There was no problem with hierarchy of structures. You could easily build nested data structure so that you could have variables like company.address.zipcode if you wanted. Also the "field" names were considered "local" to the structure so there would be no problem having a type Person with a field 'first' referring to the person's first name and some other structure for Car that also had a field named 'first' that was actually a reference to the person that first owned the car. As long as you know what type of variable you have, like if you know that x was a Person, then you can use the proper interpretation for x.age, you know to use the meaning of 'age' associated with the struct Person.
 
That was structures in C, and nearly all of the current languages still essentially implement something like structures, they have just changed the way that you define those structures.

What was primarily added with object orientation was essentially the understanding that in the same way that the field names are local names that only have meaning (as names of data variables) in the context of a particular type of structure you might want to do the same thing with functions. i.e. have function names that are essentially local to the context of a particular type of structure. 

The problem with pre-object oriented code was this. If you had two differen structure, like Person and Car, and you wanted to print them out. You need two different names for two different functions. You need printPerson(x) which would produce something like: 'Flintstone, Fred - age:40' and you would need something like printCar(y) that would perhaps print, '1972 Mustang first owned by Flintstone, Fred - age:40'. Two types, two function, two names. What Object Orientation did was change the langage systax so that you could write x.print() and y.print() and since x was of type Person, the system would know that it should use the print function associated with Persons instead of using the print function used for Cars. Two types, two functions, ONE name.

Being about to reuse names seems like a very minor change but it was very useful. What it allowed you to do was effectively write code that DID NOT KNOW what type of thing it was working with. You could write code like, x.print() and no longer CARE whether x was a Person variable or a Car variable. More importanly, you could write code that printed out some variable, and LONG after you shipped that code you could invent some new thing like a Dishwasher, write a print function for you Dishwasher and the OLD code that you shipped years ago that used the command x.print() could properly interpret that statement as meaning 'use the proper print function for whatever type of object x happens to be'.

This effect is called, 'delayed binding' and all that means is that under the hood the system didn't know which particular function it would actually be calling until it looked at the data and saw what kind of data it was. (And this is the reason for my earlier comment about space and speed - because you need to LOOK at the data and see what type it is, and then based on the TYPE decide which function to call, it added an overhead to calling the function.) 

Before we leave this general background lecture on where object oriented programming came from I want to emphasize one of the syntactic changes that came with it. In da old days you would have something like this:

  stuct Person{String first, String last, int age}; // no real language but almost C
  void printPersonWithMsg(Person p, msg){printf("%s%s, %s - age:%d",msg,p.last,p.first,plage);}
  // later when you want to load up that structure and print it out with a message
  Person x = {"Fred", "Flintstone", 39};
  printPerson(x, "Happy Birthday ");  // wish Fred a Happy Birthday
  
in the modern days in a language like Java you would have something more like this:

  class Person{  // we are defining a TYPE with a class named Person
    String first;  // here are the field names and their types
    String last;
    int age;
    Person(String f, String l, int a){first = f; last = l; age = a;} // constructor to load values into a struct
    void printWithMsg(String msg){System.out.println(msg + last + ', ' + first + ' - age:' + age);}
  }  // end class Person, both field names/types AND functions relating to Persons
  // later when you want to load up that structure and print it out with a message
  Person x = new Person("Fred", "Flintstone", 39);
  x.printWithMsg("Happy Birthday ");

The primary thing that I want you to note is that IF you think of the functions AS IF THEY WERE OPERATORS, we have moved from PREFIX notation print(x) and printMsg(x, msg) to PREFIX, x.print() and INFIX notation x.printMsg(msg). 

That is the BIG change in object orientation a syntactic change that does something similar to what math notation did for us. We moved from name_type(x, y) to x.name(y), we removed clutter from the name space. The change to infix means that we changed nesting C(B(A(x),y),z) (first do A then B then C) into sequence x.A().B(y).C(z) You also no longer need to choose a dozen different names for your print functions to print out the dozens of different types of variables that you might have. Instead you have a single name, 'print', that you reuse across dozens of different classes. YOU STILL must write exactly the same amount of code. You still must write a dozen different print functions, but the naming is easier.

==Summary
The history of the development of Object Oriented programs helps explain why the 3 languages that I have selected to teach you, C, Java, and Javascript are all rather different in the way that they deal with user-defined types. 

C just had the notion of structures, but it is not object oriented. As a result, it suffers a bit from namespace pollution. Java however is object oriented as is Javascript. Both of them allow you to associate functions with particular data structures. All of these languages use rather different syntax for the way that that they DEFINE those data structures.

Object Orientation does introduce some new vocabulary: The thing that C called a 'structure' is now called a 'class'. Both of those are though of as being 'user-defined types'. The things that used to be called 'fields' (which were ONLY data) are now called 'members' (which can be either data or functions). The biggest difference between a structure and a class is that structures ONLY described data, classes describe both data AND functions that operate on that data. 

I have been using the name 'object oriented programming' all along and haven't yet defined what the word 'object' means. Silly me. An object is a single data element of some defined type. So Person is a class but Fred is an object of type Person, just like integer is a primitive-type and 17 is a particular 'object' of that integer type. Classes are essentially 'blueprints' a description of HOW to construct a house. A blueprint is NOT a house, whereas a house is actually an object. Dog is the name of a type of critter, thus Dog is a class, whereas Fido is a particular dog and thus Fido is an object of type Dog. Objects are things, actual data, classes are descriptions of how that data is structured, what sub-components it has, what fuctions can be performed on that data.

There is a NAMING convention in Object Oriented programming which is the exact opposite of the way that we name things in English. Classes are defined with initial capital letters. So I have been writing Person and Car because those are class names and should be capitalized in code. On the other hand variable names (which hold actual data objects) should NOT be capitalized (so that you can tell that those are NOT class names). As a result in programming we both think and write 

  Person fred; // fred is a variable name that will hold an object of type Person.
  
in English however, we capitalize the names of individuals, Fred, the Grand Canyon, Chicago, and we lower case the names of classes: Fred is a person, Chicago is a city. So it goes. 

From here on out in this book I will try to avoid long lectures like this that are full of background material and are devoid of examples. We are ready to start programming. From here on out it will be programming projects.

 
::S HTML Template
==HTML Template
I will now provide you with the TEMPLATE file that I always use for my HTML projects. You will see that I refer to BOTH an external CSS file and an external JS file AND I put in some internal JS (which I won't explain quite yet) This template is based on the idea that It is easier to throw stuff out that you don't need rather than to remember that you should include it. So if I don't need CSS, I just rip out the link line. If I don't need UTF-8 I can remove that.

--Template.html
<div style="background-color:#eee;"><br/>&nbsp;&nbsp;&LT;!DOCTYPE html&gt;&LT;html&gt;&LT;head&gt;&LT;meta charset="utf-8"&gt;<br/>&nbsp;&nbsp;&LT;link rel="stylesheet" type="text/css" href="FOO.css"&gt;<br/>&nbsp;&nbsp;&LT;script src="FOO.js" type="text/javascript"&gt;&LT;/script&gt;<br/>&nbsp;&nbsp;&LT;script&gt;<br/>&nbsp;&nbsp;function inject(loc,val){document.getElementById(loc).innerHTML = val;}<br/>&nbsp;&nbsp;window.onload = function(){inject('stuff','sweet');}<br/>&nbsp;&nbsp;&LT;/script&gt;<br/>&nbsp;&nbsp;&LT;title&gt;FOO&LT;/title&gt;&LT;/head&gt;&LT;body&gt;<br/>&nbsp;&nbsp;&LT;h1&gt;Dude&LT;/h1&gt;<br/>&nbsp;&nbsp;&LT;div id="stuff"&gt;dude&LT;/div&gt;<br/>&nbsp;&nbsp;&LT;/body&gt;&LT;/html&gt;</div>  

::C Projects
::S Flashcards
==Flash cards
In this project we will develop a flash card system, and one of the things that I will be doing is showing you how to develop a project in small steps, a method that is known as incremental improvement. The primary reason for this, PARTICULARLY for beginners, is that you don't want to write a bunch of code and they try to get it working. There are FAR TOO MANY ways to screw up and trying to track down bugs is hard. SO my primary goal is to try to write only a few lines at any time and the TEST them and see if what we have built so far works.

==Basic Idea
What we are shooting for is something like this: We see the front of a card, like the word, "Cat", on the screen. We try to remember how to say that in Japanese (which is on the back of the card). When we think we remember (or when we give up) we will click on that word on the screen and it will show the word "Nekko" below it (so for a moment there we see both front and back sides on the screen at the same time - Japanese for Cat is Nekko). Now the user makes a choice. Either they remembered the correct word for cat or they didn't. They either got it right or wrong and they need to tell the system so that it can update the statistics. We will simply use the two words on the screen as the two buttons for right and wrong. If the click on the front face they are telling us that they got it right and if they click on the back face they are telling us that they got it wrong. So if the just hover the mouse over the front face and click click click, they are telling us, Yeah, got it, got it,... They shift the mouse to the revealed back face whenever that back face surprised them.

I mentioned that we will be keeping statistics. We are going to use a method closely related to the Leitner System which was used when people actually used physical flash cards. Leitner's System was simple. Keep several boxes of cards, numbered 1,2,3,4... The numbers represent how well you know those words, the higher the number the better you know them. Pull all the cards out of a box, let us say box 3. Every one you know, moves up to box 4 because you proved that you know it even better than level 3. However, every time you miss a card, you bust it all they way back down to level 1. It starts all the way back at the beginning. The idea being that if you really just made a simple mistake, that card will quickly rise back up to its true place.

The purpose of the Leitner system is simply to make sure that you spend most of your time looking at the cards that you are unsure of and to only occasionally refresh the ones that you know fairly well. There are several ways that we can improve the Leitner system but for now it should give you an idea of A method that will allow us to use the statistical feedback from the user, their RIGHT or WRONG click on a single card, to modify the presentation frequency of that card.

Wow lots of stuff to do. Where do we start?

==HTML Template
We Always start with the basic HTML code edited to set the title and the related .js file and .css file to Flashcards:
--Flashcards.html   
<div style="background-color:#eee;"><br/>&nbsp;&nbsp;&LT;!DOCTYPE html&gt;&LT;html&gt;&LT;head&gt;&LT;meta charset="utf-8"&gt;<br/>&nbsp;&nbsp;&LT;link rel="stylesheet" type="text/css" href="Flashcards.css"&gt;<br/>&nbsp;&nbsp;&LT;script src="Flashcards.js" type="text/javascript"&gt;&LT;/script&gt;<br/>&nbsp;&nbsp;&LT;script&gt;<br/>&nbsp;&nbsp;function inject(loc,val){document.getElementById(loc).innerHTML = val;}<br/>&nbsp;&nbsp;window.onload = function(){inject('stuff','sweet');}<br/>&nbsp;&nbsp;&LT;/script&gt;<br/>&nbsp;&nbsp;&LT;title&gt;Flashcards&LT;/title&gt;&LT;/head&gt;&LT;body&gt;<br/>&nbsp;&nbsp;&LT;h1&gt;Flashcards&LT;/h1&gt;<br/>&nbsp;&nbsp;&LT;div id="stuff"&gt;dude&LT;/div&gt;<br/>&nbsp;&nbsp;&LT;/body&gt;&LT;/html&gt;</div>  

--Flashcards.js
  alert("found flashcard.js");  // this is test code. Verifies that I got the names spelled right

--Flashcards.css
  #stuff {color:blue;} 
  
Run the html file and see you get the alert from the javascript file and see if the words "dude" and "sweet" came out in blue. IF NOT - well GOOD, you found a bug very early!

==Layout the DOM
The HTML that makes up the body of the document ultimately creates a thing know as the DOM, the Document Object Model. That is simply the name for the data structures that are being used inside your browser to hold onto all the little pieces of the document that you have created. Whenever you build an HTML application you have some notion of how the screen should look and this basically be a collection of divisions and possibly spans, maybe some headings that form the skeleton of your app. Those will be the DOM places that you can inject things into your document. We build that first so that we can get an idea of what our application could look like. 

Our flashcard app is pretty simple. We will want to have two card faces showing, a front and a back, so a couple of division will probably do the trick:

  <div id="FRONT">Cat</div>
  <div id="BACK">Nekko</div>
  
Note: I have loaded values into those divisions, this is just temp data to see how the words will look. The real application will overwrite those values.

So rip out that "stuff" division (or just re-edit it into a FRONT division). And modify your CSS so that it colors the FRONT card and not the "stuff" division. Also modify the script that is in the HTML file so that the window.onload function is no longer injecting something into stuff - that was just there as a test to verify that inject was written properly.

==Size your cards
Now resize the text using your CSS file to get something that looks right on your screen. I went with 10em. I also colored the back card red as a reminder that the back card will eventually be the WRONG button for the user.

--Flashcards.css
  #FRONT {font-size:10em; color:blue;} 
  #BACK {font-size:10em; color:red;} 
  
==Make Cards Clickable

Now we make those divisions into buttons by adding onclick attributes (the onclick attribute is a line of javascript called when the DOM item is clicked - in this case a function call). We do have a choice here and it doesn't much matter. I could have two different functions like, clickedRight() and clickedWrong(), where I deal with those two different behaviors, OR I could just build a single function userClicked(wrong) where I pass in a boolean value, true if they clicked the wrong button and false if they clicked the right one. In the past I have always written two different function but I think just for fun this time I will write a single one and pass in a boolean.

  <div id="FRONT" onclick="userClicked(false);">Cat</div>
  <div id="BACK" onclick="userClicked(true);">Nekko</div>
  
After those changes to the DOM I need to write a userClicked function in my javascript that will show me that I am correctly calling that function so I just "stub" userClicked with an alert.

--Flashcards.js
  function userClicked(w){alert("user said " + (w?"WRONG":"RIGHT") );}

I tested it and it works fine, BUT as soon as I start thinking about the name "userClicked", I see something that I don't like. Look at the line we are executing on the BACK button, userClicked(true), user clicked true. True what? can you tell from that single line of javascript code what that boolean value true was supposed to mean? Does it mean true, the user clicked on the button meaning WRONG or true on the button meaning RIGHT? Yes, back at the definition of the function I gave the argument the name "wrong" to imply that true means wrong but that means I have to look back at the definition of my function to see that true meant wrong. I want to rename my function to "clickedWrong()" - make those changed in both the DOM and the JS file.

  function clickedWrong(boo){alert("user said " + (boo?"WRONG":"RIGHT") );}
  
==Create some Variables
I will want to have an array of cards. It is from this array that I will select a card (based on the statistics) and make it the current card. 

  var cards = [];  // the list of cards
  var cur;         // the card currently being shown

As soon as I said I need a card, I know that I need to define a Card type so I need a Card class (which is why I am writing Card now with a capital letter. Initial capital letter on a name implies that it is the name of a class not the name of an object. So what are the fields that we need for that card object. We could of course have a front side and a back side, both strings, but that both limits us to two faced cards and makes it harder to use the cards in a different order, for example training from Japanese to English rather than from English to Japanese. I picked Japanese as my sample language however for a different reason, namely that two faces are just not enough. I will need about 4 faces for my Japanese cards. I want an English face, Cat, a Romanji face, Nekko, (that is how you pronounce the word written out in Roman characters). But I also want the pronunciation written out in one of the Japanese sylabaries like hiragana, ねこ, and I need the Kanji character as well, 猫. Japanese cards will want 4 faces.
This strongly suggests that we want a single field, "faces", for a card and that field will be an array.

We will also want a field that will hold our statistics, and if we go with the Leitner box model (and we will because it is simple) we only need a single integer representing how well known that card is. We can certainly add other fields later if we need them.

Since the function that defines a class in javascript is also the constructor for the class, we will need to think about what arguments we need for that constructor. Clearly I need to pass in the actual faces for a card, but I don't need to pass in a knowledge value since cards should start out as unknown. Because it is convenient, I will pass in the 4 strings that make up the 4 faces of a Japanese card as a single pipe-separated string which I can split into an array.

  function Card(str){this.faces = srt.split('|'); this.known = 0;}
  
I can also easily imagine a couple other variables that I will need. Now that I have an array of faces in my cards, I will need to keep track of which face I want on the front card and which one on the back.

  var front = 0; var back = 1; // train from face 0 to face 1

Since my application toggles back and forth between showing just the front face, and showing both faces, I will want a boolean variable that keeps track of what is currently showing

  var showingBoth = true;
  
Put it all together and I will need:

  var cards = [];  // the list of cards
  var cur;         // the card currently being shown
  var front = 0; var back = 1; // train from face 0 to face 1
  var showingBoth = true;
  
  function Card(str){this.faces = str.split('|'); this.known = 0;}

==Test the Card class
None of that code lets me test anything! Five lines with no testing yet! BAD BAD! Well actually, there is only ONE line that actually does anything, It constructs a card. We need to test that. Testing that means constructing a card and showing that the values got into the right places AND since we need to eventually have a routine that shows the cards (based on the value of the boolean showingBoth) we might as well write that routine NOW and use it to test the Card constructor.

  function show(){ // needs no argument because it shows cur, the current card.
    inject('FRONT', cur.faces[front]);
    var backStr = showingBoth ? cur.faces[back] : ''; // blank out back if NOT showing Both
    inject('BACK', backStr);
  }

Now that we have a show routine we need to call it from somewhere and we need to actually construct a card so let us do that in the window.onload routine.

  window.onload = function(){cur = new Card('Cat|Nekko|ねこ|猫'); show();}  
  
Well, I tested it but nothing changed. I mean it showed the same words, Cat and Nekko that it was already showing. I could change those words in the DOM and see that I am properly overwriting them when I select a card OR better yet, Since show is SUPPOSED to respect my choices for front and back, I could just change the values of front and back to see if I can get the kanji character to show up (I will set front to 2 and back to 3). This will test BOTH show() AND Card().

WOW! Big Kanji characters on the screen now!

==test showingBoth in show
It wasn't a complete test of show. I am only showing both right at the moment. I am going to make the clickWrong function toggle the value of showingBoth (which is actually pretty close to something that we need to do anyway!)

  function clickedWrong(boo){
    showingBoth = !showingBoth;
    alert("user said " + (boo?"WRONG":"RIGHT") );
  }
  
You make that change, test it, and NOTHING HAPPENS? Why? Well to be honest, I walked you into a bug one that is VERY easy to make. I do it all the time. You will probably be smarter then me and do it LESS OFTEN. The Bug. Sure, my clickedWrong routine now updates showingBoth, but did it repaint the screen to show the effects of the change that I made? No, it did not. I need to call the show routine after I change a value that affects the screen.

  function clickedWrong(boo){
    showingBoth = !showingBoth;
    show();
    alert("user said " + (boo?"WRONG":"RIGHT") );
  }
  
With that change it works great, and now I don't think I need that alert any more in clickedWrong but rather than delete it, let's just comment it out so that we can easily put it back in if we need it.

  function clickedWrong(boo){
    showingBoth = !showingBoth;
    show();
    //alert("user said " + (boo?"WRONG":"RIGHT") );
  }
  
==Build Several Cards
We won't be able to show different cards if we don't build several cards so we will add some more data at this point, also we never put the single card that we build into the list of cards. We have a choice here. We COULD change our card constructor so that it ADDS the card that it constructs onto the card list. This is easy, the single statement cards.push(this); in the constructor pushes this (inside a constructor, this means the object that is being constructed) onto the list of cards. OR we could build a helper function that will do the two steps of both constructing a card AND adding the constructed card onto the list. I am going to choose the second path for the simple reason that I don't want to write

  new Card('foo|bar|bax|baz');
  new Card('foo|bar|bax|baz');
  new Card('foo|bar|bax|baz');
  new Card('foo|bar|bax|baz');
  
over and over. I want to build a helper with a SHORT name like C() so that I can write:

  C('foo|bar|bax|baz');
  C('foo|bar|bax|baz');
  C('foo|bar|bax|baz');

Also, there is something else that I want to do in a helper. I want to validate the cards that I am shoving onto the list. (When you hand this flash card app off to someone, and they type in their cards, and ACCIDENTALLY make a Japanese card that only had 3 faces, the system does NOT crash until the user just happens to load up that card and just happens to be training to or from the 4th face - the earlier that we can detect this flaw, like the first time that the author of the card list tried to run the program - "hey THIS card has the wrong number of faces" - the better!)

So here is a helper without any validation. (You didn't think I was going to write and test validation at the SAME time that I am trying to see if I can build a helper to put cards in the array did you?)

  function C(str){cur = new Card(str); cards.push(cur);} // note side effect: sets GLOBAL cur.
  
We test this by placing several cards into the window.onload routine.

  window.onload = function(){
    C('Cat|Nekko|ねこ|猫'); 
    C('Tree|Ki|き|木');
    C('Sun|Hi|ひ|日'); 
    C('Mountain|Yama|やま|山'); 
    show();
  } 
  
We test and see that that the last card, mountain, is the one that is now loaded into cur.

==Validation
All we are going to do for validation is to test that ALL cards have exactly the same length to the number of faces. We will do this by creating a global variable nFaces which will start at zero. The first card that we actually build will change that value to something non-zero and every card after that must match the length or get alerted out as a possible error.

  var nFaces = 0;
  function validate(card){
    if(nFaces == 0){nFaces = card.faces.length; return;}
    if(card.faces.length != nFaces){alert("wrong number of faces on card: " + card.faces[0]);}
  }

then modify C to call the validate routine
 
  function C(str){cur = new Card(str); cards.push(cur); validate(cur);} // note side effect: sets GLOBAL cur.
  
AND in order to test this the validation checker, break one of the cards by removing a pipe character so that it has the wrong number of faces.

After the test, fix the card that you broke.

==Write getCard
getCard will select a new card at random. Yes, someday that randomization will actually be based on the knowledge stats, It will take us a few passes to get there. Right now I will hardwire getCard to just cycle through the cards in order.

  var nCur = 0;
  function getCard(){
    cur = cards[nCur++];
    if(nCur == cards.length){nCur = 0;}
  }

Now the question is, where do we call that function? Time to think about the logic of when we actually want to get a new card. We can put this into the show() function. It will be showing either both cards or only the front and we could wire it up to dial up a new card just before it shows the front IF it is not showing both cards.

  function show(){ // needs no argument because it shows cur, the current card.
    if(!showingBoth){getCard();}  // get a new card if this is FRONT only display
    inject('FRONT', cur.faces[front]);
    var backStr = showingBoth ? cur.faces[back] : ''; // blank out back if NOT showing Both
    inject('BACK', backStr);
  }
  
That code cycles the cards. In fact I am going to keep that code for getCard and rename it cycleCard. I am going to write a new getCard that will select one at random.

Random numbers in java come from a built in function Math.Random() which returns a floating point integer between 0 and 1 (it could return zero but it won't return 1). If you multiply that floating point number by an integer like 100 you will now have a floating point number that ranges from 0 up to but NOT including 100 - and that is still a floating point number so you might get 23.415678. IF what you want is a random integer (and I certainly never want anything else - I am always trying to choose some random thing from an array with N elements) you can throw out the fractional part of a number by taking its Floor with the Math.floor function. So if you take the floor of a number that ranges from 0 up to but not including 100 you will get an integer in the range 0 to 99 inclusive. This is exactly what you need to select from an array with 100 elements.

Just for the record, I never remember the names of the Math.floor and Math.random functions - (Java does random numbers differently and uses different names. I always look up "javascript random int" and find this bit of code that I want. My memory of how it works helps me edit the bit of code that I scrape off of the internet and let's me write getCard in a way that selects a card at random.

  function getCard(){cur = cards[Math.floor(Math.random()*cards.length)];}
  
If you run with this, you should see random cards happening. Note that with a small selection of cards you can quite often get instant repeats, where you just did cat and you immediately see it again. I leave it as an exercise to the reader to modify the above code to get a card at random but that avoids instant repeats.

==Update Knowledge
In the previous section, I wrote two different versions of get Card neither one of which is the one that I want. The one that I want will be based on our knowledge BUT we have not yet done anything to properly update based on which button the user clicked on. In some ways, the previous section was there to help us put the call to getCard in the proper place and to gain confidence that it does get a new card at the right time. NOW we will work on updating our knowledge number and on testing it and gaining confidence that we are correctly updating our stats. The reason that we want confidence is that once you start generating random numbers it is hard to look at anything and declare that it is wrong behavior. Maybe you were just unlucky with the random numbers.

The only time that you update stats is when both cards are showing. Only after the user looks as the back of the card can they decide if they were right or wrong in what was in their heads. So we will guard the function so that it just does nothing (it just returns) if both cards are not showing. The update itself is fairly easy, we bump the number up by 1 if it was right and bust to zero if it was wrong. HOWEVER I will eventually want to use the 'known' number for a card as an index into a mass array so I will want to keep it in range of that array. This means that there is a top limit that I don't want to exceed. We will use MAX for that top number.

  var MAX = 4; // temporary limit on top range (set small so we can see that we don't exceed it)
  function updateKnown(isWrong){ // works on the current card.
    if(!showingBoth){return;}
    cur.known = isWrong ? 0 : cur.known + 1
    if(cur.known > MAX){cur.known = MAX;}
  }

We believe that this function should properlay update the 'known' value for a card but we currently don't have any way to see what that is - so as a temporary hack we will modify the show routing to not show JUST the face BUT to show the known value as well. Modify the one line in show that displays the front face.

     inject('FRONT', cur.faces[front] + cur.known);

And lastly we must call that updateKnown function from somewhere. Where do we put it? Well at the moment that the user clicked on either the right or wrong button is when we can apply that knowledge so this belong right at the front of the clickedWrong routine. (And yes, I renamed the argument from boo to isWrong)

  function clickedWrong(isWrong){
    updateKnown(isWrong);
    showingBoth = !showingBoth;
    show();
    //alert("user said " + (isWrong?"WRONG":"RIGHT") );
  }

Now when you test this, pick one like mountain, that you will always get right so you will drive it to the MAX, and pick one that you will always get wrong, like cat, so that cat should always be Cat0. Let one of the others move up a bit then bust it back to zero. Convince yourself that the logic is correct.

==Unnormalized Selection
OK this should be the first and ONLY non-obvious thing in this project. I want to turn those knowledge numbers into something like probabilities and then want to choose a random card based on those probabilities. The easiest way to do this is a thing called unnormalized selection. What we do is create what we call a mass vector, it is just a list of numbers that are decreasing:

  var mass = [1000, 500, 250, 100, 50];  // this creates initial values in an array that has 5 elements
  
The notion behind it is this: when your known value is 0 you have a mass of mass[0] which is 1000. That is the NUMERATOR of your probability - we don't know the DENOMINATOR of your probability yet because that is based on the Total Mass of all the cards and we don't know that yet. But the idea is that if your mass is 1000 and your buddies mass is only 500 which is half that, well you will get selected twice as often as your buddy. The mass of 100 will get selected only one tenth as often as a level 0 the one at 50 only on twentyeth as often. These mass numbers allow us to adjust the relative frequency of the different levels.

To do the unnormalized selection we do need to know the total mass of all the cards, TotalMass. What we do in generate a random Integer that ranges between zero and up to but not including the totalMass. Then we go though the cards array and consider it for selection. Basically if the random number was less than the mass of the card we are looking at, then we selecte it. So if the first card was of mass 500 and the random number was 23 we have selected this card. There will be exactly 500 ways that we could select this first card (from 0 up to 499). But if the number was bigger than that say 599, then we move on past the first card BUT we update the random number by subtracting 500 from it first. (we subtract the 500 because in some sense those first 500 numbers were the ways that we could hit that first card, when we removed that card from consideration we must remove those unused ways from the random number) So our number moves down to 99 and we continue with the second card. Every time you pass a card you remove the mass of that card from the initial random number. Eventually the result must go below zero (because the random number was between zero and NOT including the Total Mass and if you go by ALL the cards you will have removed the Total Mass by the time you got to the last card. It is easier to write the code than to explain.

Just for the record, this sort of trick is what you typically learn in an algorithms class, it is the study of techniques that show up over and over again. Here is the code:

  function totalMass(){var res = 0; for(var i = 0; i<cards.length; i++){res += mass[cards[i].known];} return res;}
  function getCard(){
    var TM = totalMass();
    var rnd = Math.floor(Math.random()*TM);
    for(var i = 0; i<cards.length; i++){
      rnd -= mass[cards[i].known];  // decrease rnd by the mass of cards[i]
      if(rnd < 0){cur = cards[i]; return;}  // .. and set cur if it went negative
    }
    alert("you should NEVER see this alert");
    return cards[0]; // you should NEVER get to this line, but hey, just in case.
  }

If you run this code and choose one word that you always get wrong like cat, you should see that the other word choices pretty much go away and you are just telling it over and over that you get cat wrong. Cat will be staying with a mass of 1000 and the total of the other 3 is 150 so about every 10 clicks or so you get one of the other words. If you then suddenly pretend that you know the word cat, in only 4 clicks it becomes as well known as the other choices and you are back to pretty much random choices. If you then screw up any other word, it is busted to zero and stay there as long as you get it continually get it wrong. 

We have reached a milestone in this project - you now have something that essentially implements the Leitner system and shows you cards based on how well you know them. There are several other things that we can do in this system BUT before we get to those, I want to clean up a few messy details in this code. i.e. it is time for Code Review

==Code Review
If you work in a pro shop writing code, code review is when you show your boss the code that you have written and expalin how it works and the boss gets to comment on what could have been different or better about what you did. Certainly part of the reason for doing this is to let junior programmers chat with senior programmers and to pass iformation back and forth. (I do not pretend that this is a one way street - the senior programmers have typically written way more code than the juniors and often know a lot more - BUT the juniors are often fresh out of school and learned new tricks - it is just as possible that the kid had learned this cool new "unnormalized selection" routine is class and the old dog doesn't know it!) However the other part of the reason for the review is that the Company that owns the code has some interest making sure that their codes matches house style and standards so that anyone at the company can more easily know where to look at the code to find things.

For example. The code that I have showed you here was all in little chunks that I indicated that you should ADD to the ever growing javascript file. You were free to copy and paste them pretty much anywhere and it will all work.

Did you split out ALL the global variables where ever I defined them and move them all to the front of the javascipt file so that ALL the variables are right there at the top so that you can see them all in one place? Oh you didn't? Didn't I tell you to do that? Sorry, my bad. House style is to put ALL globals at the top for easy viewing (or wait, is that all at the bottom - I don't remember :). Just kidding - for me in javascript I put all global variables at the top. 

In this text file, I naturally put variables right next to the code that needed them, because I didn't know that I needed them until I was writing that little chunk of code. Since I can't easily in this text hop around from place to place in the code file, I just show you what you need and you need to split it out and place it properly.

So that is the first general comment. Now some specific ones.

That variable MAX that was used to limit how big the card.known value could get is a BOGUS variable. The reason that it existed was so that card.known could be used as an index into the mass array so really, the limit should not have been some random number like 4, it should have been mass.length - 1. So destroy that MAX var, and use the array size as the bound in the updateKnowledge code. And then test that you didn't break things with those changes.

Go ahead, do it now. I will wait.

OK, next, I didn't like the name that you used for getCard. ("What do you mean you don't like the name, YOU are the one that suggested it. Not ME!" - Yeah, Yeah, I hear you - bear with me, this is after all YOUR code even if I wrote most of it!) The problem is just this. In that code. In fact in all three versions of that code, the cyclic one, the totally random one, and the stat based one, the code named "getCards" actually shoved a value into cur. Technically that is a side effect. We used side effects ALL through this code. We used cur, a global ALL the time so that we did not need to pass that value from function to function. None the less, side effects are tacky and if you can avoid them (easily) generally you should. In this particular case I will let you choose. EITHER change the name of the function from "getCard" to "setCur", which is after all what they function is doing, OR, stay with the name "getCard" which STRONGLY suggests that the function will return a card, change the function so that instead of setting cur it DOES return a card and go change the place that called "getCard();" and modify it so that it sets cur, i.e. change it to "cur = getCard();", which makes it clear that the card that you GOT was immediately stuffed into cur. Normally I would insist on this latter course of action because it reduces the total side effects. I know, I wrote this code full of globals because that is what beginners do and that is what you SHOULD be doing right now, but the senior programmer is suggesting that we will eventually be learning a better way.

Last general comment. I used a variable, cards, to be an array of cards. Beautiful clear name, what could be better.

There is a pattern that happens often enough that it is worthwhile to identify it and write this code to match that pattern.

It is often the case that when you create a Class that represents a particular type of object, you find yourself in a situation JUST LIKE THIS ONE, where you want to capture a list of every object of that type that you create. We had a Card class (i.e. a Card function that creates Card objects) and we needed an array, cards that holds every card that we ever create. Becuase this happens so often it is nice to have a standard nameing convention that highlights that this is just another case of the standard pattern. This is the way that I would write that same card class:

  function Card(str){this.faces = str.split('|'); this.known = 0; Card.all.push(this);}
  Card.all = [];

What? Javascript allows you to treat a function name like, "Card" as a container full of all kinds of junk. That is how java script can have a single function like Card represent an entire class, all the extra class junk that you need it in that container that you normally don't see.

All I have done here is said, Hey, down inside that Card container, put a variable whose name is .all and initialize it to be an empty array.

Later on in the constructor, when I created a new card, I pushed it (the card was named "this" in the constructor) onto the list of all Cards. So that is what Card.all is, a single variable with a dot in its name that hangs onto all the cards ever constructed in the order that they were constructed. (And if you make this change don't forget to change C, the helper function that used to push the card onto cards.)

What this does is give you consistency. Whenever you see something like Foo.all = []; you KNOW that the intent is to hang onto a list of all the things of type Foo. What it also does is avoid Name space pollution, this thing - the list of all Cards - is now not really a global variable, instead it is tucked down into the Card class tied directly to that class.

OK that is enough code review. Make the changes and test that you didn't break anything. And just so you can check, here is what my final complete JS file looks like at this point.

--Flashcards.js  
  // Flashcards
  //var cards = [];  // the list of cards  REMOVED Card.all added
  var cur;         // the card currently being shown
  var front = 2; var back = 3; // train from face 0 to face 1
  var showingBoth = true;
  var mass = [1000, 500, 250, 100, 50, 25, 20, 10, 5, 2, 1];
  var nFaces = 0; // used in validate to insure all cards have same number of faces
  var nCur = 0; // used in cycleCard to sequentiall go through cards.
  
  function Card(str){this.faces = str.split('|'); this.known = 0; Card.all.push(this);}
  Card.all = [];
  function C(str){cur = new Card(str); validate(cur);} // note side effect: sets GLOBAL cur.
  
  function validate(card){
    if(nFaces == 0){nFaces = card.faces.length; return;}
    if(card.faces.length != nFaces){alert("wrong number of faces on card: " + card.faces[0]);}
  }
  
  function cycleCard(){
    cur = cards[nCur++];
    if(nCur == Card.all.length){nCur = 0;}
  }
  
  function getRndCard(){cur = cards[Math.floor(Math.random() * Card.all.length)];}  
  
  function totalMass(){
    var res = 0; 
    for(var i = 0; i<Card.all.length; i++){res += mass[Card.all[i].known];} 
    return res;
  }
  
  function getCard(){
    var TM = totalMass();
    var rnd = Math.floor(Math.random()*TM);
    for(var i = 0; i<Card.all.length; i++){
      var card = Card.all[i];
      rnd -= mass[card.known];  // decrease rnd by the mass of cards[i]
      if(rnd < 0){return card;}  // .. and return cards[i] if it went negative
    }
    alert("you should NEVER see this alert");
    return Card.all[0]; // you should NEVER get to this line, but hey, just in case.
  }  
  
  function show(){ // needs no argument because it shows cur, the current card.
    if(!showingBoth){cur = getCard();}  // get a new card if this is FRONT only display
    inject('FRONT', cur.faces[front] + cur.known);
    var backStr = showingBoth ? cur.faces[back] : ''; // blank out back if NOT showing Both
    inject('BACK', backStr);
  }
  
  function updateKnown(isWrong){ // works on the current card.
    if(!showingBoth){return;}
    var MAX = mass.length - 1 ;
    cur.known = isWrong ? 0 : cur.known + 1
    if(cur.known > MAX){cur.known = MAX;}
  }
  
  function clickedWrong(isWrong){
    updateKnown(isWrong);
    showingBoth = !showingBoth;
    show();
    //alert("user said " + (isWrong?"WRONG":"RIGHT") );
  }
  
::S Dropdown Boxes
==Dropdown Boxes
This is actually an extension of the previous project on Flashcards. We want to add some user interface elements to allow the user to change which face belongs on the front and which on the back. Of course you as the programmer have a much easier option, you can just edit the file, change two numbers, the one for front and the one for back and you are done, but if you want your user to be able to shange it on the fly, you will probably want a couple of dropdown boxes.

Since we don't remember the way that HTML encodes these we google for "HTML dropdown" we find this pile on the W3Schools site

  <select>
    <option value="volvo">Volvo</option>
    <option value="saab">Saab</option>
    <option value="mercedes">Mercedes</option>
    <option value="audi">Audi</option>
  </select> 

Since we are NOT actually building a FORM that we will send up to a server somewhere we probably won't need that value attribute for the option. (The "value" of an option is what gets pasted back to a server in a form to tell what the user clicked on. Typically that value should be short and sweet and have no spaces, where as the "innerHTML" for an option is the text that the user reads which can be long and full of spaces and strange characters) We probably will want an onclick for each option so that the actual choice of an option does something. Let's try to add this to the html document and see if it works.

  <div id="MENU">
    <lable>front:</lable>
    <select>
      <option onclick="alert('Volvo')">Volvo</option>
      <option onclick="alert('Saab')">Saab</option>
      <option onclick="alert('Mercedes')">Mercedes</option>
      <option onclick="alert('Audi')">Audi</option>
    </select> 
  <div> 

Sho nuff that seems to work fine - it pops up an alert telling me which choice I made. So what do I really want for my application? I want a dropdown that sets the front value to 0,1,2 or 3 when the user sees and selects one of the words, English,Romanji,Hiragana, or Kanji, and I need the same thing for the back value. So a pile of HTML code like this should allow me to change which face I use for the front and back.

  <div id="MENU">
    <lable>front:</lable>
    <select>
      <option onclick="front = 0;">English</option>
      <option onclick="front = 1;">Romanji</option>
      <option onclick="front = 2;">Hiragana</option>
      <option onclick="front = 3;">Kanji</option>
    </select>
    <lable>back:</lable>
    <select>
      <option onclick="back = 0;">English</option>
      <option onclick="back = 1;">Romanji</option>
      <option onclick="back = 2;">Hiragana</option>
      <option onclick="back = 3;">Kanji</option>
    </select>
  <div>  

I decided to wrap those two dropdown boxes into a single division which I named MENU. I am thinking that I might have other choices that the user can select and those lists of choices probably all belong in one division. I could have called it SETTINGS, I suppose, though menus are of course just things that present a list of choices. Anyway, put the code into the flashcard HTML file and verify that it does in fact allow you to select how you want the faces to appear when you are working your cards.
 
==Meta Programming
However, that particular HTML code hardwires me into working with the 4 face choices for Japanese. If I want to create Spanish flash cards, those would be the wrong dropdown menus. What I would prefer in my flashcard app is to "tell" the app the number and names of the faces in one place and to have the app generate that HTML code for me, so that is what we will do now. 

I am thinking that I ought to be able to tell the app the card structure, the list of face names, just before I start creating like this:

  faces('English|Romanji|Hiragana|Kanji');
  C('Cat|Nekko|ねこ|猫'); 
  ... 

I know that I can use .split() just like I did before to turn that single pipe separated string into an array of strings. Since I will need two dropdown boxes, and they only differ by the name of the variable that we will be writing into, I think I will want to have a function dropDown(varName, faceArray) that generates a single drop down and then my faces() routine can call it twice. That is probably enough strategy, let's just write it.

  function faces(faceNames){
    var faceArray = faceNames.split('|');
    nFaces = faceArray.length; // might as well set that up here.
    var res = dropDown('front',faceArray); // that puts the first one into res
    res += ' ' + dropDown('back',faceArray); // .. appends the second dropdown
    inject('MENU', res); // shoves this to dropdowns into the MENU 
  }
  function dropDown(varName, faceArray){
    var res = '<lable>'+ varName +':</lable><select>'; // note: I start the select here
    for(var i = 0; i<faceArray.length; i++){res += option(i, varName, faceArray[i]);}
    res += '</select>'
    return res;
  }
  function option(i, varName, str){
    return '<option onclick="'+ varName +' = '+ i +';">'+ str +'</option>';
  }
  
I will still need to have a division named MENU that I can inject into:

  <div id="MENU">Menu goes here</div>
  
So remove all the hard wired selects that we put in the HTML and instead use that empty Menu division. (I often put some text into my "empty" divisions so that when the code is NOT working, I can see that I do in fact have a slot out there to inject into.) And don't forget to put in the line that calls the routine faces():

  faces('English|Romanji|Hiragana|Kanji');
  

The code was fairly straight forward even if it is a bit hard to read. HOWEVER, before we run this and see if it works, I want to mention debugging.

What we are doing here is called meta-programming. We are using one language, javascript, to write out code in some other language, HTML. This is of course what javascript is all about, shoving junk, probably HTML, out onto a page into slots that were set aside to hold the junk. WHEN the HTMLJUNK fails to run correctly, you no longer have the option of just looking at that HTMLJUNK in your editor to see what was wrong. The reason is that you didn't WRITE the HTMLJUNK, instead you wrote the code that wrote the HTMLJUNK. So how to do you debug that JUNK. Simple! You need to alert it out to see what HTML your code actually created so that you can see if it has any flaws, and if so figure out what your meta-program was doing incorrectly.

  inject('MENU', res); // this shoved HTML out into the menu..
  alert(res);  //.. and this shows you the HTMLJUNK that you shoved out
  
Anyway, that is what you would do IF you had any problems. Of course, we are MASTER coders here and don't make mistakes. There will be no problems here. "These aren't the droids you are looking for!"

It all works fine. (To be honest, it all worked fine after I fixed a few bugs, like after carefully creating a res string in my dropDown function I totally forgot to return that res to the outside world, as a result instead of dropdown boxes on the screen I saw NaN - an error code meaning "Not a Number" - once I actually returned res it worked fine. I did put in the debugging alert and confirmed that that trick worked as I said it would then I ripped that out as well.)

==Non Leitner - Learning Theory
At this point we have a flash card application that is already WAY better than the ones that you can find elsewhere. One of the reasons that it is way betters is that it uses something like the Leitner method to modify the presentation frequency based on the stats. (Of course the REAL reason that it is way better is something that you would probably NEVER have thought of. The BEST feature of this app is that you built it yourself! As a result, you can add and remove words at ease with your text editor. You can change the size and the color with your CSS file. You can make the layout be just what you want. When you write the code yourself you OWN all the flexibility! You CAN'T BUY code that is this excellent!)

None the less there is a drawback to the Leitner method that we have deployed. I could just let you enter the two thousand JOYO Kanji cards (the complete set of roughly 2000 Kanji characters that define being High Shcool level literacy in Japan) all by yourself. If you did that (and I know you won't!) you would very quickly see the problem OR I could just tell you.

The problem is this: suppose I have 2000 flash cards in the system all completely unknown, all starting at level zero. They are all equally likely to be shown. You would on average flash through a thousand cards before you ever saw a the same card for a second time. You are NEVER going to learn that way! Proper flashing means trimming down to a small set (maybe 8 cards??) and working on those, seeing the same card multiple times, and only moving onto new cards when you have learned those ones.

How can I adjust the system so that it doesn't try to show me all the cards at once? This is the method that I though of - include a value of zero in the mass array. Any card with a mass of zero will never get selected, it is effectively invisible, not in play. Next, limit the total mass of all your cards to some number like 8 times the largest mass. (this means you can have at most 8 totally unknown cards in play ever). Finally look at the total mass occasionally (like every single time you adjustKnowledge) and if it is too HIGH (too many unknown cards in play), then shove some of those cards into the zero-mass box - i.e. take them out of play on the other hand if total mass is too LOW (like maybe 4 times the largest mass) it is time to throw some of those out of play cards back into the mix.

Yes, I have just made up some numbers as limits, but we can easily adjust them if the system doesn't feel good. All we are trying to do is make it possible to start with LOTS of cards and the system will immediately reduce them down to eight or so and ONLY introduce new cards, when you have mostly learned those eight. Note: there is nothing that prevents you from having thousands of cards in play all at they same time, they just CAN'T all have knowledge level zero all at the same time! We set the highest mass at 1000, we set the lowest at 1, so if the limit on total mass is 8000, you can have 8 totally unknown cards (mass == 1000) OR 8000 totally KNOWN cards (mass == 1). 

What I am actually going to do is this. Make the LAST value of the mass array be the zero mass. We will start ALL cards off with card.known = mass.length-1 instead of at card.known = 0. This means that we start the world with totalMass == 0, way too low. And whenever the total is too low we try to introduce a new card.

In fact, now that I think about it, we have a function named totalMass that we run just before we select a new card. We can make that function have the side-effect of bringing cards into or out of play. Basically as I am going through all the cards computing the total mass, I will find a card (if I can) that is totally unknown (known == 0) so that I can take it out of play if TM was too big, also I will look for a card that is out of play (known = mass.length-1) which I can bring into play if TM was too small. I will calculate total mass same as before and after the loop I will adjust the result IF NECESSARY by adding or tossing one of the cards that I found. I also threw in some instrumentation just so I could watch it work. Basically I added a MSG division to the HTML and this routine injects the totalMass into that div on each pass so I can see it go up and down as I click on the cards.

  function totalMass(){
    var str = '';
    var res = 0; 
    var oop = Card.all[0]; // this will be replaced by and out of play card that we can turn on if TM is LOW.
    var unk = Card.all[0]; // this will be the totally unknown card to remove if total mass gets to BIG
    var inPlay = 0;
    for(var i = 0; i<Card.all.length; i++){
      var card = Card.all[i];
      if(card.known == mass.length-1){oop = card;}else{inPlay++;}
      if(card.known == 0){unk = card;} // found an unknown card
      res += mass[card.known];
    }
    if(res > massMax){res -= mass[unk.known]; unk.known = mass.length-1; str = '-'+unk.faces[0];} //remove unk
    if(res < massMax/2 && oop.known == mass.length-1){
      res -= mass[oop.known]; oop.known = 0; res+= mass[oop.known]; str = '+'+oop.faces[0];
    } // introduce oop 
    inject('MSG', str + " TM: " + res + " inPlay:"+inPlay);     
    return res;
  }

And here is a pile of Kanji (most of the first grade kanji) to learn

    faces('English|Romanji|Hiragana|Kanji');
    C('Cat|Nekko|ねこ|猫'); 
    C('Tree|Ki|き|木');
    C('Sun|Hi|ひ|日'); 
    C('Mountain|Yama|やま|山');
    C('one|ichi|いち|一');
    C('two|ni|に|二');
    C('three|san|さん|三');
    C('four|shi|し|四');
    C('five|go|ご|五');
    C('six|roku|ろく|六');
    C('seven|shichi|しち|七');
    C('eight|hachi|はち|八');
    C('nine|kyu|きゅう|九');
    C('ten|ju|じゅう|十');
    C('hundred|hyaku|ひゃく|百');
    C('thousand|sen|せん|千');
    C('above|ue|うえ|上');
    C('below|shita|した|下');
    C('left|hidari|ひだり|左');
    C('right|migi|みぎ|右');
    C('moon|tsuki|つき|月');
    C('year|toshi|とし|年');
    C('early|haya|はや|早');
    C('woods|hayashi|はやし|林');
    C('river|kawa|かわ|川');
    C('soil|do|ど|土');
    C('sky|sora|そら|空');
    C('paddy|ta|た|田');
    C('heaven|ten|てん|天');
    C('raw|nama|なま|生');
    C('flower|hana|はな|花');
    C('grass|kusa|くさ|草');
    C('insect|mushi|むし|虫');
    C('dog|inu|いぬ|犬');
    C('person|jin|じん|人');
    C('name|mei|めい|名');
    C('female|onna|おんな|女');
    C('male|otoko|おとこ|男');
    C('child|shi, su ko|こ|子');
    C('eye|me|め|目');
    C('ear|mimi|みみ|耳');
    C('mouth|kuchi|くち|口');
    C('hand|te|て|手');
    C('foot|ashi|あし|足');
    C('see|mi-ru|みる|見');
    C('sound|oto|おと|音');
    C('power|chikara|ちから|力');
    C('spirit|ki|き|気');
    C('yen|en|えん|円');
    C('enter|i-ru|いる|入');
    C('exit|de|で|出');
    C('stand up|ta-tsu|たつ|立');
    C('rest|yasu-mu|やすむ|休');
    C('previous|sen|せん|先');
    C('evening|yuu|ゆう|夕');
    C('book|hon moto|ほん|本');
    C('text|bun|ぶん|文');
    C('character|ji|じ|字');
    C('study|gaku|がく|学');
    C('school|kou|こう|校');
    C('village|mura|むら|村');
    C('town|machi|まち|町');
    C('forest|mori|もり|森');
    C('water|mizu|みず|水');
    C('fire|hi|ひ|火');
    C('gem|tama|たま|玉');
    C('king|ou|おう|王');
    C('stone|ishi|いし|石');
    C('bamboo|take|たけ|竹');
    C('thread|ito|いと|糸');
    C('shellfish|kai|かい|貝');
    C('car|kuruma|くるま|車');
    C('gold|kin|きん|金');
    C('rain|ame|あめ|雨');
    C('red|aka|あか|赤');
    C('blue|ao|あお|青');
    C('white|shiro|しろ|白');  
    
==Presentation Curve  
I mentioned Learning Theory above and then said nothing about it. I come from a physics background and the theories are quite precicse, quantafiable math formulas that tell you where the cannonball will land if fired with this speed and in this direction at this angle when the wind is blowing like THIS and the earth is spinning like THAT and you are at a known latitued.

Learning theory is not physics and is not like that. It is considerably more mushy, just broad strokes, "hey you want to do something like this, X is better than Y, you know, well at least sometimes." 

So one of the things that we have done in this app is to create a mass variable. That mass variable directly drives the presentation probabilities. My mass variable as currently defined goes from 1000 to 500. The first step drops the probability of seeing a card by one half as soon as you've seen it once. In fact if you look at the table, you can see I roughly followed that rule all along, each new number being about half of the previous one.

This is a linear curve. Is it right? Should the curve be linear? Should it drop off faster? Slower? How should I know? I just write the code. We need to do experiments. Now I don't expect you to know any Japanese, I already do, so it is hard for me to judge if the presentation curve is correct. 

That is the next exercise for you, to play with the system as a NOVICE in Japanese and see if ANY of the numbers that I selected are the right learning frequency FOR YOU! (Again I point out - you wrote this code, making this a better app than ANY that you could buy. What other app would let you TUNE the presentation frequency curve to fit your personal training profile/preference?

I will tell you what I see when playing with this app the way it is now and with my reasonalby good knowledge of first grade kanji. I set it to go from Kanji to English so that I can practice my reading. When the numbers in the mass array drop off slowly you get a uniform presentation frequency, the likely hood of seeing a character that you know is not much different from the ones that you don't know yet. My impression is that this is good for the first few presentations. It means that a character that was introduced at level zero is NOT much different from you that you have only gotten right once at level 1. However, once I have seen it and gotten it right 4 or 5 times, I am sort of done with it. Get is out of my face and pound me on the few that I dont' know. I think that I want the curve to be more S shaped, pretty level at the front end, a steep dropoff in the middle, and then level toward the bottom.

Learning theory does NOT tell us what the optimal shape of that curve is. It is unlikely that there is an optimal shaped curve that work for evey person for every language flash card task. All that IS known is that you shouldn't swamp your learner with too much knowledge right up front (and we have dealt with that using the arbitrary number 8) and that once they know something, the presentation frequency should drop (not to zero, forgetting does happen so it is GOOD to occasionally pull something from the well known pile and refresh it) and that is of course what our Leitner design does for us. So we have followed the theory about as far at the formal studies can take us, but that doesn't mean that we shouldn't continue to take note as we use the system, whether we couldn't tune the system a bit more to our liking.

I choose the following mass table. Notice, sharp drop from 600 to 100, then back up to 1000, then on down. A well known card is forced back into being likely befor it descends into the dark.

  var mass = [1000, 700, 600, 100, 1000, 30, 10, 5, 4, 3, 2, 1, 0];

==Wait -I just saw that!
One of the features that I have traditionally included in flashcards systems that I have built in the past was that I didn't like the system to show me the card that I JUST looked at. Yes, Nekko is cat, Nekko is cat, yeah I got it Nekko is cat - come on, I know I blew it once, there are other cards, show me one of those. Oddly enough, when I built it once again for this write up where my emphasis was NOT in writing a flash card system but was in teaching how to write code, I found myself untroubled by that immediate repetition problem. I like to think that I have learned some patience with advancing age and am willing to look at the same card again immediately, though I must confess that possibly my attention span and memory have just fallen so low that I can't even remember which card I just looked at, "Did I just look at Nekko? Hmm... maybe."

In any case - as an exercise to you, how would you change the code to fix this defect in our current program if you, as I once did, actually view it as a defect?

You already have a routine that will get a card getCard(), and that routine has access to cur, so it knows what the previous card was, so it COULD test if there was a match and it could look again, so not too difficult a fix. However as a senior coder allow me to make a suggestion befor you hack up getCard to NOT return the same card that is sitting in cur.

The suggestion is just one that does not typically occur to noobs. getCard works perfectly fine as it is. If you start editing that code you could break it and they you will have to test it a put it back together again. You could instead write a new routine, getDifferentCard() that can call getCard, many times if necessary, and then call that new routine in show() instead of the just calling getCard(). All this does is protect you a bit from a screw up AND makes it trivial to set it back to the way that it was. (I used the name, getNoRepeatCard().)

What noobs tend to do that old timers learn to avoid is to write long code. They have one function that does X and they realize that it should also do Y so they edit it to do X+Y and then, oh yeah, Z would be nice too so now it is X+Y+Z. Soon the code is LONG LONG functions. This is SO easy to do, I mean code is just a SEQUENCE of events just one after another and if the sequence is long - well it is just a long sequence.

This is NOT quite the correct view. Certainly part of what functions do is let you break code down into chunks that you can reuse from different places, but the other things that functions do is let you give NAMES to the steps in your code, So when X used to be something you needed, and you now need X and Y, possibly instead of hacking the X function into one that does X+Y you leave the X function alone, write a new Y function and replace what used to be a call to X to yet another function XY that does both. The point is that you can use functions to break up and document that long sequence, giving names to steps. New programmers tend to used too few functions. 

So here is a rule of thumb on that: You have no doubt heard of the psychological importance of the number 7, something like you can keep 5 to 7 distinct things in your head at one time but more than that starts to be too much - well, any function that gets longer than about 5 to 7 lines is too long. Try to chop it up. I actually strive to make my functions just one line long. I certainly don't always succeed. 

Anyway, last comment on selecting a card that doesn't match cur. Yes you could just call getCard again if you got a match. and then call it again if it matched again. and then again. and again. ... Did you just introduce an infinite loop into your program? What you risk is that the user clicked the card and instead of instantly returning a card the system leans over while the random number generator keeps choosing that very high probability totally unknown card that it just showed you instead of one of those deeply known and very unlikely cards?

Infinite loops are bad. The system leans over and never returns. BLUE SCREEN OF DEATH! The probabilities that we are dealing with will PROBABLY never get so lop-sided that the system ever has ANY noticable slowdown even if you had thousands of kanji cards (and you could) and even if you had to look thought that list a thousand times, BUT the crafty programmer will look at that probability and say, "You know, fixing this NO IMMEDIATE REPEAT cards problem was NOT so improtant that I want to introduce any thing resembling an infinite loop so I am going to PREVENT the system from looking again and again and again". The prevention of this is EASY. Create a loop that calls getCard() and IF is doesn't match cur return it and you are done, BUT if you have done the loop one hundred times, and got a match for cur back EVERY SINGLE TIME then you fall out of the loop and deal with this terribly unlikely circumstance. How you deal with it - I don't much care. You can just give up return cur and let an immediate repeat happen. OR you could just give up on your probabilities all together and return Card.all[0], even if it was out of play. OR you could look for some other card to bring up. It doesn't much matter becasue this really was just protection from the very unlikely possibility of having introduced an infinite loop.

One last comment on this topic. IF you DO put in a loop like this, one that prevents an unlikely event from happening, by the very fact that you wrote code to make it VERY LIKELY that you would exit one way (with a different card from cur) and VERY UNLIKELY that you would just fall through the loop and select an alternative, it mean that if you just run the code to see what happesn it is unlikely that you will ever take the unlikely path. If you NEVER take the unlikely path then you have NEVER tested that path. What if that code has a simple crashing bug?

You, as programmer, have an obligation to test your code and at least convince yourself that it does what you thought it ought to do. Whenever you write code that occurs on an unlikely path, you need to consider how you will FORCE the code to go down that path when you are testing. In this case I would try it once with the limit changed from 100 to 1 or even to zero. I would also put in an alert to tell me, "Limit failed - repeated char comming up." When I see that alert, I know that I am running the code outside of the loop.

::S MobyDick
==Moby Dick
Call me Ishmael.

Or don't call. Fine by me. This project is actually here just to help you get a handle on Text Processing. 

We are going to take some text, a few paragraphs from Moby Dick, and do some text processing. What we are going to process, well, to be honest, I don't exactly know. "I thought I would sail about a little and see the watery part of the world." What we do depends pretty much entirely on the format that the text is in when we steal it from project Gutenburg. And that is the purpose of this exercise - to show you some of the text processing tools that are available in javascript and how you think about them and use them to mash text that is in ONE format into some OTHER format.

So start off with the HTML template, rip out the CSS, we won't be needing any of that. We probably won't need an external javascipt file either rip out that line or set the filename to null (this will cause the load to fail but it will fail silently). The body of my document looks like this:

  <body>
  <h1>Moby Dick</h1>
  <div id="TEXT"></div>
  </body>

Basically it is one heading and one empty division where I can paste something.

==Project Gutenberg
Head out to project Gutenberg. If you have never been here before, look around check it out. These people were stealing books back before there was an internet. No, stealing in the wrong word, they have been carefully following copyright law and copying the text from books that are int the public domain, into an 80 column punch card format (which shows you how long they have been at this) making it a LARGE resource of essentially free books. In the old days they ONLY had their original 80 column card format but now days they got PDFs and HTML, and audio formats and who knows. One assumes that geeks saw this free stuff in an old format and said to themselves, "Hey we could reformat this stuff and make it more accessible, easier to read." 

Today we are going to be one of those geeks. So we are not interested in the more readable formats. We only trust the 80 column format. We are going to produce one of the more readable format. So go find Moby Dick and take a look at the 'Plain Text UTF-8' copy.

It will start with a bunch of junk like:

  The Project Gutenberg EBook of Moby Dick; or The Whale, by Herman
  Melville
  
  This eBook is for the use of anyone anywhere at no cost and with almost
  no restrictions whatsoever.  You may copy it, give it away or re-use it
  under the terms of the Project Gutenberg License included with this
  eBook or online at www.gutenberg.org
  
Look at all those 80 column lines - you can almost smell the punch cards lurking silently in the background. Of course that fishy smell of LEGAL THREAT, "almost no restrictions" was not penned by Herman Melville, that was text that was ADDED by the project, when they took that wonderful FREE PUBLIC DOMAIN text by Herman, made a copy and ADDED a sprinkling of LEGAL text, which technically makes this a DERIVIATE COPY, a NEW and IMPROVED version of Moby Dick, and THUS this new version can be re-copyrighted giving them, Project Gutenberg, the ability to threaten legal action if you don't treat their COPYRIGHTED material (meaning ALL of MOBY DICK and their sprinkling of LEGAL TEXT) in the way that they tell you.

FORTUNATELY, they are in fact the good guys, they know that you just wanted a free copy of Herman Melville's masterpiece and pretty much let you have at it. Also fortunately we are academics engaged in active pursuit of knowledge and are given a very special FAIR USE clause in the copyright law that allows us to make copies of stuff for our research so we are pretty much OK even without reading though the Project Gutenberg Legal Thicket.

Looking further down you will see an amazing amount of garbage, (Table of Contents, EXTRACTS, ETYMOLOGY...) was this from Melville, or is this just an extra sprinklings of trash that some BOOK publisher added in some earlier attempt to refresh a copyright, extra trash that was in the book that Gutenberg copied? Who know? Who cares. Call me Ishmael.

Scroll down and you will eventually come across CHAPTER 1. Loomings and those first words of the actual book. Please copy 3 paragraphs out of that, and we will limit our play with text processing to those 3 paragraphs at first. I would cheerfully tell you to copy the whole book and work with that, and indeed, before we are done we will probably do that, but 3 paragraphs is certainly enough for you to see the problems and develop the solutions involved in groveling over and altering this text.

What do you do with that text that you copied? Well this is a trick that I have used on occasion. (In fact, I am using it right now in this online text that you are currently reading!) I want to put the paragraphs that you copied someplace where I can load it up into a string variable in Javascript so that I can play with that text string. I don't want to just put quotes around it - that wouldn't work - the text itself is full of quotes, and is spans multiple lines. Instead I want you to put a NEW script section up in the HEAD of you document that looks like this:

  <script id="RAW" type="Garbage">

Then immediately after that line paste in the 3 paragraphs and then immediately after that put in the closing tag for the script section you know, the open angle brackt slash script close angle bracket thing (humm ... why is he hesitant to write that out for us - in moments you will see.)

So what did that script do for us. Well It had an id attribute so we can find it AND fetch out the text with a call to 
  var str = document.getElementById('RAW').innerHTML;
  
The type="Garbage" attribute is the interesting attribute. The script tags that you have seen so far don't have attributes. That is because the default 'type' attribute is "text/javascript". So any script that DOESN'T have a type attribute assumes that the script is written in javascript and starts running the javascript compiler on that text. We told the system that THIS PARTICULAR script is written in the language named "Garbage". I am assuming that no one has yet named a language Garbage and installed it into your browser so I am playing the odds here that your browser, sees the script tag, assumes that the code is written is some weird language named Garbage and so it just looks for the closing script tag scanning over all the text inside. When it finds the closing script tag it can then run the Garbage-language compiler on that - oh wait, it can't find a Garbage compiler anywhere. Oh well, fail silently and continue reading the document.

As I said, this is just a cheesy trick that I came up with to let me load a bunch of RAW text into an HTML document so that I can then play with it in javascript. 

--sidebar
I used this trick in this online book. YOU see a bunch of different pages that you can click through. That is my javascript showing you the text in different pages. The actual text is being kept in one single script block and my javascript fetches it out and carves it up into pages. And that is the reason that I do NOT write a closing script tag anywhere in this instructional text. If I wrote a closing script tag in my book the browser thinks that my script and my text book ends right there. You will of course run into the exact same problem if Herman Melville just happend to put a closing script tag into the text of Moby Dick somewhere. I think the odds are low and we are safe.
--end sidebar

Next we modify our window.onload over in the REAL script section that contains our actual javasciprt code. We are just going to fetch out all of the text in RAW and stuff it into that empty division named TEXT.

  window.onload = function(){
    var str = document.getElementById('RAW').innerHTML;
    inject('TEXT', str);
  } 

When I do that I see the 3 paragraphs all folded into one single paragraph stuffed into that one division, and that is of course exactly what I expected to see. Since there are NO html tags in that text to mark paragraph boundries it just all flows together into one block of text. So next, let's see if we can actually find those paragraphs in the raw text.

==Cards
We have a string that is the entire text of our raw script. We will first split it into pieces using the newline character that delimits each line. That split will get us an array of lines. I will call each of those lines 'cards' because that is how I think of them, they are 80 column punch cards. So add this to your onload function

  var cards = str.split('\n'); // splits str into individual cards.
  
I like to BELIEVE that the breaks between paragraphs was done by inserting a card that was completely blank in between the cards with text. However what I DON'T know is how clean the data is. Did those blank cards have absolutly nothing on them so that the strings were actually empty or did they have a few space characters on them or maybe space and tab characters? There could be several invisible characters (commonly called 'white space') on those blank lines. We won't know till we look at some of them. So when I break it into cards I am expecting cards[0] to be that chapter title, "CHAPTER 1. Loomings." and I am expecting cards[1] to be a blank line. So add these alerts after you create cards.

  alert(cards[0] + " - " + cards[0].length);
  alert(cards[1] + " - " + cards[1].length);

Well, I was wrong. Glad I did that experiment. cards[0] was a blank card, which in after thought is what I SHOULD have expected. My raw script section starts like this:

  <script id="RAW" type="Garbage">
  CHAPTER 1. Loomings.
  
  Call me Ishmael. Some years ago—never mind how long precisely—having
  little or no money in my purse, and nothing particular to interest me
  on shore, I thought I would sail about a little and see the watery part

And what is the VERY first character in that script section? Do you see it? It is the carriage return on the end of the line that follows the closing bracket of the script tag itself. So when I split by new lines, the amount of stuff that came just before that first carriage return is an empty string.

So I changed my code and alerted out the first 4 cards just to be sure, and other than the first card being blank, the ACTUAL blank card between the chapter title and the text was indeed of length zero indicating that the breaks really are empty cards. Are they all empty? I have no proof but it is a reasonable first guess. We will assume that the data is fairly clean until we see otherwise.

==Chunks
So I am thinking that I want to format this text as paragraphs just so that it looks more like I expect. This means that instead of cards, I really wish I had an array of chunks (and I will call them chunks rather than paragraphs - because SOME of those chunks will actually be CHAPTER headers). To create these chunks, I will need to go through the array of cards, looking for blank cards and gluing multiple non-blank cards back together into single chunks. Note, when I do that, I don't just want to glue cards together with NOTHING in between. When I created the cards by spliting on new line, those new line characters were all removed. That first string that starts "Call me Ishmael" ends with "precisely-having" and the next line starts with "little". I will need to glue them back together with a space character in between if I don't want to produce "precisely-havinglittle".

What I think of next is how I am going to produce these chunks and what I imagine is a little factory, that works like this: I shove in a card. The factory looks at the card and if it is non-blank, it glues it onto the end of the currently growning chunk. On the other hand, if it is blank, it will flush out the currently growing chunk to the growing array of chunks. 

Oh yes, and while I am at it with a simple guard on that flushing, I can collapse multiple blank cards (if there are any) into acting like a single blank card. Basically if the growing chunk is null (i.e. a brand new growing chunk because I just saw a blank) and then I see yet another blank line I DON'T flush out that empty chunk. I don't need to flush an empty chunk I ONLY flush out chunks with actual text in them. That way a single blank card or multiple blank cards all in a row will act as one single delimiter.

  var growingChunk = ''; // first growing chunk is empty
  var chunks = []; // and we start with an empty list of chunks
  function chunkFactory(card){if(card.length == 0){flushChunk();} else {growingChunk += ' ' + card;}}
  function flushChunk(){if(growingChunk.length != 0){chunks.push(growingChunk); growingChunk = '';}}
  
Notice that flushChunk does the guarding directly. One last warning. Once we start this process of stuffing cards in order into our chunkFactory how does it end? What I mean is what happens if the very last card is not a blank, we end up with that last chunk sitting in growingChunk and it never gets flushed to our list of chunks. Is it safe to just call flushChunk() at the end of the process? What happens if the actual raw text DID have blanks as the end? Does a single call to flushChunk() actually work in that case? The answer is Yes, it does work. Because flushChunk is guarded - if there was a chunk remainder it flushes it out to the chunks and if there was NOT, because there were blank cards at the end, another call to flushChunk does NOTHING.

This is just reflexive behavior for me. I am used to writing code and am used to BOUNDRY conditions. Did everything start out OK, all properly initialized. Does everything end properly? humm.. I could have had been stuck with a growingChunk... how do I flush it out? Oh, I already have a flush routine, will that work. Oh yeah, it does perfectly! How nice is that?

  function createChunks(cards){
    for(var i = 0; i<cards.length; i++){chunkFactory(cards[i]);}
    flushChunk(); // make sure that the last card got out
  }
  
I want to test this code. What is the easiest way to do that? I suppose I could do an alert on each chunk as it comes from the factory, or I could write a routine to go through the chunk array and alert them out. OR since most of them should be paragraphs, I could just go ahead and write the code that will treat EVERY chunk as a paragraph. In a loop I will wrap each chunk with paragraph tags, and glue them all together back into one single HTML string which I can then inject into my TEXT division. Lets do that.

  function showParagraphs(cards){
    createChunks(cards);
    var str = '';
    for(var i=0; i<chunks.length; i++){str += '<p>'+chunks[i]+'</p>';}
    inject('TEXT', str);
  }

So add those functions, chunkFactory() etc, creatChunks(), and showParagraphs(), to your script section and put a call to show paragraphs into our window.onload function.

  window.onload = function(){
    var str = document.getElementById('RAW').innerHTML;
    var cards = str.split('\n');
    showParagraphs(cards);
  }

Wow - worked perfectly. Now I know that this probably means nothing to you whoever you are, because you probably grew up with fast computers with lots of memory. I grew up working on computers that could barely hold the entire text of Moby Dick on their hard drive let alone in memory. You certainly couldn't hold an entire novel on a single floppy disk so you could NOT actually edit a book. You could edit chapters and then change disks when you wanted the next chapeter. The code I just had you write is taking a huge chunk of text, and ENTIRE NOVEL, rips it up into tiny cards, then glues them back together first into chunks and then finally gluing those chunks into a single string and THEN when that is all done processing it into letters that show up on your screen. It was IMPOSSIBLE to do that much work when I was a young programmer, or would have been way too slow. SO I had to try it. I copied the entire text of Moby Dick, chopped off the legal and garbage from the front, chopped off the legal trash from the back, pasted it into my html files script section, saved it and and ran it. Yup It took actual time! The text of MobyDick did not come up instantly on the screen. It took maybe half a second to show up. Wow!

Anyway - we are not done processing this text yet. I just wanted to point out that except for turning the chapter headings into actual heading, we have done most of the work that was done by those friendly geeks that created PDF files and HTML files from the original Gutenberg card-image files. It took all of 17 lines of code. Not too much work. Let's do better.

==Same thing Object Oriented
Nothing that we have done so far is very object oriented. Everything was done with global function. Before we get too far into this task, I want to switch to being object oriented. In particular I am thinking that I might want to have different ways to display paragraphs and that will be easier with I have functions that act on the chunks differently. So I am already thinking that Chunk should be a class and those chunks are objects.

Since we already have some code that deals with chunks, I expect that I can reuse that code BUT I am going to have to change the names of them and pack them in a little differently to fit into Javascripts notion of what classes look like. We used classes before when we created our flash cards however in that project we used them like C-structs. Our flash cards held data but didn't have any functions relating to them.

If I am going to treat a chunk as an object, I need to know the data members for our Chunk. The Chunk itself will certainly contain the text that makes up our paragraph or header and I will also want a boolean member to tell us whether the chunk is a paragraph or a header. Our constructor for chunks will only be called by that factory when it determines that our growing fragment is a finished Chunk and we can make our constructor add it to the list of Chunks. We will rename our that array of that the chuks to be Chunk.all and follow our 'all pattern'. 

So here is my rewrite of code above, just renamed some of the function and converted them over into something more resembling objects. Take a look at the code - you should see many chunks that you recognize, I will then comment on what we did.

  function Chunk(){this.text = Chunk.frag; this.isHeader = this.detectHeader(); Chunk.all.push(this);}
  Chunk.all = [];  // this will be our array of chunks
  Chunk.frag = '';  // this will be our growing chunk fragment
  Chunk.addCard = function (card){if(card.length == 0){Chunk.flush()}else{Chunk.frag += ' ' + card;}}
  Chunk.flush = function (){if(Chunk.frag.length != 0){new Chunk();}} // creates and adds to list
  Chunk.createAll = function(cards){
    for(var i = 0; i<cards.length; i++){Chunk.addCard(cards[i]); Chunk.frag = '';}
    Chunk.flush(); // convert final frag (if there is one) to chunk.
  }
  Chunk.allParagraphs = function(){
    var str = '';
    for(var i = 0; i<Chunk.all.length; i++){str += Chunk.all[i].asParagraph();}
    inject('TEXT', str);
  }
  
First of all there is some javascript syntax that you have never seen AND it is unlike any notation that you will ever see in C or in Java. Javascript has the notion that variables can hold ANYTHING and that includes functions. You have seen this function definition:

  function foo(x){...} // create a function named foo that takes in an argument x and does something
  foo(13); // call the function withe the value 13

What you haven't seen is this alternate way of defining a function.

  var foo = function (x){...} // create a variable named foo that holds an Anonymous function (no name) that has arguement x
  foo(13);  // call the function that is sitting in the variable named foo and stuff it the value 13.
  
The functions were defined differently BUT you can't even see the difference when you use those function. 

I used that syntax when I wrote Chunk.flush = function and Chunk.addCard = function. This is a more object oriented way of defining these function. Basically instead of having a global function named flushChunk, I have a Class named Chunk and down inside that class I have created a variable named flush, and I loaded a function into that variable. This then allows me to call the function like this: Chunk.flush() - which means, "go to the Chunk class, fetch out the function named flush and run that". In many ways, this is NO different from telling you that I have a global function named Chunk.flush instead of one named flushChunk. The behave exactly the same way. BUT by tucking that function down in that class, I am making it clear that that function, flush, is actually some kind of helper function for the Chunk class.

== static members
One of the concepts of Object Oriented code that I have NOT talked about yet is static members. This is a TERRIBLE choice of names. It is an adjective that comes from C that has NO meaning to someone that is just learning an object oriented language. Sorry about that. However its meaning, once you get it, is clear. non-static members (both data and function members) directly relate to OBJECTS. An object has data members or fields, those are sub-components of the object, those are therefor non-static members. Similarly any function that acts directly on an object IS a non-static member. 

I am going to show you the way that you can tell the difference between static and non-static members in the way that you use them. IF we follow the conventions to ALWAYS name classes with a capital first letter and to NEVER name variables and function with a capital letter, I can instantly look at a name and distinguish between a class name, like Person, and a variable name like person (that we will assume contains a single object of type Person). So if I write a function in my Person class that is non-static, that means that is MUST act on a single person like this: person.print() - presumably a function like that prints out the name of the person object that is sitting in the variable person. On the other hand if I create a static function, it is just some global function that happens to live down inside a class and I need to call it by supplying the Class name where that function lives: Person.print() - presumably this print function does NOT print the name of any person. This function was not handed ANY actual person object to interact with. It is just printing something, maybe an error message, that was written somewhere in the class.

So that is the way to think about static vs non-static. Non-static is the default way of doing things in a class, because the class is all about defining the fields of ojbect and doing things with objects of that type. However classes may will need helper function, like our chunk factory that is holding temporary information while we assemble an actual chunk. All those helper variables and helper function are most definately NOT sub-components of a Chunk object, they are essentially global variables and functions that are so closely associated with chunks that we have stuffed them into the Chunk class and given them names so that you can see that they are there to help with chunks.

So that global vars and functions that I used to have, named: chunks, growingChunk, chunkFactory, flushChunks, createChunks, and showParagraphs - all get more regularized names and I tie them directly into the Chunk class (which was created when we created a function that was a class constructor - that was the function Chunk - starting with a capital letter). Those vars and functions were regularized and renamed as Chunk.all, Chunk.frag, Chunk.addCard, Chunk.flush, Chunk.createAll, Chunk.allParagraphs. Now you can see that all those functions and variables are static members, helpers, in the class Chunk.

And that is ALL we have built so far, the class constructor, Chunk, and those static helper functions. 

At the risk of confusing you, let me show you the way that java would do these same things. Java would look more like this:

  class Chunk{               // all vars and all funs are contained in a named class - no free floating globals
    String text;             // these are the two non-static data members in a Chunk object, text and isHeader 
    boolean isHeader;
                             // .. and here are the globals, named in the class, so Chunk.all and Chunk.frag
    static ArrayList<Chunk> all = new ArrayList<>(); // these are the static data members that are class helpers
    static String frag;
    
    Chunk(){text = frag; isHeader = detectHeader(text); all.add(this);} // the constructor for a Chunk object
    
    // none of the function are object function, they are all static, global
    static void addCard(String card){if(card.length == 0){flush();}else{frag += " " + card;}}    
    static void flush(){if(frag.length != 0){new Chunk();}}
    static void createAll(String[] cards){
      for(int i = 0; i<cards.length; i++){addCard(cards[i]);} 
      flush(); // convert final frag (if there is one) to chunk.    
    }
    static String allParagraphs(){
      String str = "";
      for(int i = 0; i<all.size(); i++){str += all.get(i).asParagraph();} //as Paragraph not yet defined in this class
      return str;
  }

The things that I want you to note: Java requires the word static on every variable or function definition that is static, Javascript did it by requiring that you NAME the variable or function with the class name. Java requires return types on all function and wants to know the type of every argument. Javascript doesn't type check and doesn't need to know that. Javascript REQUIRES the name of the class on every call to a static function, but java is more relaxed. Java sees the word 'flush' and the only thing that it can find IN THIS CLASS with the name 'flush' is that static function so it assumes that that is what it means. The difference is that Java is compiled ONE CLASS AT A TIME so it is always dealing with a smaller name space, Javascript on the other hand will have several classes being defined all at once in a single file, so you MUST use class names whenever you call a static function or when you use a static variable, and to be fair, in Java, if ANY OTHER CLASS wants to call that 'flush' function defined over here in the Chunk class than that other class MUST use the longer name 'Chunk.flush'. ONLY the Chunk class gets to shorten the names a bit. So Java is more bulky because of the keywords 'static' and type names for everything, and Java is leaner because it can leave off class names.

I'm sorry, even I can't handle this lecturing any longer. Can we just get on with writing some code.

Yes, good idea. Let's just back up to the rewrite that I did, that collection of static functions, throw out the old code and paste that in and see if it works. Well, it doesn't. I forgot that I called two functions in my Chunk constructor that I haven't written yet - detectHeader, and asParagraph.

Now these two function are non-static function. They actually work on a Chunk object. detectHeader() looks at the text to see if it is a header and returns the boolean result. asParagraph() is the thing that looks at the chunk an wraps it with paragraph tags. 

In order to make function that are OBJECT function, i.e. non-static function, Javascript used a rather unique notation. They use a field in the constructor function named, 'prototype'. Easiest to just look at the definitions:

  Chunk.prototype.detectHeader = function(){return this.text.indexOf('CHAPTER') >= 0;}
  Chunk.prototype.asParagraph = function(){
    if(this.isHeader){return '<H2>'+this.text+'</H2>';}
    return '<P>'+this.text+'</P>';    
  }  

It looks like an anssignment statement and indeed that's what it is. There is a variable named, 'detectHeader' that is tucked down in the Chunk class in the prototype section and the value that we are assigning to that variable is an anonymous function. If I have a Chunk type object sitting in a variable foo, I can call this object function on foo like this: foo.detectHeader(); - javascript sees that you are calling a function because of the parens, so it goes to the foo variable, looks at the object inside, sees that it is a Chunk type of object so goes to the Chunk class goes to the prototype section, looks up the name, 'detectHeader' finds that function and calls it. When that function is executing there is a LOCAL variable named, 'this' that contains the object that was sitting in foo. That is the way that the guts of the object function can find WHICH Chunk object the object function was called on.

--indexOf()
If you look at what 'detectHeader' does it takes the 'this' object, fetches out its text field and 'looks for' the word 'CHAPTER'. The indexOf function is one of the standard string processing tools of both Java and Javascript. It returns a number telling WHERE it found the word in the string. So if the very first letter in the text is the capital C that starts off the word 'CHAPTER' then it would return 0, the array slot index for the first character. If the text was 'yo CHAPTER 45', it would have returned 3 (there are 3 characters BEFORE the slot named 3). If the word 'CHAPTER' does not occur anywhere in the string, indexOf returns -1 to indicate not found. SO look at the boolean that we are returning. indexOf.. >= 0 is TRUE if it found the word 'CHAPTER'. So detect header return TRUE whenever it sees the word CHAPTER somewhere in the text. 

We are taking a gamble here. IF Herman Melville wrote that word, all caps, somewhere in the middle of a paragraph, then we will detect that and declare the entire prargraph to be a header. I am willing to gamble.

Now let's look at that other object function, asParagraph. If the text in the object was a header, then I wrap it with 'H2' tags, otherwise, I wrap it with 'P' tags. Clearly, headers will be presented as HTML headers and non-headers will come out as HTML paragraphs.

The complete code looks like this:

  window.onload = function(){
    var str = document.getElementById('RAW').innerHTML;
    var cards = str.split('\n');
    //showParagraphs(cards);
    Chunk.createAll(cards); // creates all the Chunks
    Chunk.allParagraphs(); // renders all paragraphs to the screen
  } 
  
  function Chunk(){this.text = Chunk.frag; this.isHeader = this.detectHeader(); Chunk.all.push(this);}
  Chunk.all = [];  // this will be our array of chunks
  Chunk.frag = '';  // this will be our growing chunk fragment
  Chunk.addCard = function (card){if(card.length == 0){Chunk.flush()}else{Chunk.frag += ' ' + card;}}
  Chunk.flush = function (){if(Chunk.frag.length != 0){new Chunk(); Chunk.frag = '';}} // creates and adds to list
  Chunk.createAll = function(cards){
    for(var i = 0; i<cards.length; i++){Chunk.addCard(cards[i]);}
    Chunk.flush(); // convert final frag (if there is one) to chunk.
  }
  Chunk.allParagraphs = function(){
    var str = '';
    for(var i = 0; i<Chunk.all.length; i++){str += Chunk.all[i].asParagraph();}
    inject('TEXT', str);
  }
  Chunk.prototype.detectHeader = function(){return this.text.indexOf('CHAPTER') >= 0;}
  Chunk.prototype.asParagraph = function(){
    if(this.isHeader){return '<h2>'+this.text+'</h2>';}
    return '<p>'+this.text+'</p>';    
  }  

You should see the Chapter Titles brough out as headers.

--title attributes
We are now going to head off in a completely different direction (so that I can show you some other string procession tools and other presentation options). You have certainly seen the feature of 'tooltips', where you hover the mouse over a button and some text pops up near where the mouse is to tell you what you are looking at. I didn't honestly remember the name tooltips when I went to look up how you do this in HTML. I looked up 'hover text', that was close enough. The way that you do that in HTML is you add a title attribute to a span that wraps some text:

  <span title="Dude, here's yer tip">Sweet!</span>
  
Paste that into your document like after the TEXT division. Hover over the text. Sweet!

SO - now what we are going to do is to print out moby dick so that it looks like this:

  h p p p p p p h p p p

each one of those single letters will be a span that you can hover over and the 'h' will be a header and the 'p' will be a paragraph. In this presentation you don't need to scroll, instead you need to hover over the paragraph that you want to read and read in the pop up text. I don't claim that this presentation is USEFUL, we are just playing to see what we can do.

What this means is that instead of writing

  <h2>CHAPTER 1. Loomings</h2>
  
I need to write

  <span title="CHAPTER 1. Loomings">h</span>
  
And as I look at that text that I need to produce I see an immediate problem. If I try to stuff an entire paragraph into a title attribute, I will run into problems whenever that paragraph has and double quotes in it. I will need to ESCAPE the quotes in the paragraph. This means that I need to locate " and replace each one with \"

--replace(regexp, str)
Fortunately there is a string processing command in Javascript that does just that. It works with a regular expression as the first argument and this will be our first regular expression. We will see many more later. In this case the regexp is fairly simple, /"/g, which means, "look for a single quote and globally replace all (instead of just replacing the first one that you find.)".

We will rewrite the single routine, asParagrap, to emit our new form.

  Chunk.prototype.asParagraph = function(){
    var letter = this.isHeader ? 'h' : 'p';
    var qSafe = this.text.replace(/"/g, '\\"'); // note: I need to escape my \ in the replacement string
    return '<span title="'+qSafe+'">'+letter+'</span> ';
  }

Worked first time. Now I can read (barely!) Moby Dick as hover text.

==Regular Expressions
Regular Expressions were developed by a mathematician, a logician, that was working on logical languages. They were basically a compact way of writing "languages". Now what he meant by language was vastly different from you or I think of as language. For his purposes he just wanted to characterize large, possibly infinite collections of words. All he was concerned with was vocabulary words. And his sets of words would look something like this:

  {a, aa, aaa, aaaa, aaaaa, ...}  // all possible strings of one or more a's
  {'', b, bb, bbb, bbbb, ...} // all possible strings of zero or more b's
  {a, aa, ab, aaa, aab, abb, aaaa, aaab, aabb, ...} // all string starting with 1 or more a's followed by zero or more b's

He named the first set a+, the second one b*, the third one a+b*

Plus and Star were operators that acted on the previous letter (or letter set) to create some number of repetitions, plus meant at least one, star meant possibly none.

so consider the normal integers (which can be negative). What is the language for describing all possible strings that we would think of as simple integers? It would be something like this:

 -?(0|[1-9][0-9]*)   // an optional minus sign followed either by a single zero OR a non-zero followed by any digits
 
And that is what regular expressions WERE before the computer people got ahold of them and changed them - they were just a way of very compact way of defining possibly infinite lists of symbols that landed in very simple patterns.

The computer folks decided that this would be a very cool way to search for data. You can write a compact definition that defines what any possible integer looks like, or any legal variable name, both possibly infinite sets and find any string (or substring) that matches that regular expression. So of course, they added features that weren't in the original description, wrote tools that used them, changed the tools, went through revision, built an entire language, PEARL, based on regular expressions, fought over WHICH version of PEARL you ought to use, copied some of the features into some language and not into other. It is the classic old story of language chaos straight from Genesis - the tower of Babel.

Fortunately - you live in a better time. Mostly the world has consolidated, the language for regular expressions has mostly stabalized.

I am not going to teach a course on regular expressions, yet. I will just use them freely from here on and explain each one as I use it. It in NOT the only tool in the string processing toolkit that I am trying to familiarize you with but it is certainly the most powerful and potentially hard to use.  

There is a joke that comes with regular expressions. Goes like this:

One day, you a programmer are faced with a problem involving string manipulation. What do you do? You write a regular expression! And now you have TWO problems. (Meaning that the regular expression that you wrote down probably didn't work leaving you with your original problem unsolved AND a regular expression that does not work the way that you think that it should. Ha Ha!)

==Index
Sure would be nice to have an index for our book, though when you get right down to it, an index as it normally exists is sort of a paper concept. It tells you what page to look on to find a particular word. Page numbers don't really work with text that you can scroll. None the less, it is a familiar concept and we can at least do the important part, namely figuring out all the words that show up in Moby Dick.

We already know that there will be a bunch of words that are very frequent like {a, is, in, of, he, she ...} that are very common and will NOT be in the index. Those are generally called STOP words, and most indexing programs let you supply a list of stop words. We will not quite do that, but what we will do is create a list of words and sort them by frequency so that we can see the most common words. Chances are with just a glance we can run down that list and find the first word that we think in NOT a stop word.

Working from the other direction, there will probably be a lot of words that show up exactly once. There is a good chance that these words would also not belong in a good index, because in some sense, the book is NOT talking about those words.

So our next task is to create a list of all the words in the book and to spew it out the screen so that we can take a look at it.

This is a place where we can use the "Map", or "Associative Array" features of our Javascript arrays. I will create a global array, var index = []; and I will stuff values into it like this: index['Ishmael'] = 0; I will be storing a count of how many times I have seen that word in the index. So the keys to the array are words, and the values in the array are counts.

We still have some other things to deal with, like capitalization. We will do the easiest thing, just capitalize every word as it comes in so that we don't have to deal with 'the' as being different from 'The'. I don't know if there are ANY contractions in Melville but I am inclined to keep something like don't as a single word, rather than break it at the apostrophe into two words 'don' and 't'.

What I am getting at is that we need to define what we mean by a word. I know, you thought that was obvious. Perhaps it is to you and me but we need to tell the computer what to look for and that means a regular expression. So here is a candidate for a regexp that means a word - [a-zA-Z']+

That means, any contiguous substring of one or more lowercase, uppercase, or apostrophe. Of course technically this means that a lone tic all by itself is a word, as is ''a'Z. Again, we take a gamble that Melville didn't write anything like that. More likely, we will have problems if he nested quotes. I mean, I believe that it is correct English punctuation to have a sentence like this: Starbuck said, "You know, Ahab told me, 'I'll get that whale!'" We won't know until we look.

Alternatively, we could instead write the expression for something that is a NOT-WORD. I.e. the document is actually an alternating list of a word then a not-word, then a word then a not-word. The not-words are the separators between the words. One way to build the not-word class is a list of all the characters that don't make up words, something like [.,?!@#$%0-9] but that is a mess and it will need escapes and it would be easy to leave something out. Turns out that regexps allow you to define COMPLIMENTS of sets very easily, you just make ^ (the 'up arrow, hat' symbol) the first in the set. So if our words are [a-zA-A'] then the compliment of that set is [^a-zA-Z']. 

The advantage of using this second set, the not-word set, is that the function split, which we have seen before, that is looking for punctuation that it can use to split the string, can work with a regular expression just as easily as with a character. So we have see pipe separated string split into arrays like this:

  var weekArray = "Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday".split('|');
  
We can replace that splitting string '|' with a regexp. Let's try something and see if it works. Add this single line to the onload function at the very bottom after you have created and rendered all the chunks.

  alert(Chunk.all[1].text.split(/[^a-zA-Z']/));

That seemed to find the words. Let us assume that it will work and write some code to create and show the index.

  var index = [];
  function createIndex(){
    for(var i = 0; i<Chunk.all.length; i++){
      wordsToIndex(Chunk.all[i].text.split(/[^a-zA-Z']/));
    }
  }
 function wordsToIndex(words){
   for(var i=0; i<words.length; i++){
     var w = words[i];
     if(index[w] == null){index[w] = 0;} // if we have never seen this word before create it with count zero
     index[w]++; // .. the word w is now for sure in our index so bump it up.
   }
 }
 function showIndex(){
   var res = ''; var wCount = 0;
   for(var w in index){ // this varient of the for walks through the keys (the words) in the js array
     res += w + ':' + index[w] + ', ';
     wCount++;
   }
   inject('INDEX', res + '<br> Word Count:' + wCount);
 } 
 
You should be able to see that createIndex has a loop that goes though the chunks, splits the chunk.text into an array of words and passes that array onto a wordsToIndex function.

wordsToIndex has a loop that goes through the array, first inserts a new word if necessary into the array, and then updates the count.

showIndex has a loop that goes through the index array - this is a loop variety that you have NOT seen yet, It is used for the non-numeric keys - and we append both the word and the count to the growing result. And once out of the loop we inject the entire result to a place named INDEX. This means of course that we need to introduce a division named INDEX into the body of the document.

  <h1>Index</h1>
  <div id="INDEX"></div>

And of course we must call the createIndex and showIndex at the end of our onload function.

  window.onload = function(){
    var str = document.getElementById('RAW').innerHTML;
    var cards = str.split('\n');
    //showParagraphs(cards);
    Chunk.createAll(cards); // creates all the Chunks
    Chunk.allParagraphs(); // renders all paragraphs to the screen
    //alert(Chunk.all[1].text.split(/[^a-zA-Z']/));
    createIndex();
    showIndex();
  }
  
When we do all that we should see the index of words. You can see that the order of the keys is pretty much the order that we inserted them, Call me Ishmael ...

--sort()
Now we would like to sort the index before we print it out. What we are actually interested in is a sort of the words NOT alphabetically by word, but rather by frequency so that we can see the most common words first.

In order to do that nearly every programming language that supports sorting directly in the language (and javascript is one that does) also has some way to tell the sort function HOW it should do its comparisons. The notion is this: normal sorting of integers would be done by a < b. This puts the smaller integer a before the larger integer b. Normal sorting of strings is practically the same a < b for strings means a is in alphabetical order before b. However if you want to do anything different you need a "comparator" function that will calculate a result, negative if a is less than b, zero if a equals b, and positive if a is greater than b. You hand this function to the sort routine and it will use that as the means of comparing elements in the list that you are sorting. The traditional math expression that sorts integers a and b is (a-b). Note: if a is less than b that expression is negative.

We will give examples both ways, first sorting alphabetically by word, (where you don't need a comparator function), and then ordering by frequency.

 function indexKeys(){ // creates an array consisting of the keys that are in the index, i.e. a list of words
   var res = [];
   for(var w in index){res.push(w);}
   return res; 
 }
 function showIndex(){
   var keys = indexKeys();
   keys.sort() // sort words alphabetically
   var res = ''; var wCount = 0;
   for(var i = 0; i<keys.length; i++){ // this varient of the for walks through the keys (the words) in the js array
     res += keys[i] + ':' + index[keys[i]] + ', '; // glue the word to it count
     wCount++;
   }
   inject('INDEX', res + '<br> Word Count:' + wCount);
 } 
 
The function, indexKeys, creates and array that is nothing but the words that are keys in that index array. That will give us a list that we can sort however we like.

Then we modify showIndex to call that indexKeys function, sort it, and now our loop goes through that sorted list of keys, and fetches numbers out of the index to create our final message that we can inject.

Run that and see that it alphabetically sorts the index.

Next we modify that call to sort() in showIndex so that we can pass it a comparator function

  keys.sort(function(a,b){return index[b]-index[a];}) // sort by the difference between the counts in the index

That comparator is passed two words, a and b, and it orders them numbercally (in descending order) by useing the value in the index.

Run it again and see the list of the most frequent words in the index. As expected, the most common words are the very frequent words like The, the, of, a, he, etc.

Humm.. we never fixed corrected for different capitalization. We should do that BEFORE we stuff the words into the index array. The easiest thing is to re-render the word into all uppercase before we stuff it to the index. Replace the one line in the addWordsToIndex function

  var w = words[i].toUpperCase();

At this point I am ready to look at the entire text of Moby Dick so I copy the whole thing, paste it into my script section and re-run it.  The entire text of Moby Dick fits on one page ... well, it does when we hide each paragraph under a single letter. Nice!

Before we leave the topic of sorting, let me show you another sort. 

I had the notion that short words tend to be common words, an interesting word like HARPOONERS, would be both long and frequent. So if I want to boost interesting words to the front of the list instead of just comparing frequency of words, I could compare the frequency multiplied by the length of the word.

  keys.sort(function(a,b){return index[b]*b.length-index[a]*a.length;})
  
This sort boosted the word WHALE up to slot 11 (the first 10 were the usual suspects, THE, AND, OF, THAT, TO ...), and it took the words that only showed up once and put the shortest of those, the one letter words at the back. There were a bunch that I didn't like. X, N, Y, S, T

--Problems
However as I look at that list I see some problems. I am seeing S and T as frequently occuring words. I don't believe it. Those look suspiciously like what I would get if AHAB'S was split at an apostrophe and DON'T also got split. So I go search the text for ' and don't find it. Looking carefully at the text, I see that some fool has NOT used straight up and down as GOD intended apostrophes in this text but has instead used angled tick marks and also angled quote marks. EVIL!

So yes, my regular expression was wrong. It was [^a-zA-Z'] and what it needs to be for this text is [^a-zA-Z’]. Sadly the world has NOT standardized on orthography. This is a fact of word processing. You need to look at the mess of data that you were given and deal with that. If you scrape random texts from Project Gutenberg, some will be done one way others will be a different way. This makes it hard to write generic code that will deal with any text you hand it. Some books will spell chapter all Caps, some not, some won't spell it out, some will use Roman Numerals (as if that empire had not DIED out THOUSANDS of years ago!) EVIL! Oh well that is the nature of ART! viva la différence!

Fixing the bad apostrophe fixed the S and the T but not the other solo characters.So what was causing the solitary Y? Where was that? I didn't want to just search my text for Y because that would clearly not locate the Y that was a stand alone so I hacked up the code to show me where it was.

  function createIndex(){
    for(var i = 0; i<Chunk.all.length; i++){
      var ch = Chunk.all[i];
      wordsToIndex(ch.text.split(/[^a-zA-Z’]/), ch); // modified to pass the chunk 
    }
  }
  function wordsToIndex(words, ch){ // modified to accept a chunk so that it can alert it out.
   for(var i=0; i<words.length; i++){
     var w = words[i].toUpperCase();
     if(w == 'Y'){alert(ch.text);} // show me the entire paragraph that has a solo y
     if(index[w] == null){index[w] = 0;} // if we have never seen this word before create it with count zero
     index[w]++; // .. the word w is now for sure in our index so bump it up.
   }
 }

That code instantly locates a section where Melville has the text

  Star-bo-l-e-e-n, a-h-o-y! Eight bells

Ah ha, there were some solitary characters right there where he was doing arty stuff with dashes. And some of the other things that seemed strange (like not dictionary words) I tracked down in the same way to places where he was doing accents.  

==Summary

We have showed you that you can use a script tag to load up a bunch of text, you can use string.split(sep) to create an array of substrings separated by sep. (And that sep can either be a string of characters OR as we saw later it could actually be a Regular Expression). We used the function toUpperCase() to modify the case of a string. 

We introduced the notions of Classes and Objects, and in this project we had a single Class, Chunk which in some sense represented a paragraph of the original text.

We used an associative array to act as a Map - a collection of key/value pairs where the keys were Strings and the values were integers. We used a regular expression to split each paragraph into words and used that Index Map to create to count how often each individual word showed up in the book. We saw code to extract the keys from a Map and saw how we could build comparators to sort that index into different orders.

Equally importantly what we have NOT done is anything useful with all of that index data that we looked at. Yes, we saw that it put the most frequent boring words at the top of the list, words that we would consider to be stop words for a real printed index BUT we are not living in the printed world any more. It does me no good to give you a list of page numbers when what you have is a long chunk of scrolling text. So that will be our next project - to continue hacking on Moby Dick but to do something more interesting with our index, like to put in a search field and to consider alternatives for presentation of the results of the search.

I would recommend a break at this point for the simple reason that I took a break at this point. When came back to the code I had written previously, I made one change, which necessitated a couple others and pretty soon I ended up rewriting much of the previous code. So take a break, and come back when you are ready to toss a lot of what we just did and do a rewrite.
::S Search
==Search
The alternative to indexing that is common in online documents is essentially search. You type in what you are looking for and the system shows you places (by highlighting or other means) where to find it.

This means that we will need to have a text box on the screen and will need to learn how to use javascript to scrape the text out of a text box and how to notice that the text in the search box has changed.

==Textbox
The minimal HTML for a text box (with a text lable in front) looks like this:
  Search: <INPUT type="text"/><BR>

Since you might actually want to find this on the page we will probably add some other attributes like an id and an onchange.

  Search: <INPUT id="SEARCH" type="text" onchange="doSearch();"/><BR>

So that will need to get stuffed way down in the body of the HTML file and we will need to implement a doSearch function up in the javascript section to test if this INPUT does the right thing. The important thing to know is that an INPUT box has a field named 'value' and that is what holds the string that is currently sitting in the text box.

  function doSearch(){var w = document.getElementById('SEARCH').value; alert(w);}  

Well, that didn't work! Apparently the 'onchange' event only happens if you click on the box, enter some text and then click somewhere else. It is on 'losing the focus' that the box notices that it has changed. I want to know every time the user types in a new character. I think there might be an onkeyup event. Ah yes, that is much better. edit 'onchange' into 'onkeyup'. Now every time I type in a key I get an alert, and the text is right. 

Just for grins change it to 'onkeydown' to see what that does. When you do that - the alert shows the wrong text. The difference is WHEN the event happens. keydown is the moment that the key is pressed. When that happens the actual character that the key represented has not yet been written into the box. The key up events happens at the moment that the user lifts up their finger and the key is going up. At that point the input box has already been updated, so 'onkeyup' is the event that we actually want.

So now that I have a function, doSearch that will run when I want, and I know that I can fetch out the value in the box, what do I want to do with that.

My first notion is to trim that long list of ALL the words and shorten it to only the words that start with the same letters in the box.

==Word objects
I will do that, but first, before I get to much further, I want to move my words up into a class Word. Yeah, I know, I should have done that before I started. EVERYTHING is easier if you work with classes. So why am I doing it WRONG first and then backing up and CHANGING everything and fixing it? Because I want you to learn to write code, and that includes noticing that you did something wrong and backing up and fixing it, and yes, I promise after we have seen objects and classes just a few more times, I will start writing my projects with classes right from the beginning.

Why do I want to change to Objects? Well, when we started, I just had a list of words, they were just strings. Strings are simple. I wanted to count them - fine I can just use my strings a keys to an associative array and keep a count there. But now when the user starts searching those words, and I show a list of words, I can just tell that the next thing I am going to want to do is to when the user clicks on the word ABIDE which shows up 3 times, I am going to want to know which 3 paragraphs that word shows up in, so that I can highlight them. And I start thinking that there might be lots of information that I want to connect to a single word. Well having lots of information means that I need some structure to hold the information connected to a single word, and boy doesn't that sound like an object in a class. So I am thinking that I should have been constructing Word objects when I started building my index. 

So I am thinking a Word should look lsort of ike this:

  function Word(str){this.text = str; this.count = 0; this.chunks = []; 
    this.ndx = Word.all.length; Word.all.push(this); // note: ndx is the index of this word in the list Word.all
  }                                                  // .. ndx will let me get from a single number to a Word
  Word.all = []; // all the Words in a list

Well, when I start thinking about a major change like this I think I will actually go through the whole system and modify just about everything, moving things around and renaming them if necessary.

Since this is a change to almost everything, I will document what I did in this manner. First I will show you the entire file as it is finally rewritten. Then I will talk about each chunk of code and comment on what I changed and why.

--all the js code
  function inject(loc,val){document.getElementById(loc).innerHTML = val;}
  
  window.onload = function(){
    var str = document.getElementById('RAW').innerHTML;
    var cards = str.split('\n');
    Chunk.createAll(cards); // creates all the Chunks
    Chunk.showAll(); // renders all paragraphs to the screen
    Word.showAll();
  } 
  
  var index = []; var uniqueWords = []; // the unique words are the keys to the index Map
  
  function doSearch(){var w = document.getElementById('SEARCH').value; alert(w);} 
  
  function Chunk(){this.text = Chunk.frag; this.isHeader = this.detectHeader(); Chunk.all.push(this); this.index();}
  Chunk.all = [];  // this will be our array of chunks
  Chunk.frag = '';  // this will be our growing chunk fragment
  Chunk.addCard = function (card){if(card.length == 0){Chunk.flush()}else{Chunk.frag += ' ' + card;}}
  Chunk.flush = function (){if(Chunk.frag.length != 0){new Chunk(); Chunk.frag = '';}} // creates and adds to list
  Chunk.createAll = function(cards){
    for(var i = 0; i<cards.length; i++){Chunk.addCard(cards[i]);}
    Chunk.flush(); // convert final frag (if there is one) to chunk.
  }
  Chunk.showAll = function(){
    var str = '';
    for(var i = 0; i<Chunk.all.length; i++){str += Chunk.all[i].htm();}
    inject('TEXT', str);
  }
  Chunk.prototype.detectHeader = function(){return this.text.indexOf('CHAPTER') >= 0;}
   
  Chunk.prototype.htm = function(){
    var letter = this.isHeader ? 'h' : 'p';
    var qSafe = this.text.replace(/"/g, '\\"');
    var res = '<span title="'+qSafe+'">'+letter+'</span> ';
    //alert(res);
    return res;
  }
  Chunk.prototype.index = function(){wordsToIndex(this.text.split(/[^a-zA-Z’]/), this);}
    
  function Word(str){this.text = str; this.count = 0; this.chunks = [];
    this.ndx = Word.all.length; Word.all.push(this); // note: ndx is the index of this word in the list Word.all
  }                                                  // .. ndx will let me get from a single number to a Word
  Word.all = []; // all the Words in a list
  
  Word.prototype.incCount = function(){this.count++;}
  Word.prototype.addChunk = function(ch){if(this.chunks.indexOf(ch) < 0){this.chunks.push(ch);}}
  Word.prototype.htm = function(){return this.text + ':' + this.count;}
  
  Word.showAll = function(){
    var res = '';
    uniqueWords.sort();
    for(var i = 0; i<uniqueWords.length; i++){res += index[uniqueWords[i]].htm() + ', ';}
    inject('INDEX', res);
  }
  
  function wordsToIndex(words, ch){
    for(var i=0; i<words.length; i++){
      var w = words[i].toUpperCase();
      if(w != ''){
        if(index[w] == null){index[w] = new Word(w); uniqueWords.push(w);} // first time seen, create new
        index[w].incCount(); // .. now that we know it exists we count it ..
        index[w].addChunk(ch); // .. and mark it as containing this chunk.
      }
    }
  }

-- the changes
inject() remains the same as always

I renamed several of the function that were called by the onload routine. I changed things like Chunk.showParagrapsh to showAll for symetry with Word.showAll that shows all the words in the index. I also realized that I could throw out the routine, createIndex. Instead I realized that I could add an index function to each chunk object with the result being that at the same moment that I create a new chunk, I can index that chunk. This saves me from writing a function that goes through the chunks one at a time. Indexing just happens as we work through the cards creating the chunks. 
 
I 'boosted' the index variable (which is the Map) to the top, and I added a new variable, uniqueWords. This let me throw out the routine that iterated through the keys of the index to collect them all into a list that we could sort. I realized that at the moment that I see a word for the first time and add it to the index as a key, I could also add that word to a list of key words, the uniqueWords array.

I renamed the asParagraph() function in Chunk to be htm(). I like the shorter name and often use that name in projects. Whenever I have an object that will ultimately have some way of being written out to the screen, I name the function that produces the html that I need to inject, htm().

I wrote the index function for a single chunk object.
  Chunk.prototype.index = function(){wordsToIndex(this.text.split(/[^a-zA-Z’]/), this);}
  
and I eliminated the loop to go through the chunks by adding the single command
  this.index();
  
into the Chunk constructor. Thus, constructing a Chunk automatically indexes it.

I added the constructor for Word objects and added three functions for manipulating a single word object

  Word.prototype.incCount = function(){this.count++;}
  Word.prototype.addChunk = function(ch){if(this.chunks.indexOf(ch) < 0){this.chunks.push(ch);}}
  Word.prototype.htm = function(){return this.text + ':' + this.count;}
  
The first, incCount, is used just to increment the count. The second, addChunk, does a GUARDED addition of a chunk to the list of chunks that contain the word. The guarding was done because I don't want the word THE which shows up many times in one single paragraph to list that chunk more than once. So when I am adding a chunk to the chunks list of a word, I first look to see that that chunk is NOT already on the list. The last is just the htm() function for a single word, showing the text of the word and the count.

I rewrote the routine, showAll, to show the index, mostly because I renamed nearly every function in the old one. You can see I am now using that uniqueWords list rather than calling a routine to create that list by collecting the keys from the index.

  Word.showAll = function(){
    var res = '';
    uniqueWords.sort();
    for(var i = 0; i<uniqueWords.length; i++){res += index[uniqueWords[i]].htm() + ', ';}
    inject('INDEX', res);
  }

With all those changes, when you run the program it does pretty much what it did previously.

==Concordance

I do not really want to produce a full concordance for Moby Dick, but since I am showing you how to do some text processing and a concordance is not that difficult, I will do some of it to show you the basic idea. 

A concordance allows me to take a single word like Ishmael, (which shows up 19 times in the text) and show you a single line of text that has that word roughly in the middle, i.e. it shows the context for each of those occurances.

  Call me Ishmael. Some years ago—never mind
  “WHALING VOYAGE BY ONE ISHMAEL. “BLOODY BATTLE IN AFFGHANISTAN.”
  wherever you go, Ishmael, said I to myself,
  lodge for the night, my dear Ishmael, be sure to
  ...

What I am going to do is limit myself to showing just ONE line having the word, not all the lines, AND I am going to use the same trick that we did with the paragraphs, of placing the concordance line as a title attribute of the index word, so that way, I can hover over the word, ISHMAEL, and see that first concordance line.

And just for the record, this will let me TEST if I have done at least some of the work right in creating the chunks list connected to each word. (We haven't tested that those lists are being created correctly - we will use that list to find the FIRST chunk that contains a word and use that text of that chunk to create a concordance line and if we did not do the chunks right, that would break the concordance code.)

Since the only OUTPUT is to add a title attribute to the html that represents a single Word, we will need to modify the htm() for a Word

  Word.prototype.htm = function(){return this.concordance() + ':' + this.count;}
  Word.prototype.concordance = function(){
    var ch = this.chunks[0]; // grab the first chunk from the list contained in the Word
    var loc = ch.text.toUpperCase().indexOf(this.text); // looks up the location of Word's text in the chunk.text
    var low = loc - 30; // 30 characters before the word starts
    if(low < 0){low = 0;}
    var len = 70; if(low + len > ch.text.length){len = ch.text.length - low;}
    var title = ch.text.substring(low, low+len); // fetch out the substring containing the word
    return '<span title="'+title+'">'+this.text+'</span>';
  } 
 
In the concordance routine I use indexOf to locate the place that the first occurrence of the word shows up in the paragraph (and yes, you may get problems if you look at the concordance for the word A because it just finds the first A possibly in the middle of a word in the first paragraph that legitimately had the word A). Once you know the location you back up by a few characters, I chose to back up by 30 characters. I then want to pluck out the substring that starts 30 characters below the target word and runs for 70 characters total. Now the substring function works from a low address to a high address and both of them need to fit in the length of the substring so the guards are there to force low to be at least zero and to force the length of the substring, len, to not cause low+len to exceed the last slot in the string. Once you have extracted the substring you just stuff it into the title of a span and return it.

With that little modification you can now look at those index words in context. Here are some that you might look at, A, IN, and ON all fail (showing up in the middle of words). CALL is interesting to show that when the first occurrence is the first word of a paragraph, the rounding up to zero for the lowest low is in fact working. QUEEN'S was interesting to me for the sole reason that the word count is 2, and both of them show up in the single concordance line for the first occurrence. Look up STARBUCK, AHAB, QUEEQUEG (which is of course how I stumbled on QUEEN'S) just so you can see context for first occurrence of some of the main characters.

You should start to notice that it is taking a bit longer to do the calculations (about 2 seconds on my machine). For one thing, when I look for each word, I must first first capitalize the entire paragraph because my words are all capitalized, so a paragraph with 100 words, I am capitalizing the paragraph 100 times, once for each word. Also the 17,000 words now all have a title that is about 70 characters long so we have about a million characters of text just in the index portion alone, not to mention the million or so characters that show up in the text itself.

Basically the code that I am writing is very inefficient. I could of course speed this up by breaking out my code differently, but I try to NOT worry about speed until the entire thing is built - the reason is fairly obvious, we don't really know what exactly we are going to do yet and thus we may end up rewriting and reorganizing several times still during our development. So what we want to do is minimize the amount of code we have to write and rewrite, and ONLY when we are finally sure that our code does what we want do we worry about mundane things like speed. (Well actually there is one other time that we worry about speed. If that last change made the system so slow that it was taking us minutes to reload and test instead of 2 seconds, we would look at speeding it up so that we get good turn around time on all our test runs.)

--Back to Search
Sorry for that little trip though concordances, let us get back to looking at search. We have created a search box that they user can type into, and we can detect whenever the user has changed the text in the box. What we want do actually do when the text changes is to redisplay the index using the text in the search box as a filter.

If you are not familiar with the term 'filter' as it is used in programming, it is the process of going though a list and producing a shorter list by essentially checking each element on the big list to see if it 'passes' through the filter. Thus a filter in a programming standpoint is a boolean function that looks at a single element from a list and returns a boolean, true it passes, false it rejects.

In this particular case our filter will just check if the Word.text starts with the text (converted to upper case) that is in the search box.
  
  var searchUC; // we will keep the current value of Search box in uppercase to speed searches
  function filter(word){return word.text.indexOf(searchUC) == 0;}
  function doSearch(){
    searchUC = document.getElementById('SEARCH').value.toUpperCase(); // set up the value needed by the filter
    Word.showAll(); // show the filtered words.
  }
  
And we must rewrite Word.showAll to now respect the filter that we just created.

  Word.showAll = function(){
    var res = '';
    uniqueWords.sort();
    for(var i = 0; i<uniqueWords.length; i++){
      var w = index[uniqueWords[i]]; // fetch the Word object corresponding to the uniqueWord string
      if(filter(w)){res += w.htm() + ', ';} // only include one's that pass the filter
    }
    if(res == ''){res = 'nothing passed the current filter!'}
    inject('INDEX', res);
  }

So I ran that code and it worked fine (well it worked fine after I reset the search box to call doSearch on the 'onkeyup' event instead of the 'onkeydown' that I had it set to when I was checking out the different events.)

The one thing that I didn't like was that when you first boot up, the search box is empty and thus nothing passes the filter. I would like EVERYTHING to pass the filter when the search string is null so I will fix the filter code.

  function filter(word){return (searchUC != '')? word.text.indexOf(searchUC) == 0 : true;}
  
That's more like it.

So I look up 'WH' so I can see all the varients for Whale and sho nuff there's quite a few. whale, whaleboat, whalebone, etc. The ones that I found interesting are WHALEMAN'S and WHALEMEN'S. When I look at the concordances I see that there is a "Whaleman's Chapel" in New Bedford and when I look at the word WHALEMEN'S the concordance shows a whalemen's chapel. So which one is it, actually? Is the formal name singlar and yet the latter reference is pluralized to be inclusive, "you know that chapel for the whalemen," or did Melville just WISH that he had had a computer with Javascript available so that he could do a better job of proofing reading his Novel. I don't suppose that we will know.

==Color
You know, I am getting tired of all that black and white text. Are we limited to black and white because black ink is cheap and colored printing is expensive? NO WE ARE NOT! We are on a computer. Color is FREE! Well, almost, you do have to write some code to insert color. 

Where shall we add some color? How about we color the words that have a very high frequency one color, and the infrequent another color and the ones in the middle can stay black.

This will be a change to the htm for a word. It will now be in a span that sets the color if the count is in a particular range. I started to write the color spans in place but as soon as I started typeing the second one I realized that I needed a helper function so I wrote color to wrap some text in a color span.

  function color(str, color){return '<span style="color:'+color+';">'+str+'</span>';}
  
  Word.prototype.htm = function(){
    var res = this.concordance() + ':' + this.count;
    if(this.count > 300){return color(res, 'red');}
    if(this.count < 4){return color(res, 'gray');}
    return res;
  }
  
And just for the record, since that color function is VERY generic I moved it up to the very top of the JS right after inject().

I decided to color the very frequent words in red and the uncommon ones in gray so that the potential 'stop' words would pop out. 

Upon scrolling and looking through all the words, the only red ones that struck me a topic specific were, AHAB, CAPTAIN, SEA, SHIP, TIME, WHALE. And I could go either way on TIME. The other red ones, HE, SHE, IT, UPON, WHICH, THAT etc. were genuinely uninterseting words. Technically what we have created here is something that is known as a 'Bag of Words'. A 'set' of words is just an unorderd collection of words that are either in the set or not in the set. A 'bag' on the otherhand, is like a set except that you have a frequecy count for each element in the set.

In a very vague sense, those words that were NOT genuine boring English stop words, like CAPTAIN, AHAB, SEA, SHIP, WHALE are what the book was about. The boring words showed up with a frequency that is in line with any other randomly chosen English text, but those words like SHIP, certainly a common English word, showed up with a frequency that was FAR FAR beyond the rate that it normally shows up in some randomly selected English text. That unlikely circumstance is telling us that this text has something to do with ships and captains and whales.

When computers are doing linguistic processing, trying to find out what a text is about, (in particular, trying to determine if this chunk of text is genuine email that you would like to read or should be filtered out as spam) they use the concept of a 'Baysian bag of words'. The word 'Baysian' refers to probability statistics, not just the count of the words in the bag but the LIKELYHOOD that you would see that word in a randomly choosen text. In a Baysian bag of words, those words like THE which have a high frequency also have a very high likelyhood, they represent NO SURPRISE what so ever. And as a result they vanish. However words like VIAGRA, FREE, SEX, NUDE etc have a low corrolation with random text and a high corrolation with SPAM. What we are doing here, looking at word frequencies in a large chunk of text, is very similar to what one does in building spam filters.

So now that we are having fun, let's throw in another color. Theres quite a range between 4 and 300. Lets look at the mass words that are over 200 and see how boring they are.

  if(this.count > 200){return color(res, 'orange');} // add this AFTER the >300 line

When I do that and just look at the orange words I pick up only a few that are clearly 'Moby Dick' words, BOAT, QUEEQUEG, SPERM, STUBB, WHALES. Since those cut off numbers were completely arbitrary I am going to shift them down a bit. I will move the red limit down to 200 (cutting off STARBUCK who is sitting at 178) and move the orange down to 50.

Upon doing that the orange words are more interesting. There are many that are boring English words: ABOVE, AGAINST, ALMOST, ALSO and yet there are many that we recognize as topic specific: AYE, CABIN, COOK, CRAFT, CREW, DECK, DICK, DEEP, HARPOON, LEVIATHAN.

When I saw that word, DICK, I started thinking about the characters: AHAB, STUBB, STARBUCK, QUEEQUEG, which one was named DICK? OH YEAH, MOBY DICK! DUH!

==Click Text
Well I have just spotted a problem that I had not noticed before. I was looking at the hover text for the very last paragraph and realized that it stopped early. I looked closely at some other. Same thing. It appears that there is a text size limit to the title text that you pop up on the screen. This is not really much of a surprise since there is only so much real estate that you can use in a pop up window.

So it is time we do something with all those little p paragraphs and h headings. What I think I will do is leave the p's and h's on the screen, as is, BUT I will make each one clickable. The Chunks will get a new field, visible, and clicking on the p or the h will toggle the visibility field for the chunk. We will then put a new division, between the GlobalMap (that's what the p's and h's are; an over all map of the book) and the Index. That division will hold the visible text of the book.

Adding a visibility field to Chunks means changing the chunk constructor.

  function Chunk(){
    this.text = Chunk.frag; this.isHeader = this.detectHeader(); this.visible = false;
    this.ndx = Chunk.all.length; Chunk.all.push(this); // also add ndx field 
    this.index();
  }

I added the visible field and I also added an ndx field (prounounced 'index': it remembers the slot number for where this particular chunk has been pushed onto the Chunk.all list. You will see in just a moment why that is a useful thing to remember.
  
We add a function to toggle the visibility field:

  Chunk.prototype.togVis = function(){this.visible = !this.visible;}
  
Next I modify the htm() for the chunk (which is creating the letter p or h) to add an 'onclick' event to the single letter AND also to false color that letter so that I can see up in the map whether that letter is turned on or not.

  Chunk.prototype.htm = function(){
    var letter = this.isHeader ? 'h' : 'p';
    var col = ' style="color:'+(this.visible ? 'red':'black')+';"'; // the color attribute
    var oc = ' onclick="tv('+this.ndx+');"'; // the on click attribute
    var qSafe = this.text.replace(/"/g, '\\"');
    var tit = ' title="'+qSafe+'" '; // the title attribute for creating hover text
    var res = '<span'+tit + col + oc +'>'+letter+'</span> ';
    return res;
  }
  
If you look closely at the onclick routine I am calling a function, tv(ndx), that I haven't written yet. This was the reason that I wanted the chunk to know its number in the Chunk.all list. It was so I could write that number out into an attribute. (I can't write a Chunk object out into an attribute - yet I need that chunk in the onclick routine so that I can call its togVis() function. So instead I pass a number, a slot number, of where to find that Chunk object on the Chunk.all list. So tv looks like this:

  function tv(ndx){Chunk.all[ndx].togVis(); Chunk.showAll();}
 
I add a division to show the actual book text. I decided it put it up above the GlobalMap

  <div id="VIS"></div>

And that reminds me that I never did put anything in to write the actual text into that division. When I write a text chunk out I will need to wrap it with either a heading or a paragraph tag. 

At this point my htm function become a little inadequate. I mean, the function is fine the way it is, it is just the name that is a little wrong. There is no longer one single chunk of html text being written into one single division to display that chunk. I have one little piece of html that is being used to create a p or h that I can click on, and I have another one that is the paragraph or h1 that is being written into the VIS division.

I know, I should think up two new names right now, but that is just TOO HARD. I will use the name h1OrP as a new function name to just hand me back the text of a chunk properly wrapped and I will call that in Chunk.showAll();

  Chunk.showAll = function(){
    var mapStr = ''; var textStr = ''
    for(var i = 0; i<Chunk.all.length; i++){
      mapStr += Chunk.all[i].htm();
      if(this.visible){textStr += this.h1OrP();}
    }
    inject('TEXT', mapStr);
    inject('VIS', textStr);
  }
  
The h1OrP function looks like this:

  Chunk.prototype.h1OrP = function(){
    return this.isHeader ? '<h1>'+this.text+'</h1>' : '<p>'+this.text+'</p>';
  }

With those changes, you can now open and close individual paragraphs and headings as you choose.

==More Text Clicking
Since we now have a way to make paragraphs visible. We can finally used the index in the way that you might expect it to work. When you click on the word ADRIFT in the index, it will toggle the visibility of all the chunks on its list.

I though at first that what I wanted to do was to first run the list of all Chunks, turning off all that were currently turned on, and then running the chunk list in the Word turning them on. i.e. it would clear out the trash before it showed you exactly what you wanted.

Then I thought about the trouble that you could get yourself into, if you clicked on the word A. You would get nearly every paragraph turn on. Turning them off would be a pain. So I decided that it would be better to just toggle the visibility. You can click A to turn them all on and click it again to turn them all off.

Once again, the primary thing that you need to do is to add an onclick routing to the spans wrapping the index words.
  function togWord(ndx){
    var w = Word.all[ndx]; 
    for(var i=0;i<w.chunks.length;i++){w.chunks[i].togVis();} 
    Chunk.showAll();
  }
  Word.prototype.htm = function(){
    var oc = ' onclick="togWord('+this.ndx+');"';
    var res = '<span'+oc+'>' + this.concordance() + '</span>:' + this.count;
    if(this.count > 200){return color(res, 'red');}
    if(this.count > 50){return color(res, 'orange');} 
    if(this.count < 4){return color(res, 'gray');}
    return res;
  }
  
We try that out and now clicking on a word opens up all the relevant passanges.

==Text Highlighting
Next I want to modify our paragraph presentation. Instead of just showing the text, I am going to emphasize the words that are the singltons, the words that Melville used but a single time in the entire work. We will just italicize those words. In order to do this, I need to go through the text, find every word (using the same definition of word that we used before), look it up to see its count and to wrap it with italic tags.

So how do we do that? I don't think a single replace function will work because we need to make decisions based on what word we found that we are replacing. We could write a loop that finds each word in turn and wraps it so "Call me Ishmael" becomes first "LT;i&GT;Call&LT;/i&GT;", then we replace the second word etc. In order to do this we must modify our definition of what constitutes a word so that we skip over words that we have already wrapped in i tags and the i in the i tag itself must NOT look like a word. That sounds kind of messy. 

Here is another idea: the text essentially toggles back and forth between letters that are considered to be parts of words and those that are NOT. We could just loop though every character in the string one at a time and every time we switch our state from non-word char to word-char we drop in a start tag for italic...Nope, that won't work we don't know if the word we are starting is one that we should be wrapping...

Humm.. when in doubt look up the documentation. Let us see if there is some way to do this with the replace function.

I look at the javascript replace regex on the W3 schools site and towards the bottom they give an example where instead of replacing some text that matched the expression with more text, you can replace it with a function. Excellent, just what we need. The function can look up the word that we are replacing and wrap it if necessary.

Let us try this:

  function wrapParagraph(str){
    var res = str.replace(/[a-zA-Z’]+/g, function(x){return (index[x.toUpperCase()].count == 1) ? '<i>'+x+'</i>' : x;});
    return res;
  }

we need to call that function, on the chunk.text that we are assembling in h1OrP BEFORE we wrap in the the h1 or p tags (because we don't want to treat that h or p as a word in the doucument).

  Chunk.prototype.h1OrP = function(){
    if(this.isHeader){return '<h1>'+this.text+'</h1>';}
    return '<p>'+wrapParagraph(this.text)+'</p>';
  }

To be honest, I forgot the toUppercase() in the expression index[x.toUpperCase()] in the replace functions. oops! index is based on uppercase characters so it was not finding actual words. It took so work with the debugger to find my mistake, but once found it was easily fixed.

Now that you can look at the italicized characters, you can think of them as <i>spice</i>. They are NOT the important words in Moby Dick, they are the unusual words that add flavor. "<i>Circumambulate</i> the city of a dreamy Sabbath afternoon." 

When you look at the 17,000 words in the index, you see that MOST of them are used only once. It gives you the impression that the whole book is made up of infrequently used words. It is so easy to forget that those bright red words like A are used 4600 times. So when you look at text where the singular words are highlighted their density is low, they do NOT in fact dominate, they are more like !ispice, they just add !iflavoring. Take a look at the 5th paragraph for example. A whole paragraph with exactly one unique word in it.

--Highlighting the clicked index word

When we made it possible to click on a single index word and open up several paragraphs all at once, I noticed that it is hard to see WHERE the word lies in the paragraphs that opened up. So now we will located an highlight the clicked on word.

This is relatively simple, but not trivial. The trivial thing to do is to just capture the word that was clicked on as a string, and then replace that string where ever you find it in visible paragraphs with a span that recolors it. 

The only problem with that is the word I. The problem with I is, that we have already littered the paragraph text with a bunch of I tags to italicize the singular words. If you try to then color the word I, you would muck up ALL your italic tags. And if you think we can just do this replacement BEFORE we muck it all up with the italic tags, you will find that the SPAN that you dropped in to color the highlighted word will now interfere with looking up words like A or AN or SPAN that need to be italicized. 

Well, in the interests of seeing how this is going to look/work, I am just going to do the expedient thing of blocking the word I. If the user tries to locate all the paragraphs with the letter I in them, it won't work, which is marginally better than having the system freeze up and stop working because we broke our tags.

So here is a global variable to store our current highlight, and a routine to load it with a string (which will block the value I). Also you will see that in the interests of visibility, I have added a new heading to our document that will show the current value of what we are highlighting.

  var highLight = ''; // set by clicking on a Word in the index
  function setHighLight(str){
    highLight = (str == highLight || str == 'I') ? '' : str; 
    inject("HIGHLIGHT", ((highLight=='') ? '' : 'Highlighting: ' + highLight));
  }
  
I added this heading right after the big Moby Dick at the front of the document

  <h3 id="HIGHLIGHT" style="color:orange"></h3>
  
Next we make sure that togVis, which was the onclick routine for a Word that we just wrote calls the setHighlight function

  function togWord(ndx){ // sets highLight and toggles visibility on this Word's chunks
    var w = Word.all[ndx]; 
    setHighLight(w.text);
    for(var i=0;i<w.chunks.length;i++){w.chunks[i].togVis();} 
    Chunk.showAll();
  }

And finally we rewrite our h1OrP function to do a replacement right after we have italicized everything. I did something in the replace that you have not see before. Normally when I shove a regexp into a replace, I define it with slashes like /foo/ this means look for the string "foo" and replace the first one (and only the first one that you find). I can use an expression like /foo/g with a 'g' at the end which means do the replace 'globally', continuing on after you found the first one. I can also add an 'i' tag at the end, /foo/gi which means do the replacement globally AND be 'insensitive' to case. This will allow me to look for /WHALE/gi  and match 'whale' and also match 'Whale' or any other combination of upper and lower case.

My trouble is that I DON'T have a constant string of characters that I can write into my code where I am doing the replace call. Instead I have a string value stuffed into a variable named highLight. I want to append the 'gi' characters to the end of that string if I make it into a regular expression. Well the way that you make this into a regular expression is to know that regular expressions are actually objects and they have a constructor. Those slashes are just cute syntax to make it easier to construct a regexp from a constant. To turn our highLight variable into a regexp we use - new RegExp(highLight, 'gi')
  
  Chunk.prototype.h1OrP = function(){
    if(this.isHeader){return '<h1>'+this.text+'</h1>';}
    var ip = wrapParagraph(this.text); // paragraph now polluted with I tags
    var hip = ip;  // highlighted pargraph
    if(highLight != ''){hip = ip.replace(new RegExp(highLight,'gi'), function(x){return color(x, 'red');})}
    return '<p>'+hip+'</p>';
  }

With these additions we can now spot the highlighted words much quicker.

That should be sufficient play with Moby Dick for now. Just to be sure that you got all the code in correctly I will do a dump now of all the javascript and after that a project summary.

--Moby Dick javascript
  function inject(loc,val){document.getElementById(loc).innerHTML = val;}
  function color(str, color){return '<span style="color:'+color+';">'+str+'</span>';}

  window.onload = function(){
    var str = document.getElementById('RAW').innerHTML;
    var cards = str.split('\n');
    Chunk.createAll(cards); // creates all the Chunks
    Chunk.showAll(); // renders all paragraphs to the screen
    Word.showAll();
  } 

  var index = []; var uniqueWords = []; // the unique words are the keys to the index Map
  
  var searchUC; // we will keep the current value of Search box in uppercase to speed searches
  function filter(word){return word.text.indexOf(searchUC) == 0;}
  function doSearch(){
    searchUC = document.getElementById('SEARCH').value.toUpperCase(); // set up the value needed by the filter
    Word.showAll(); // show the filtered words.
  }

  function Chunk(){
    this.text = Chunk.frag; this.isHeader = this.detectHeader(); this.visible = false;
    this.ndx = Chunk.all.length; Chunk.all.push(this); // also add ndx field 
    this.index();
  }
  Chunk.all = [];  // this will be our array of chunks
  Chunk.frag = '';  // this will be our growing chunk fragment
  Chunk.addCard = function (card){if(card.length == 0){Chunk.flush()}else{Chunk.frag += ' ' + card;}}
  Chunk.flush = function (){if(Chunk.frag.length != 0){new Chunk(); Chunk.frag = '';}} // creates and adds to list
  Chunk.createAll = function(cards){
    for(var i = 0; i<cards.length; i++){Chunk.addCard(cards[i]);}
    Chunk.flush(); // convert final frag (if there is one) to chunk.
  }
  Chunk.showAll = function(){
    var mapStr = ''; var textStr = ''
    for(var i = 0; i<Chunk.all.length; i++){
      var ch = Chunk.all[i];
      mapStr += ch.htm();
      if(ch.visible){textStr += ch.h1OrP();}
    }
    inject('TEXT', mapStr);
    inject('VIS', textStr);
  }
  Chunk.prototype.detectHeader = function(){return this.text.indexOf('CHAPTER') >= 0;}
  Chunk.prototype.togVis = function(){this.visible = !this.visible;}
  function wrapParagraph(str){
    var res = str.replace(/[a-zA-Z’]+/g, function(x){return (index[x.toUpperCase()].count == 1) ? '<i>'+x+'</i>' : x;});
    return res;
  }
  Chunk.prototype.h1OrP = function(){
    if(this.isHeader){return '<h1>'+this.text+'</h1>';}
    var ip = wrapParagraph(this.text); // paragraph now polluted with I tags
    var hip = ip;  // highlighted pargraph
    if(highLight != ''){hip = ip.replace(new RegExp(highLight,'gi'), function(x){return color(x, 'red');})}
    return '<p>'+hip+'</p>';
  }
  
  Chunk.prototype.htm = function(){
    var letter = this.isHeader ? 'h' : 'p';
    var col = ' style="color:'+(this.visible ? 'red':'black')+';"'; // the color attribute
    var oc = ' onclick="tv('+this.ndx+');"'; // the on click attribute
    var qSafe = this.text.replace(/"/g, '\\"'); //convert the text so it is safe as a popup attribute
    var tit = ' title="'+qSafe+'" '; // the title attribute for creating hover text
    var res = '<span'+tit + col + oc +'>'+letter+'</span> ';
    //alert(res);
    return res;
  }
  Chunk.prototype.index = function(){wordsToIndex(this.text.split(/[^a-zA-Z’]/), this);}
  function tv(ndx){Chunk.all[ndx].togVis(); Chunk.showAll();} // click function for chunks  

  function Word(str){this.text = str; this.count = 0; this.chunks = [];
    this.ndx = Word.all.length; Word.all.push(this); // note: ndx is the index of this word in the list Word.all
  }                                                  // .. ndx will let me get from a single number to a Word
  Word.all = []; // all the Words in a list
  
  Word.prototype.incCount = function(){this.count++;}
  Word.prototype.addChunk = function(ch){if(this.chunks.indexOf(ch) < 0){this.chunks.push(ch);}}
  
  var highLight = ''; // set by clicking on a Word in the index
  function setHighLight(str){
    highLight = (str == highLight || str == 'I') ? '' : str; 
    inject("HIGHLIGHT", ((highLight=='') ? '' : 'Highlighting: ' + highLight));
  }
  function togWord(ndx){ // sets highLight and toggles visibility on this Word's chunks
    var w = Word.all[ndx]; 
    setHighLight(w.text);
    for(var i=0;i<w.chunks.length;i++){w.chunks[i].togVis();} 
    Chunk.showAll();
  }
  Word.prototype.htm = function(){
    var oc = ' onclick="togWord('+this.ndx+');"';
    var res = '<span'+oc+'>' + this.concordance() + '</span>:' + this.count;
    if(this.count > 200){return color(res, 'red');}
    if(this.count > 50){return color(res, 'orange');} 
    if(this.count < 4){return color(res, 'gray');}
    return res;
  }
  //Word.prototype.htm = function(){return this.text + ':' + this.count;}
  Word.showAll = function(){
    var res = '';
    uniqueWords.sort(); //function(a,b){return index[b].count - index[a].count;}
    for(var i = 0; i<uniqueWords.length; i++){
      var w = index[uniqueWords[i]]; // fetch the Word object corresponding to the uniqueWord string
      if(filter(w)){res += w.htm() + ', ';}
    }
    if(res == ''){res = 'nothing passed the current filter!'}
    inject('INDEX', res);
  }
  
  Word.prototype.concordance = function(){
    var ch = this.chunks[0]; // grab the first chunk from the list
    var loc = ch.text.toUpperCase().indexOf(this.text); // looks up the location of word in the chunk.text
    var low = loc - 30; // 30 characters before the word starts
    if(low < 0){low = 0;}
    var len = 70; if(low + len > ch.text.length){len = ch.text.length - low;}
    var title = ch.text.substring(low, low+len); // fetch out the substring containing the word
    return '<span title="'+title+'">'+this.text+'</span>';
  }  
  
  function wordsToIndex(words, ch){
    for(var i=0; i<words.length; i++){
      var w = words[i].toUpperCase();
      if(w != ''){
        if(index[w] == null){index[w] = new Word(w); uniqueWords.push(w);} // first time seen, create new
        index[w].incCount(); // .. now that we know it exists we count it ..
        index[w].addChunk(ch); // .. and mark it as containing this chunk.
      }
    }
  }
  
==Summary
The purpose of Moby Dick as a project was to introduce you to some word processing. I have shown you places where we split text, where we replace text, where we chop it into pieces, where we keep data on those pieces (using classes and objects) and where we reassemble those pieces in different ways and shove them out to the document. This creates a dynamic document.

To my mind that is the PURPOSE of this entire course. IF all you ever do is produce PDF file in black ink which you COULD print in a book or a newspaper, you are using high tech to produce ROMAN NUMERALS, a beautiful, ancient, perfectly legitimate and out of date system of presentation. "I come to bury Ceasar, not to praise him."

HTML documents, in contrast to chapter books and published articles, are living views. They have color. They can be animated. They react to mouse clicks to either show more or less. They are not dead documents.

Of course you CAN put a dead documents into html. Your browser is perfectly willing to show a page of text that the user can just read as is. If that is all you do, fine. No problem. that is GOOD! What I am pointing out is that you you can do BETTER, you can do more AND it is not that hard to do more once you learn a little about code. In about 100 lines of code here (and yes, it has taken me about a week to write and debug those lines of code, and to write all this text as well), we have done more to Moby Dick than ANY of those generous geeks that rendered the old bogus 80 column cards of Gutenberg text into HTML. They simply took an old dead text, ripped out the new lines and put in some paragraph markers and left it as dead text, another leviathan rotting on the beach. We went and found the cool words, decorated the work, spiced it up, hid the text and hovered and revealed. Did this improve Moby Dick? Not in the least. Would Melville be proud or ashamed of what we have done? I neither know nor care.

I didn't do this for him. I didn't do this in order to improve Moby Dick. I did this because, "This is my substitute for pistol and ball. With a philosophical flourish Cato throws himself upon his sword; I quietly take to !bthe_ship. There is nothing surprising in this. <i>If they but knew it</i>, almost all men in their degree, some time or other, cherish very nearly the same feelings towards !bthe_ocean with me."

replace 'the ship' and 'the ocean' with 'javascript' and 'writing code'  

Next up a new project. 



</script>
</body></html>