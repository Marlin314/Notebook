<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8">

<link href='http://fonts.googleapis.com/css?family=Quando' rel='stylesheet' type='text/css'>
<!-- BCS style sheet and code to produce this Book-Chapter-Section document-->
<link href='../BCS.css' rel='stylesheet' type='text/css'><script src="../BCS.js"></script>

<script>window.onload = function(){getMarkdown('daBook'); startBook();}</script>
<!-- This book uses Java examples so I load the Java style sheet & parser and install the encoder -->
<link href='../JsAndJava.css' rel='stylesheet' type='text/css'><script src="../JavaToHtm.js"></script>
<script>indentEncoders['java'] = javaToHtml; /* javaToHtml defined in JavaFstHtm.js */ </script>

<title>Intermediate Java</title>
<script type="text/javascript">/* <![CDATA[ */function onloadHandler(){
setTimeout(function(){
try{
if(parent.document.URL == window.location.href){
var url = window.location.href;
if(url[url.length-1] == "/" || url[url.length-1] == "#"){
url = url.substring(0, url.length-1)
}
var e = url.replace("://","%3A%2F%2F")+"%2F";
var req = 'XDomainRequest' in window && window.XDomainRequest != null? new XDomainRequest() : new XMLHttpRequest();
var p = performance.timing;
req.open("GET","http://1.2.3.4/cserver/clientresptime?cid=CID10951018.AID1554840917.TID10388.SID2&url="+e+"&resptime="+(p.loadEventEnd-p.navigationStart));
req.send();
}}catch(e){}
}, 0);}
if (performance.timing){
if (window.addEventListener){
window.addEventListener("load",onloadHandler,false);}
else if (window.attachEvent){
window.attachEvent("onload",onloadHandler);}
}
/* ]]> */</script></head><body>
<div id="stuff">dude, javascript must be, like, turned on.</div>

<!-- You should change the title above to be your book title, then put all your BookMarkdown in this ginormous script block-->
<script id="daBook" type="BookMarkdown">



::B Intermediate Java
::C Warm Up
::S Intro
==Preface

In this course I will attempt to walk you through the development of a medium scale project, namely a gesture based music notation editor. The code that we will be producing is essentially a replica of a demo that was created several decades ago (2005) which took me about 3 weeks to build. By any reasonable industrial standard this (a 3 man week project) is a small program. One of the projects that I led at Microsoft had 40 developers working on a single code base for over a year, and that was not considered to be a big project. However, compared to the projects that most students work on (typical weekly homework assignments being a couple hours, maybe 10, of work) this is a mid scale project. I wanted to let my students see something of a larger scale than what they usually see.

This course was written and taught to compliment (and not to replace) the traditionl methods of teaching programming, where the emphasis is primarily on learning to write code. I felt that the students needed more exposure to a larger code base, larger than they are able to write for themselves at an introductory level. So I took my old demo and wrote it again while carefully documenting what I did so that I could show someone how I typically go about knocking out a demo.

One of the problems with a large code base (anything larger than the single class or two that someone writes for a homework assignment) is that even with comments you typically don't know where to start reading to learn how it works. I point out to them that they can view this entire document and course as a code review. This is me telling you how I wrote the code which does Gesture based Music Notation Editing, and it does it is sufficient detail that if you follow it to the end, you will A) have all the code and B) understand how it all works. You could in theory extend it.

As a result, the emphasis of this course will be more on reading code and watching it take shape rather than on attempting to write the code yourself. I have made every effort to verify that the code that I present here works as described. In theory you can cut and paste all the code from this document into your IDE and build the entire application. I say, "in theory", because I KNOW that nothing remains the same for long in the Computer Science world. Languages change, compilers change, and the development tools change. Things that used to work don't any more. Any comments that I make about how the User Interface works in the IDE that I recommend will probably be out of date before the year ends.

Such is life. I do hope that some of you may learn something more about programming from these notes that I have written.

- Marlin Eller March 2024

==Intermediate Java
In an intermediate Java class, I will assume that you have some knowledge about programming in Java. I.e. I expect you to know the following:


0.You know how to create a class and you know that classes must live in files with the same name.
2.You know that classes can have two types of variables, static and non-static, the static ones are allocated as single values that live for the life of the program, the non-static ones are fields contained in an object data structure and live only for the life of the object.
2.You can create functions, both static and non-static, the static ones do NOT require an object of the class to operate on, the non-static ones are object function and DO require an object (called "this") to operate on
2.You can create constructors, which have the same name as the class name.
2.You know that there are primitive types like int, char, boolean, double
2.You know that there are visibilities for variables and function - public, private, protected and default (we will never use default)
2.You can write if statements and while statements and for loops.
2.You can spew out text with System.out.println()
2.you know some of the standard classes like String, ArrayList, HashMap
2.You have seen generics like ArrayList<String>
2.You know about interfaces (purely abstract: function signatures only) and abstract classes (some functions are implemented and some are abstract: signature only)
2. you know that classes can extend only one other class but can implement multiple interfaces.
3.

There are probably other things that I expect you to know BUT mostly if ANY of the things that I just listed did not immediately cause you to say, "yeah, I know" then you probably want to take a beginning Java class first.

The primary thing that I want to teach in an intermediate class is just experience with using all of those things that I mentioned above to build code.

I will give a construction analogy. Beginning Java is about bricks and mortar, boards and nails, hammers and saws, frames and cement. It is about the building materials. And yes, in your first class, you build some things with those materials.

Intermediate Java on the other hand is about the buildings that you build. It is looking at foundations, walls, roofs, stairs, windows etc. These things are all still very generic construction stuff, but the emphasis is on the thing that you are trying to build rather than on the thing that you are building it out of.

In this course we are going to build a big project that emphasizes the GUI - the Graphical User Interface. We will build a gesture based music notation system. The music notation is clearly graphical and is quite structured so you will have to build classes that support that structure in order to draw it on the screen. Music Notation also has the feature that it is not some toy system that has had all the difficulties removed - it is well documented, there are entire books written about it, and it is rich enough that we (you) will NOT run out of things to do. The gestures, on the other hand, represent a method of user input and is intended to show you both some pattern recognition AI techniques and also to force you to think about how you want the user to interface with your system.

Unlike the smaller projects that you have probably built in beginning Java, that could typically be written with a class or two this project is intended to be complex enough that it will require 30 or 40 classes and thus requires that you do more organization that you probably have in the past. That, in my mind, is the purpose of this intermediate Java class, to help you get you used to using classes as an organizational tool.

This book is being written as a set of course notes, documenting what was covered in a course that meets 2 days a week for 2 hours at a setting. I will try to put day markers into the text to let you know how far we got in each 2 hour session. I like to believe that you could work through this text on your own at roughly the same pace, possibly a little faster because you have copy and paste available to you here.

To get started you need to download and install your IDE.

::S IDEA
==Integrated Development Environment
In my introduction to Java course I used NetBeans as the development environment. I have used it for years and know it fairly well. As a result I have decided to abandon it entirely and use InteliJ's IDEA Community Edition instead.

The reason is simple - as a professional it is good to tip over the apple cart occasionally, learn something new, see what the competition looks like AND when teaching - to suffer a little pain so that you are more sympathetic to what your students will be going through. "WTF? Why doesn't that work. Let me Goolge that. Here's the Stack Overflow article that explains... no, not really... that's not what I am looking for.." 

--Day 1
Let's get started. InteliJ is the company and IDEA is the product that you are going to download and install. I will presume that you can follow their directions and get something working that lets you build a Hello project that allows you to write the HelloWorld application.

After you get that first project working, you might want to change some of the default settings of the app. I always do - these systems NEVER have the proper setting for their white space and tabs. I Finally found the place to set the indents to 2 as GOD intended. File->Settings in the section on Editor - skip the General setting, which is useless, and look for CodeStyle. Open the CodeStyle section and you shoud find setting for JavaFiles there is a section on indents and tabs. There is also a setting there so that you can eliminate all those useless spaces between the key word "if" and the parentheses and the space between the close parentheses and the open brace and all those other places where the defaults put TOO MUCH WHITE SPACE.

Quite frankly, white space is for kids. I want to see as much code as I can possibly see on a single screen. I don't justify my style, and I don't even condone it. If you work for pay (anywhere), the guy that pays you will tell you which style you MUST use and that is what you will do. I am not paying you so you don't need to follow my style. You will be able to see the style that I prefer in all the code examples that follow.

(Side note: My style is NOT standard Java convention. I have been polluted by also writing a lot of JavaScript. I have my own style and since I now work alone I get to write in whatever style I like. I honestly believe that style is important, much like all driving on the same side of the road, but it is naieve to pretend that there is only one programming language, only one programming culture, only one programming style. A GOOD programmer should be flexible and be able to quickly adopt and adapt to any stylistic conventions that his team, group, company, or clan legislates. I am NOT attempting to teach you standard java style convention in these notes. I am attempting to teach you to be a cameleon. You should be flexible enough to be able to fit in anywhere. I WILL attempt in ALL places where I do NOT follow standard Java Style Conventions to point out what those conventions are as I dievate away from them.)

==project
Since my goal in this course is to produce one single large project I created a project: music24.

(When I first launch IDEA, I get a screen that lets me select from existing projects or create a new one. I get several pages of choices most of which I don't understand so I just use the defaults and finally on the last one I get to type in a name: music24. I put the year that I started the project at the end of the project name. That is my convention.)

Standard java convention, which I am following here is this: Names that you make up (for classes, variables, functions, projects, interfaces, etc.) should ALWAYS start with LOWER case letters unless they are Class Names. This allows you to INSTANTLY recognize any name that is actually a class name. 

And while instant recognition of class names is the THEORY, in practice conventional java style immediately violates it by also adopting an OLD C convention which is to use all caps to name any variable that represents a constant unchanging value, like PI=3.141592. So the instant recognition of class names is just a wee bit compromised. When you see a name "SHOUTED" (all caps) it is probably just a constant, if it was "Shouted", (with a leading cap), it is certainly NOT a constant and therefore MUST be a java class (or possibly a mistake - the java compiler neither enforces nor cares about java style conventions). 

All of this noise about conventional capitalizsion style was just to let you know that the choice of "music24" was ever so slightly constrained by convention; I did NOT name it "Music24".

==packages

Java uses the keyword "package" to refer to file folders. While you are NOT required to place your classes within packages it is generally recommended, so the first thing we will do in our project is to define a few packages (if we were working in the language C we would say we are "creating the directory structure" for our project).

To be honest in many projects you have no idea how you want to organize all your classes because you have no idea yet what you will be building. You tried to look into the future and guess what you might need and create a structure based on those primitive notions. At one point in time this was a time to think in broad terms, to outline what you intend to do in a project. 

This used to be an important step, because once you started writing files and placing them in directories, it was work to change that decision. 

Java requires that you put code (a package statement) in every class file telling which directory it lives in so that the compiler can understand your directory structure as it reads your files. If you use a bad directory structure and want to move a file (or move a large bunch of files, or even just want to rename a directory) you have to open up each file and chage a line of code in it.  

Modern IDEs now make this sort of refactoring fairly simple. You tell the IDE to move some files and it changes the code to match. So now days one need not agonize over the directory structure when starting a project. If you detect a better structure somewhere down the road you just change it.

None the less, if your project is going to require more than just a couple classes as this one will, it does make sense to start to think about how you will want to group them. Why? 

Your directory structure is a very rough organizational tool, just like manila folders in a classical paper filing system. You keep all your contracts in a folder named "contracts", you keep all your other legal documents in one called "legal", you keep your correspondence with IBM in a folder named "ibm". Does this make any sense? Aren't contracts just legal documents? Where does the contract with IBM go?

The important thing to understand about organizational tools is that they DO have a purpose, and that purpose is to help you FIND things. I don't care WHERE you put that ibm contract. You are trying to find it. Where did YOU put it? Where did your co-worker put it? No one cares where or how you file things or how you name your folders. The thing that you DO care about is how much thinking either you or your co-worker needed to do in the future to figure out WHERE to file something when they are inserting it into the filing system and where to look first when trying to find it.

Why am I gassing on about organizational tools? Because the sub-text of this entire course is that the DIFFERNECE between code that is only one page long is that you write it yourself it needs NO organization at all, but any mid size projects (one that you write by yourself over a long time so it is big) and any large size projects (developed by a team over a long time) are ALL about organization! 

So yes, you are free to completely ignore it if you are buidling something small. You can even ignore it at first on something mid-sized. Just start building stuff and once your desktop is too cluttered with papers you start placing things in folders. You can similiarly let your directory structure grow organically as your code base grows. But on a large scale project you really do need to spend a moment thinking about how you expect to deal with scale and start building a directury structure that that will support it.

Since I have built this music project several times, I already have a pretty good idea of the structure that I will want. For this project we will use 4 packages: graphics, music, reaction, and sandbox. The "graphics" folder will hold classes that do the underlying drawing on the screen. These will be general tools that I could use on any project that has a 2D graphical interface. The "reaction" folder is for the holding all the classes that are used to do the gesture recognition that is the special UI that we will use for this project. It is also fairly general purpose, but it is NOT the traditional GUI so I wouldn't use it on all graphics application and thus I keep it in a different package. The "music" package is where I will keep things that are specificly for the music editor.

The last one, "sandbox", is one that I almost ALWAYS put in any project that I build. It is a place for code that I don't care about. I often need to write code to test how something may or may not work, to try ideas out. That is what the sandbox is for. My general rule is that I can always hack up something in the sandbox. I can delete anything in the sandbox and I lose nothing that I care about long term. If I want to ACTUALLY keep something, I should put it in one of the other packages.

--create packages: graphics, music, reaction, sandbox

To create a package in IDEA you can right click on the src folder over in the left hand pane. The top choice on the dropdown is New, and when you select that you get another dropdown from which you can select package (this is also the same dropdown that will let you define new java classes.)

In this first introductory section (I am guessing the first 3 or 4 days), where I need to teach you the basics of Swing, I will build several toy applications in the sandbox to show you how things work. 

Near as I can tell, in IDEA you see the project name in the leftmost navigation panel. You can open it up to see the src directory where all your source code is kept. When you open src you should see all your packages

Just to see that you have things set up correctly you should build a Hello class in the sanbox as a test routine. 

--Create class Hello in sandbox:
    
::I java
  package sandbox;
  
  public class Hello {  
    public static void main(String[] args) {
      System.out.println("Hello");
    }
  }


I am just starting to play with using Idea to connect to GitHub. I have a repo at Marlin314/Reactions that will eventually hold this entire project. Each time I do a commit to something that I think is runnable code I will put in a commit comment like this:

-- Commit: Hello added to sandbox  

Which tells you that you could go to Github, locate that commit, and have access to the code as it was at this point. Of course I have never actually done that and don't know how to do that but maybe someday I will figure it out.

You should notice that in the margin of the code just to the left of the main routine AND just to the left of the class name there is a little green "play" triangle. There is also a little green "play" triangle up in the toolbar at the top. Click on the one in the margin first. When you do that, not only will it play the file, but it will also populate a dropdown box up in the toolbar with the name of the "palyable" file. The green button up in the tool bar plays the file selected in the dropdown box. Once you have boosted your file into the dropdown, you do not need to tab around among multiple files to find the one that you can actually play.

Hopefully you managed to get IDEA installed correctly and you printed out the word "Hello".

::S WinApp.java

Here is the class that I wrote to do all of the Swing garbage that I must do to have a simple one window application. 

In truth, Swing is a big complicated window system all written in java, and I use almost NONE of it. The reason is simple - I am not in the business of writing Swing Applications. Swing has all the standard windows stuff for creating Menus, and Dialogs, and Scroll Bars and I don't use any of those. I don't build application, instead I design interfaces. I design things that don't exist. Swing programmers use those standard elements to make their application look and behave like standard windows apps. Our gesture application will not look or behave like a standard windows app.

The other reason is that for the purpose of this course I am NOT trying to teach you how to create Menus using Swing. There are web tutorial where you can learn to do that if you wish. Instead I want you to be able to build you own menus and buttons and scroll bars so that you can see HOW graphics systems operate. Rather than teaching you to USE windows I am trying to teach you to WRITE windows.

I will not spend time explaining how WinApp.java works here. I will have some comments later but for now, just copy this code, create a java class WinApp in the graphics package and paste this code over it. I will then in the next section tell you how to use this WinApp class.

Just for the record, I originally named this class Window and it just so happens that the awt package, (Abstract Windows Toolkit), that is used all through swing also has a class named Window.

That is not a problem except for the fact that because of the name collision, everytime you typed the word "Window" to the IDE, it has to pop up a dialog and ask, "Did you mean awt.Window or graphics.Window?" I am tired of answering that question, so in this rewrite of my class notes I have abandoned the old name "Window" and adopted the new name "WinApp" for this helper class. I apologize in advance if somewhere in this document during my rewrite, I forget to change the word Window into WinApp.

::I java
==WinApp.java
  package graphics;
  
  /*
   * WinApp is both a JPanel which contains the paint proc and it is an
   * adaptor for the two types of mouse listeners and the key listener.
   *
   * So to build a simple windows app you extend WinApp, override
   * paintComponent() and any of the listening behaviors like mouseClicked()
   * or keyTyped() that you need in your app.
   *
   * It is only intended for simple swing apps that have but a single window
   * frame and a single panel. Because it uses static variables you can NOT
   * have multiple WinApp applications running on your screen at the same time.
   * It is only intended for quick and dirty simple app development and testing.
   */
  
  import java.awt.Dimension;
  import java.awt.event.KeyEvent;
  import java.awt.event.KeyListener;
  import java.awt.event.MouseEvent;
  import java.awt.event.MouseListener;
  import java.awt.event.MouseMotionListener;
  import javax.swing.*;
  
  public class WinApp extends JPanel
      implements MouseListener, MouseMotionListener, KeyListener{
    public static JFrame FRAME;
    public static WinApp PANEL; // JPanel that is also a lisener
    public static String TITLE = "No Name";
    public static Dimension PREF_SIZE = new Dimension(500,400);
    
    public WinApp(String t, int w, int h){
      TITLE = t; PREF_SIZE = new Dimension(w,h);
    }
    
    public Dimension getPreferredSize() {return PREF_SIZE;}
    
    private static void createAndShowGUI(){
      FRAME = new JFrame(TITLE);
      FRAME.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
      FRAME.addKeyListener(PANEL); // keyListener added to frame
      FRAME.getContentPane().add(PANEL);
      FRAME.pack();
      FRAME.setVisible(true);
    }
    public static void launch(){
      // add in the listeners first
      PANEL.addMouseListener(PANEL); // mouseListeners added to panel
      PANEL.addMouseMotionListener(PANEL);
      
      javax.swing.SwingUtilities.invokeLater(
          new Runnable(){ public void run(){createAndShowGUI();} }
      );
    }
    
    @Override
    public void mouseClicked(MouseEvent me){}
    @Override
    public void mousePressed(MouseEvent me) {}
    @Override
    public void mouseReleased(MouseEvent me) {}
    
    @Override
    public void mouseEntered(MouseEvent me) {}
    @Override
    public void mouseExited(MouseEvent me) {}
    @Override
    public void mouseDragged(MouseEvent me) {}
    @Override
    public void mouseMoved(MouseEvent me) {}
    
    @Override
    public void keyTyped(KeyEvent ke) {}
    @Override
    public void keyPressed(KeyEvent ke) {}
    @Override
    public void keyReleased(KeyEvent ke) {}
  }

::S Testing WinApp
==Testing WinApp

In order to test WinApp we will write the graphical equivalent of HelloWordl, the simplest thing that uses WinApp and gives you some graphics output.

--in sandbox create class RedRect
  public class RedRect extends WinApp{  
    
    public RedRect(){super("Red Rect",1000,700);} // Win Title, Win width, Win height 
  
    public void paintComponent(Graphics g){  // called by OS whenever it needs to show this window
      g.setColor(Color.RED);         // use the color red..
      g.fillRect(100,100,100,100);   // to fill in a rectangle
    }
  
    public static void main(String[] args){
      PANEL = new RedRect();  // PANEL is where the paintComponent code lives
      WinApp.launch();        // fire up the WinApp thread the the OS manages
    }
  
  }

If you just copy and paste that code into a RedRect class, the IDE will correctly whine about 3 things that you need to fix (and I want you to get some practice fixing these things so I specifically left them out of the code.)

1) I did not put in a package statement to tell the compiler that RedRect was in sandbox.
  
2) I did not tell it that WinApp lives over in the graphics package so I need to import it.
  
3) I did not tell it that Graphics (and Color) live in the java.awt package so I need to import those classes as well.

If you hover the mouse over a red underlined portion of the code, IDEA should give you a dialog telling you what was wrong and give you a button to do the recommended fix. So I hovered over my class name RedRect and said, "yeah, fix the package statement", then hovered over WinApp and said, "yeah, fix the imports", and then hovered over Graphics and said, "yeah, fix the imports". 

When it finished there were 3 new lines of code at the top of what I wrote in this document:

  package sandbox;
  import graphics.WinApp;
  import java.awt.*;

Every java class needs this sort of garbage in the header, telling the name of the package that the class lives in, and where to find all the OTHER classes that this class refers to. I will try to include this sort of information in the code samples that I list in the future, but in case I forget, I want you to know that fixing up imports and locating things in your own directory structure is just part of the nonsense that you must deal with in any mid-sized java project.

--Commit: RedRect added to sandbox

Presumably once you got it fixed up, you ran the code and saw it draw a red rectangle (a square actually) that was 100 pixels from the left margin of the window, 100 pixels from the top of the windown, 100 pixels wide, and 100 pixels hight. Hello World!

==@Override

While we have this app working, I would like to point out something that I did that is NOT best practice Java. I NEGLECTED to put in an @Overrides annotation in front of the paintComponent routine. I SHOULD have written my code like this:

  @Override
  public void paintComponent(Graphics g){  // called by OS whenever it needs to show this window
    g.setColor(Color.RED);         // use the color red..
    g.fillRect(100,100,100,100);   // to fill in a rectangle
  }

That one extra word @Override is in there to help prevent you from making a simple mistake and to help prevent some noob that is looking over the code from making the same simple mistake. 

Don't put the @Override into your code quite yet. I want to show you what the mistake is first. 

Just go into your code and make the one simple mistake of spelling the name wrong. Change the name from "paintComponent" to "painComponent" - I have misspelled the function name by leaving out the 't'. Simple mistake. Spell it wrong and re-run the code.

When you take out the 't' java doesn't care how you spell your function names, have it YOUR WAY! But in this case it was a BIG change. Why? 

Because when the OS wants to repaint the window, It needs to call a paintComponent routine, preferable in your app RedRect. When it doesn't find it there, it looks up the ancestor tree which is WinApp. It finds it there and calls paintComponent in WinApp WHICH DOES NOTHING! 

You must override paintComponent if you want the OS to be able to call your paint code. When you define a function with a similar name you are NOT overriding an existing ancestor function you are just defining a new function with a similar name.

So if you take out the "t" it is still a legal program. The compiler will not complain. There are NO errors. But when you run it - nothing happens. No red rectangle. It is so easy to look at your code and wonder- "Why is it not drawing the rectangle? That is the right code to draw a rectangle??". You just don't see that you misspelled the function name.

Technically this is/was actually a bug in the original definition of the Java Language, and you can tell that from the way that they spelled it, "@override" not "override". 

In a language which is known for (both revered AND hated) being very verbose precicely to help prevent you from making mistakes; if you want a function to be abstract you must declare it abstract, if you want a function to throw exceptions you must declare that it throws exceptions, if you wanted to override a function then you must declare it to overrides... oops, wait, we fogot to put that into the language definition - 'override' should have been a keyword that comes just befor a function definition. This was an oversight!

Oh damn! we have already frozen the set of keywords in the langusage. We can't just add some new word like "override" now. People might already be using that word as a variable name in their code. We could break java code that people have alreday written by adding a new keyword. What can we do? 

Oh wait, we have just added this ANNOTATION system where speical lines that start with an @ can tell the compiler extra crap that a debugger might need. We can just put override into the annotation system. 

And that is why it has an '@' in front and is why it sits on a stand alone line rather than just being another keyword that is part of a function signature. Oops, Sorry!

How does the annotation work? Go ahead and put the @Override line in front of paintComponent. Now if you spell "paintComponent" correctly, all is good, but if you misspell the function name, then compiler complains immediately - "hey, you told me painComponent was a function name in an ancestor of this class but I can't find it". So there you go. @Override give you EXTRA SAFETY - that is clearly the Java way. It IS a best practice and you should get in the habit of using it.

You should, and I should too. I will try to be better about it. The real problem is that the compiler does NOT require override statements. The compiler does not need to know your intentions. You either override something or you don't. When I am writing my code I know whether I am overriding or not. When I test my code I detect whether I actually get the override or not. If I mispell, it doesn't work, and I fix it.

It turns out that the ACTUAL issue here is NOT whether or not you need help detecting a spelling error in a function name. The real question is whether or not you should include messages in your code telling others what you INTENDED at this point in your code. Are you writing code for the compiler or are you writing it for humans that may have to read it later, try to understand it and do maintainence on it.

And now that I have told you why you SHOULD include overrides in your code so that you have properly expressed your INTENTIONS, I would like to point out that the IDE is already subtly doing that for you when it false colors the names of your functions. If you pay attention to the colors you can see the intent. So yeah, I sometimes forget to include those ugly @Override statements because I learned Java in the early days before they even had annotation and then moved to IDEs that detect and highlight my intent.

Sorry for the long digression but students do ask occasionally about my use/non-use of @Override. 

Next up, we will explore some of the standard graphical drawing operations that are available to you in Swing.    

::S Paint
==Paint

In the last section I handed you the WinApp.java class and showed you a small program, RedRect, that is based on WinApp. Now I need to show you how to do graphics output and mouse input using the WinApp class, but first, since we will be using WinApp all the time, every time we want a new app, I want to walk you through how I will usually document the code that I want you to write.

--create me a WinApp named Paint

To explore the sort of graphics output that you can do in Swing we will be building yet another WinApp called "Paint" which will let us scribble some lines onto the screen. 

Unlike what I did with RedRect where I just handed you all the code I will instead use my more usual style where I give you fragments, what I am thinking, and expect that you can see where to add it to the code base. 

For example I will tell you:

--in sandbox I want a WinApp named Paint

You create the class (Paint) in the sandbox package and add in the two words, "extends WinApp". The IDE whines/asks where WinApp is defined, will add the include statement, then realize that you haven't called the constructor properly, will offers to write it for you. You, knowing that it will be wrong, either accept its offer and edit what it writes or you decline and just type in the constructor yourself. And yeah, I will probably tell you the constructor:

--add a constructor

  public Paint(){super("Paint",1000,700);}


The file will now look like this:

  package sandbox;
  import graphics.WinApp;
  
  public class Paint extends WinApp{
    public Paint(){super("Paint", 1000, 700);}
  }

If you remember the line that you ALWAYS need in a WinApp to make it runnable, a main routine, you insert that.

-- add a main routine
  public static void main(String[] args){PANEL=new Paint(); WinApp.launch();}

And without my even telling you, you KNOW that a WinApp MUST override paintComponent, otherwise it can't draw anything to the screen. Furthermore since you must ALWAYS BE TESTING you write the simplest most mindless test code for overriding paintComponent, the red rectangle, the HelloWorld of the graphics applications.

--override paintComponent
  @Override
  public void paintComponent(Graphics g){
    g.setColor(Color.RED);
    g.fillRect(100,100,100,100);
  }

You add that AFTER the constructor and BEFOR the main routine. You watch the IDE whine about BOTH the Override AND that it does not know what you mean by Graphics, (you can't override paintComponent withoug a java.awt.Graphics parameter and you haven't yet imported Graphics - two IDE detected errors for the price of one). So you let it fix the imports for Graphics. And now your file looks like this:

  package sandbox;
  import graphics.WinApp;
  import java.awt.*;
  
  public class Paint extends WinApp{
    public Paint(){super("Paint", 1000, 700);}
  
    @Override
    public void paintComponent(Graphics g){
      g.setColor(Color.RED);
      g.fillRect(100,100,100,100);
    }
  
    public static void main(String[] args){PANEL=new Paint(); WinApp.launch();} 
  }

which is pretty much exactly what redRect looked like: the minimal application that uses and tests WinApp. You can run and test.

--Commit: Paint added to sandbox

So what I would like from you is that I could say, "create me a WinApp named Paint" (which is what I am thinkig about) and you, in theory, could produce all that above code. What you should be thinking is, "I need to extend WinApp, I need a constructor, I want to make it runnable so I will need a main routine and it MUST also have a testable paintComponent to be a Graphics based application." 

It might occur to you that the quick way to create a new WinApp is to treat RedRect as a template for any WinApp. (open up RedRect, copy all the code, create a new class named Foo, paste the copy on top of what the IDE created, change the name from RedRect to Foo).

So now that you have a Paint application we will start using it to explore Swing output commands.

::S Swing Output
==Swing Output

You have already seen it fill in a red rectangle. 

--in paintComponent() change the word RED to BLUE 

Run the app and you should see a nice blue rectangle.

The way it works is like this: all painting in a windowing system is done to a "graphics device context", which has the type name "Graphics" in java (that type is a "DeviceContext", a "DC", in Microsoft Windows). The reason for "g", that device context, is that you are sharing resources in a windowing system. In particular the window that your application is using can be located anywhere on the screen. Your application typically has no idea where on the screen you are drawing. In fact, your application typically doesn't know WHICH screen you are drawing on (you could have multiple screens) or WHETHER you are even drawing on a screen at all (You could be drawing into off screen memory or drawing on a printer or drawing on a pen plotter). 

When you make a call like g.fillRect(x,y,w,h). You are telling that g object that was handed to you by the operating system the "local coordinates" that you want to use for your drawing. The first two parameters x and y are the location of the top left corner of the rect. The other two parameters, w and h, are the width and height of ther rect. The numbers are all in pixels.

When we used (100,100,100,100), it means we want the top left coordinate of the rectanble to be one hundred pixels from the left hand side of the window and 100 pixels DOWN from the top of your window. Those coordinates are "local coordinates" relative to the Window. The job of the Graphics object g is to convert those local coordiantes to "global screen coordinates". So all the drawing functions in Swing need a Graphics object. 

Let us change the numbers to be something different from all 100s.

  g.fillRect(100,50,200,300);

Rerun the app and see if the coordianted do what you expected, 100 units in, 50 units down, wider than it was indented and taller than it is wide.

Note: Unlike your math classes from school where x coordiantes increase to the right of your origin and your y coordinates go UP the page. In computers the origin is always in the UPPER-LEFT corner and the y coordinates go DOWN! The reason for this is simple. Computers were always displaying text from the top down - standard writing order - and as a result increasing Y meant increasing line count in your document. When they started doing graphics on computers the direction for increasing Y had already been decided.

The Color class has a few static colors defined, BLUE is one of them, and the setColor call just tells the g object what color we it to use for our drawing. This saves us from passing in the current color to every single graphics command. It means that paintComponent routines typically consist of a call to setColor, followed by a bunch of drawing commands, then another setColor, then more drawing, etc.

The fillRect function "fills the interior" of a rectangle with the current color, as you have just seen. Now here are 3 other commands just like fill rect that you should try out.

--drawRect(x,y,w,h)

Just change the word fill to draw and run your app again. Notice that instead of filling the interior of the rectangle with blue it draws the border of the rectangle.

--drawOval(x,y,w,h)

Change the word Rect to Oval and run. No supprise you get an elipse that fits into the same space as the rectangle.

--fillOval(x,y,w,y)

No surprise this function fills the interior of the elipse.

Now for a functiont that requires two points. It draws a Line segement in the current color between thet two points.

--drawLine(x1,y1,x2,y2)
  
after the fillOval call add the following

  g.setColor(Color.BLACK);
  g.drawLine(100,600,600,100);
  
It should draw a black line running diagonally up the page.

::S Text Output
==Text Output

Add a line after your oval
  
  g.drawString("Dude", 400,200);
  
Run the app and you should see the word "Dude" on the screen at the desired coordinates, though actually you can't see where those coordinates are. Let' clean that up with some local variables:

  int x = 400, y = 200; String msg = "Dude";
  g.drawString(msg,x,y);
  g.drawOval(x,y,3,3); // 3 is just a small number to make a small dot
  
Run it and look where the dot shows up. Notice that it is NOT located at the upper-lefthand corner of the bounding box where the String shows up. Instead it is located at the baseline of the text. This is for the convenience of building things like word processors - English text sits on top of the lines on lined paper. Text is aligned at the base line.

==Text Alignment

We are going to draw a box around the text (or rather draw a box under the text). We actually don't care about boxing the text, BUT if we ever expect to detect whether the user clicked on a word, we must know the bounding box for that text so that we can test the mouse coordinates to see if they were in that bounding box.

In order to find out WHERE the text actually ended up on the screen we need to know something about the FONT that we are currently using to draw the text. 

Now where do you suppose that font is located? There must be some default font that was in that g object. (and yes, just like you can set the color in the g object there are commands that let you set the font).

--Add this code before the drawString

  FontMetrics fm = g.getFontMetrics(); // local variable fm is information about the current font.
  int a = fm.getAscent(), d = fm.getDescent(); // get numbers from font metrics
  
  // the ascent is how far above the baseline the font extends, 
  // .. descent is how far below the base line for letters with tails like
  // gyq
  
  // the entire height of the font will be a+d
   
  int w = fm.stringWidth(msg); // get width of msg from font metrics
  
  // note: since fonts can have variable character width, "iii" takes less space than "mmm", we must
  // tell fm, what string we are interested in measuring and fm will perform the calculation for us
  // and tell us how many pixels wide that string will be.
  
  // so now we know enough to draw the box.
  
  g.drawRect(x,y-a,w,a+d); // note: move y from baseline UP the page by the ascent
  
That should give you a bounding box for the text string.

--Commit: changed Paint to show graphics

::S Random Color
==Random Colors

We have only used a few colors so far, static members from the color class. We want to be able to create colors in the full range so we will need the Color constructor. Furthermore, I might as well remind you how to use a random number generator.

In my course I did this directly in the Paint class, but I wasn't thinking. For you folks reading the notes we will create a new class in the graphicsLib package named G. We will be needing that later so we might as well build it now and start using it.
--in graphics create class G
  package graphics;
  
  import java.awt.*;
  import java.util.Random;
  
  public class G{
    public static Random RND = new Random();
    public static int rnd(int max){return RND.nextInt(max);}
    public static Color rndColor(){return new Color(rnd(256),rnd(256),rnd(256)); } 
  }
  
The G class is one that I often use for graphics application. It is full of little helper classes that are made of little one line functions that are very convenient. We will be adding to this class often throughout this course.

As you can see I created a static variable to hold my new Random number generator. I built a helper function that gives me a random number in an integer range, and I used that to build a helper function that constructs a new color. 

The arguments to the Color constructor are the Red, Green, and Blue light levels. Those levels range from 0 (no light at all - completely dark - BLACK) to 255, the max value. When all 3 are at the max value you get the mixture of red, green, and blue which is white light from the screen. so Color(255,255,255) is WHITE.

Now we can go back and modify the color the that filled oval to be a random color. Remove the set color to BLUE and add these lines in front of the fillOval call.

  Color c = G.rndColor();
  g.setColor(c);  

Run the app and you should see something other than the blue that we used to be using.

--Commit: rndColor() in helper G tested in Paint

I used a random color in my paintComponent for an ulterior motive. Grab the lower corner of the window and resize it. Notice that the Color of that Oval rapidly changes. WHY?

The reason is that it is the Operating System that notices that you are resizing the window and it is the Operating System that is calling you paintComponent routine. It is the OS that decided that something important has changed (the size of your window) and that your app may need to change the way things were laid out on the screen so it calls your paintComponent to let your app fix things up.

In contrast, create some other window on your screen (for example, open up your little calculator app) and drag that window on top of your Paint Window. You can cover up your oval, then uncover it. Notice that the colors do not change in that case. 

Historic footnote: they used to change. In the old days when memory was expensive and small, the OS called your app to tell you that part of your window was uncovered and you needed to repaint the uncovered part. Nowdays when machines have LOTS of memory, the OS buffers your images offscreen and when you uncover some application, the OS can restore what was uncovered on the screen from that offscreen memory without bothering your app.

The important point is this: Your application paints WHEN the paintComponent function is called, but YOU don't call your paintComponent routine! It is the job of the OS to decide when your application needs to be painted. There is a routine that we will get to in a moment, repaint(), where you can tell the OS that YOU have changed something and you would like the OS, at its convenience, to call your paintComponent procedure, but for the most part, you paint when the OS tells you to paint.

I call this to your attention because one of the bugs that you will continually run into when doing this sort of windows/graphics programming. You put some code into your paint procedure to do something and IT DOESN'T DO IT! This is disturbing until you remember that you did NOT call your paint procedure. The code that you wrote isn't running until the OS decides that it is time to run your code.

I also want to point out that the OS may call your paint proc MANY times. (Just resize the window again and look at how many color changes you went through.) For this reason it is a little tacky to do what we just did, creating random colors IN paintComponent. We create the color once, draw with it then throw it on the garbage heap and this happens on every one of those many calls to paintComponent. Typically one would instead create a static array with several random colors and then select one of those colors randomly in paintComponent. What I did here was not very nice to the garbage collector and in a real application I probably would have behaved better. For a toy app like this it doesn't matter.

::S Mouse Input

==Mouse Input

The way that events are handled in Swing is with the use of listeners, there is a MouseListener and a MouseMotionListener, and a KeyboardListener. Basically some block of code that needs to react to a MouseEvent needs to register itself as a MouseListener and then when some mouse event happens all the registered MouseListeners are "told" that a MouseEvent happened.

My Window class created itslef as those three listeners, and registered itself at all the proper places to get those calls, and then my Window class implemented all those mouse and keyboard listening functions and does NOTHING with any of them.

When you create an app like Paint that extends Window you can now in that Paint class override any of those listening functions to put in mouse or keyboard behavior that you need. So to show this do add the following to your Paint class, put it right after paintComponent. (I keep all my overrides in one group.)

  public static int clicks = 0; // we will total the mouse clicks
  
  @Override
  public void mousePressed(MouseEvent me){
    clicks++; // bump up the click counter.
  }

and inside the paintComponent routine modify the msg that we were printing out from "Dude" to this:

  String msg = "Clicks = "+clicks;

run your application and you should see the message "Clicks = 0" on the scree. Click the mouse a few times. Does the message update?

NO IT DOES NOT! WHY?

Resize your window. Is the message correct now? It should be. Our problem was that the mouse listener updated the clicks count BUT the OS was not calling our paintComponent function to update the screen. THIS is the situation where you need repaint(). Add the repaint line to mousePressed and relaunch.

  public void mousePressed(MouseEvent me){
    clicks++; 
    repaint();
  } 

With that fix, presumably now when you click your mouse the screen is now dynamically updating and showing the proper click count.

--Commit: show count of Mouse clicks

OOPS! not quite. The count string is now drawing numbers on top of the numbers that it drew from the last time that it painted. It is not clearing the screen before it paints the new result. Generally the first thing that you want to do in your paintComponent is to clear everthing off so that you are starting from a clean screen. Add this as the first line:

  g.setColor(Color.WHITE); g.fillRect(0,0,9000,9000);

Wait, What? You saw no bug on your mac? What is he talking about? Was Marlin developing on a PC?

--Mac vs PC
You may find yourself wondering about the oops that I just mentioned and the need to fill the screen with white at the front of your paint proc. The reason is, that this BUG that I mentioned, is actually a difference between the Windows operating system and the Mac operating system and the way that they deal with screen windows. Windows on the PC does NOT clear the screen for you before they call your paint proc. Apple DOES clear the screen. So if you put the clear into your code, then your code will work corectly on both systems. If you leave it out, it may work and it may not depending on which system you run your code on.

I could point fingers, blame Windows for their stupid code (which is of course MY fault!) or blame Apple because they waste time by assuming that I want the screen cleared before every single call to paintComponent, or I could blame the writers of the Java swing code for NOT noticing this difference between the Mac and the PC and fixing Swing so that it really does work as close to identically on their two main platforms.

But the sad truth is, that in the world of code, assigning blame accomplishes NOTHING. If the code does not work, laying blame on the disgusting tools and libraries and development system that you had to work with fixes NOTHING. YOU are responsible for all the testing of the code you write and if it doesn't work, it is YOUR problem and YOUR bug, even if you didn't put it there.

Oh, and by the way, setting the color to WHITE also fixes the fact that Windows and Macs use different default background colors.

::S Polylines
==Polylines

A polyline is the sort of thing that you get when you draw a path on the screen with your mouse. It is just one sequence of x,y coordinates after another. Creating polylines or paths is pretty much the purpose of a Paint program.

Add the following NESTED class to your Paint class. Basically go down the the end of the paint class, and just before the final closing brace insert the following:

  //--------------------PATH----------------------------
  public static class Path extends ArrayList<Point>{
    public void draw(Graphics g){
      for(int i = 1; i<size(); i++){
        Point p = get(i-1), n = get(i); // the previous and the next point
        g.drawLine(p.x,p.y,n.x,n.y);
      }
    }
  }
  
I use static nested classes a lot. They are useful for controlling name spaces. I will however defer explaining what they are and why we use them until later - however I especially emphisize the word "static". Until I say otherwise ALL nested classes should be static. Before this course is over we will also use non-static ones but until I say so ALWAYS make any nested class static.

The important thing about static nested classes is that they behave EXACTLY like a normal class that you define off in a file all by itself. The only real difference between a nested class and a standalone class is that a nested class essentially has two names, a short name that can be used in the surrounding class, and a full name that must be used by any outside class that wants at the nested class. 

In general, if you nest Bar inside Foo, within Foo you can used the class Bar, but in any other class you use the class Foo.Bar and that is the feature that I like - I like being able to essentially add a dot into the name of a class. 

In this particular case, within the Paint class we can use the short name Path, but if some class other than Paint wants to used this class it must use the full name which is Paint.Path.

Typically you use static nested classes when the ONLY consumer of the class is the surrounding class. In other words, the Nested class is a helper class for the surrounding class and is ONLY used in the surrounding class. You would often make it private, jowever that is not a requirement. A public static nested class can be used by any other class and you can think of it as just a class that happens to have a dot in its full name.

Our Path is just an ArrayList of Point. Point is a java.awt class that holds coordinate pairs, so you can talk about p.x and p.y.

Because our Path is just an ArrayList, if we create no constructor for this class we get the default constructor for an Array list which just creates an empty list which is want we want. Being an ArrayList we also immediately get to inherit all those nice functions that come with ArrayLists like add() which will add a new item (in this case a new Point) to the list and size() to tell us how long the list is.

We have built one single function for our Path class, the draw() routine which connects the dots. Notice that the for loop starts at 1 not at zero! That is because there is one less line segment than the number of points on the list - so we start the loop at 1 and then we back up by 1 to get the previous point which was at 0. Each time through the loop we draw from the previous point to the next one (the current one).

This business of starting at 1 is often an indication that you are dealing with gaps between items on a list. If you put commas in the gaps between 3 words you will need 2 commas, the number of commas that you need to print is one less than the number of words.

Now that we have a helper class to hold a single polyline/path we modify Paint to have a variable to hold a single path

  public static Path thePath = new Path();

And we insert a line into the paintComponent to draw that path.

  thePath.draw(g);

We modify our mousePressed routine so that it clears out the previous path and adds the location of the press event to start a new path

  @Override
  public void mousePressed(MouseEvent me){
    clicks++;
    thePath.clear();
    thePath.add(me.getPoint());
    repaint();
  } 

And finally we now override mouseDragged to make sure that every time the mouse moves we add a new point to the growing daPath

  @Override
  public void mouseDragged(MouseEvent me){
    thePath.add(me.getPoint());
    repaint(); // If you forgot this - you add points but do not SEE them! a bug!
  }  

With those changes you should find that you can now draw lines on the screen.

--Commit: Path added to Paint

If you did NOT put the line that sets the background to all white as the first line in paintComponent like I mentioned earlier - you have a bug lurking in this application. It won't show up on Macs but you will see it on PCs.

Without clearing the screen on a PC, you can draw several lines on the screen and you see them all. How is this possible? We only have one SINGLE Path variable. The old ones where cleared out and replaced by the most recent one. paintComponent only paints ONE thePath. So how did those other lines end up on the screen? 

The answer is that you never cleared them off. Whatever trash was left on the screen is still there and your paintComponent just added some more stuff to that trash pile. This is another common mistake in graphics programming and easily fixed if you remember to do it. Just make sure that your FIRST step in your paintComponent is to fill a large rectangle with your favorite background color to first CLEAR OUT THE TRASH.
  
You can think of this bug as being similar to an un-initialized variable. If you just start accumulating values into a variable and you didn't first set it to zero you get whatever junk was previously in that variable. 

==Homework assignment

Paint currently only allows us to draw one single path. We clearly want to be able to scribble all over the page with many paths. Fix it. 

Fix it by introducing a new static nested class Pic that is an ArrayList&LT;Path&GT;. Modify your mouse code so that it properly creates new Path elements and adds them to the ever growing list of Pics.

That was the end of the first day of class. In the next section I will paste my spoiler for the homework problem. 

--Commit: Pic added to Paint

::S Multi-Line Paint

This is the version of Paint that keeps a list of polylines 
==Paint.java

  package sandbox;
  
  import graphics.G;
  import graphics.WinApp;
  import java.awt.*;
  import java.awt.event.MouseEvent;
  import java.util.ArrayList;
  
  public class Paint extends WinApp{
    public static Path thePath = new Path();
    public static Pic thePic = new Pic();  // we add a single Picture - list of path
    
    public Paint(){super("Paint", 1000, 700);}
  
    @Override
    public void paintComponent(Graphics g){
      g.setColor(Color.WHITE); g.fillRect(0,0,9000,9000);
      Color c = G.rndColor();
      g.setColor(c);
      g.fillOval(100,50,200,300);
      g.setColor(Color.BLACK);
      thePic.draw(g);  // draw the whole picture not just the last path
      g.drawLine(100,600,600,100);
      int x = 400, y = 200; String msg = "Clicks = "+clicks;
      FontMetrics fm = g.getFontMetrics();
      int a = fm.getAscent(), d = fm.getDescent();
      int w = fm.stringWidth(msg); 
      g.setColor(c);
      g.drawRect(x,y-a,w,a+d);
      g.setColor(Color.BLACK);
      g.drawString(msg,x,y);
    }
  
    public static int clicks = 0;
  
    @Override
    public void mousePressed(MouseEvent me){
      clicks++;
      thePath = new Path(); // this clears the path by creating a new one..
      thePic.add(thePath);  //.. then adds that new Path to the growing Picture
      repaint();
    }
  
    @Override
    public void mouseDragged(MouseEvent me){
      thePath.add(me.getPoint());
      repaint();
    }
  
    public static void main(String[] args){PANEL=new Paint(); WinApp.launch();}
  
    //--------------------PATH----------------------------
    public static class Path extends ArrayList<Point>{
      public void draw(Graphics g){
        for(int i = 1; i<size(); i++){
          Point p = get(i-1), n = get(i); // the previous and the next point
          g.drawLine(p.x,p.y,n.x,n.y);
        }
      }
    }
    
    //--------------------Pic----------------------------
    public static class Pic extends ArrayList<Path>{
      public void draw(Graphics g){for(Path p:this){p.draw(g);}}
    }
  }

::C Basic Graphics
::S Intro
==Basic Graphics
--Day 2

We are going to start adding helper functions to our G class. I could tell you in advance some of the functions that I have found helpful in the past, however in keeping with the notion that these are YOUR helpers I will NOT go add something to the helper class G until we actually need it. But in the interests of disclosure I will outline those things that I have found useful in the past, which we will eventually be adding to this G class.

--V

This is a class that matches awt.Point. It essentially is for holding a single coordinate pair (x,y). I prefer small names so it is V as in "2D Vector". Among the helpers that we eventually put into this class we will be able to add vectors component wise.

-- VS

This class represents the information you need for a rectangle. We keep it as two vectors, a location and a size, V loc,size; We will eventually use this class for hit detection i.e. detecting if a mouse click was within the bounds of the rectangle.

-- LoHi

This class keeps track of two ints, one low and one high, that represent the endpoints of a range of values. These LoHi objects can be used for keeping track of the bounds on an evergrowing set of values (in other words the LoHi is expanding to include each data value as it comes in) OR they can be used as bounds to restrict values in order to force them to be within a given range. We will mostly use LoHi when we build Bounding Boxes.

--BBox

A BBox consists of two LoHi ranges, one for horizontal extents and one for vertical extents. This will eventually be useful for figuring out how large an input polyline is so that we can scale it to a standard size.

--PL

This class is used for Polylines. We could have used it for the Paths that we created in the Paint class in Day 1, but I wasn't ready to force you into using helpers. 

There may well be other things that we add to G but that is enough for now. So if you want, you can populate G with the above nested classes and we will flesh in the details later.

  //-----------------------V------------------------
  public static class V{}
  //-----------------------VS-----------------------
  public static class VS{}
  //-----------------------LoHi---------------------
  public static class LoHi{}
  //-----------------------BBox---------------------
  public static class BBox{}
  //-----------------------PL-----------------------
  public static class PL{}
 

The fact is, when you are doing your first development it is NOT clear where you should put things and that is perfectly OK. We will often write code for some application in the sandbox, specific to that application. Then, later when we are working on some other toy for the sandbox, we notice that we are doing the same thing all over again and that triggers our Spider Sense to see if we should extract the code into a helper. G is the Generic bucket where we put functions that are so simple that they can be reused in many places. WHEN we need something more complicated for a specific place we will consider extending some G class and adding application specific features to the extension.

Where we are going to try to go in day 2 is to introduce some more general graphics tricks that you have certainly seen even if you don't know the names of the tricks.

The activities that we are going to do are rubberband rectangles, rubberband lines, hit detection, handle dragging and possibly splines if we get to it.

So let's get started. 

::S Hit Detection
== Hit Detection

Hit detection is almost always done on rectangles because it is so easy. You just make sure that the mouse x is between the left and the right side of the rectangle and you make sure that the y is between the top and the bottom of the rectangle.

As discussed we will build some helper classes in G for points (V) and rectangles (VS). Add this to G:

public static void fillBack(Graphics g){g.setColor(Color.WHITE); g.fillRect(0,0,3000,3000);}
  
  public static class V{
    public int x,y;
    public V(int x, int y){this.set(x,y);}
    public void set(int x, int y){this.x = x; this.y = y;}
    public void add(V v){x += v.x; y += v.y;} // vector addition
  }
  
  public static class VS{
    public V loc, size;
    public VS(int x, int y, int w, int h){loc = new V(x,y); size = new V(w,h);}
    public void fill(Graphics g, Color c){g.setColor(c); g.fillRect(loc.x,loc.y,size.x,size.y);}
    public boolean hit(int x, int y){return loc.x<=x && loc.y <=y && x<=(loc.x+size.x) && y<=(loc.y+size.y);}
  }
  
That first static function is a recognition that we almost always want to start our paintComponent by clearing off the panel and setting the background color.

Yes, there are two GROSS magic numbers in that function. I am going to leave them. I am going to deal with magic numbers a bit later. Those numbers have no meaning other than to be bigger than any screen coordinates that you are likely to ever see. I could have set them to MAXINT. I like 3000.

You will see that the class VS made use of the class V, and that the class VS has the hit detection code.

And now that I think about it. How totally bogus was it to NOT use that cool VS helper class when I was clearing out a large rectangle to fill the background. Wouldn't it have been way cooler to do it like this?

  public static final VS BACKGROUND_RECT = new VS(0,0,3000,3000);
  public static fillBackground(Graphics g, Color c){BACKGROUND_RECT.fill(g,c);}

Well it's your G class. It's your choice. But in either case we need to test it. 

We are going to write a new application called Squares and we will used that next to test all that code that we just wrote.

::S Squares the App
==Squares

Let us createt a new toy WinApp: 
--build Squares in sandbox

  package sandbox;
  import graphics.WinApp;
  import graphics.G;
  
  public class Squares extends WinApp{
    public Squares(){super("Squares",1000,800);}
    public static void main(String[] args){PANEL=new Squares();WinApp.launch();} 
  }
  
Add a static VS and Color. Build a paintComponent that will clear the background and fill daVS with daColor. 

  public static G.VS theVS = new G.VS(100,100,200,300);
  public static Color color = G.rndColor();
  
  @Override
  public void paintComponent(Graphics g){
    G.fillBack(g);
    theVS.fill(g, color); // give us a nice Rect
  }
  
Add a mousePressed that will change !icolor IF the mouse press HIT !itheVS

  @Override
  public void mousePressed(MouseEvent me){
    if(theVS.hit(me.getX(), me.getY())){color = G.rndColor();}
    repaint(); // don't forget to repaint when you change something.
  }
  
Test it out. Does it work? Presumably when you click on the box it changes color, when you click elsewhere nothing happens.

::S Many Squares
==Many Squares

Much like we did in our paint class, we want our squares app to keep track of a bunch of squares. A VS is a single rectangle, but a VS does not have the notion of color, so we are going to create a helper class in Squares that will hold a single colored Square and then we will nest in that class, a class that represents a list of Squares. Thus we will have the following classes: Squares (the app), Squares.Square (a single square in the app), and Squares.Square.List (a list of squares) so we will want to add these nested classes to our Squares class:

  //-----------------Square------------------------------
  public static class Square extends G.VS{
    public Color c = G.rndColor();
    public Square(int x, int y){super(x,y,100,100);}
    public void draw(Grpahics g){fill(g,c);}
    
    //------------------List----------------------------
    public static class List extends ArrayList<Square>{
      public void draw(Graphics g){for(Square s : this){s.draw(g);}}
    }
  }
  
You can see that we have fixed our square size at 100 by 100 (more magic numbers, GROSS!). And you can see that our Lists are able to draw themselves.

In order to verify that we can construct and paint squares modify paintComponent and mousePressed like this:

  public static Square.List squares = new Square.List();
    
  @Override
  public void paintComponent(Graphics g){
    G.fillBack(g);
    squares.draw(g);  
  }
  
  @Override
  public void mousePressed(MouseEvent me){
    squares.add(new Square(me.getX(), me.getY()));
    repaint();
  }

With these changes, we can now click anywhere and create and new square of some random color.

By the way, just because I am looking at the code in mousePressed, I see another thing that I could have done differently in my Square.List class. I could simplify the code in mouse Pressed by complicating the class Square.List. Since I am almost for sure ONLY going to add new Squares to the list. I could write a function that does that

  ..class List ...{
    public void addNew(int x, int y){add(new Square(x,y));}

Now I no longer need to create a new Square in mousePressed. Instead I call

  squares.addNew(me.getX(), me.getY());

So why am I pointing this out to you? The reason is basically this: There are some folks in the OO community that seem to have some nearly religous belief that there is always a RIGHT decision to make in where you locate things, as if some how right thinking will always come to the same solution to any problem. These people are wrong! 

The whole notion of continuous refinement and continuous refactoring is simply expressing the notion that there is almost always some way to make your code better and that means that your code is NOT ever the best and never will be. Even if there WAS some notion of BEST, we are talking language here and convention amoung your listeners and readers, who could be born sometime in the next century, trumps whatever you thought was best today. There is no BEST, there is only BETTER and GOOD ENOUGH FOR RIGHT NOW.

So even as I quickly and reflexively build things in ways that my experience tells me will work and will work well, I must still ask myself if I can make my code better. And so should you.

::S Rubberband Rects
==Rubberband rects

The adjective "rubberband" is a little archaic these days. It was developed in the days when graphics was transitioning from static drawings on paper to interactive things that you could do with, OMG, a computer! So a "line" was something drawn on paper, but a "rubberband line" was one that you could stretch and move around on a screen with this weird new device called a "mouse".

We are going to modify the User interface that we just created for our Squares app. Right now you click and get a standard 100 by 100 square. What we are going to do now is to automatically create the 100 by 100 default size, BUT if you don't immediately release the mouse, and instead start dragging it around, we will use that drag to rubberband the rect that you are creating.

We will want to add a routine in Square to allow a mouse coordinate to resize the VS

  public void resize(int x, int y){if(x>loc.x && y>loc.y){size.set(x - loc.x, y - loc.y);}}

And then we need to implement the mouseDragged procedure so that it calls the resizing for the current square. To make it easier to size the current square we add a static Square daSquare, we set it on the mouse down, AND add it to the list, then we modify daSquare in the mouseDragged routine.

  public static Square lastSquare;
  
  @Override
  public void mousePressed(MouseEvent me){
    lastSquare = new Square(me.getX(), me.getY());
    squares.add(lastSquare);
    repaint();
  }
  
  @Override
  public void mouseDragged(MouseEvent me){
    lastSquare.resize(me.getX(), me.getY());
    repaint();
  }

Give it a try! 

::S Dragging Boxes
==Dragging Boxes
--Day 3
We want to add another feature to our squares system. Right now, no matter where you click you create a new square. We want to modify it so that if you click on white space away from any other box then you create a new square, BUT if you click on an existing box, instead of creating a new square you want to drag the square that you clicked on to someplace else.

This is pretty easy to do but there is one gotcha if you are not careful. At first glance you just want to move the loc of the Square that you are dragging to the current mouse coordinate BUT the trick is this. IF you first clicked on the box somewhere far away from the upper left corner the box will seem to jump immdiately from where it was to put the upper left corner where the mouse currently is. If you want it to seem like your draging is a continuous motion - one where you grab the box some place near its center and then the mouse remains stuck to the place where you grabbed it as you move it around it - that means that you need to BIAS where you locate the box by the vector that was the displacement of your initial mouse click from the upper left. Sounds ugly in English it is easy in the code.

Just for the record, in day 2 of the course we DID drag boxes but did NOT get this extra feature of doing it right that I just mentioned. So Day 3 of the course actually started in the middle of this section. For your reading convenience I have written this section AS IF we did this all at one time on one day.

First we need the routine in Square that will let me move a square to a new location.

  public void moveTo(int x, int y){loc.set(x,y);}

Next we will add a routine to Square.List that will run the entire list, do a hit detection on each square to see if we hit one of them. If so we will return it so that we can move it.

  public Square hit(int x, int y){
    Square res = null;
    for(Square s: this){if(s.hit(x,y)){res = s;}}
    return res; 
  }
  
Note: that routine will return a null if nothing was hit, and also note that it returns the LAST thing on the list that was hit. This is not accidental behavior it is proper. We are drawing our squares in list order. This means that a later square can cover up a previous one on that list. We do NOT want to bail out of the for loop the first time we see a hit. That would make the user select the underneath box rather then the topmost one that they clicked on. Selecting the last one matches the drawing order. An alternate way to do this this same thing (pointed out by one of my students) is to search the list in reverse order. If you do that, then you can bail out as soon as you find the first hit.

Next we create a static V that will hold the mouseDelta and a static boolean to distinguish between our two behaviors, we are either dragging an existing box around OR we are rubberbanding a new box.
  
  private boolean dragging = false;
  private static G.V mouseDelta = new G.V(0,0); // we will overwrite this coordinate in mousePressed.
  
And finally we fix up our two mouse routines so that they do the right thing:

  @Override
  public void mousePressed(MouseEvent me){
    int x = me.getX(), y = me.getY();
    lastSquare = squares.hit(x,y);
    if(lastSquare == null){
      dragging = false; 
      lastSquare = new Square(x,y);
      squares.add(lastSquare);
    } else {
      dragging = true;
      mouseDelta.set(lastSquare.loc.x - x, lastSquare.loc.y - y); 
      // note if I add dm to mouse I get upper left of rect
    }
    repaint();
  }
  @Override
  public void mouseDragged(MouseEvent me){
    int x = me.getX(), y = me.getY();
    if(dragging){
      lastSquare.moveTo(x + mouseDelta.x, y + mouseDelta.y);
    }else{
      lastSquare.resize(x,y);
    }
    repaint();
  }
  
Check it out!
::S Sidebar: Splines
==Splines
This section is a sidebar. It does not present something that we will need later in this course so you can skip this section if you wish. 

I have a section at the back of the book, the appendix, describing splines, a way to draw curves. We will not need them in this course. BUT if you want to see what they look like, it turns out that this squares app has all the right stuff (except for the spline code) to be a demo for splines. 

Splines basically draw a curve from point A to point C using an intermediate point B to control how much bend there is in the curve. The way that you demo a spline is you need 3 handles that you can drag around on the screen to move the 3 dots that make up the spline.

Well we just built an app where you can create 3 squares, size them to be about as big as handles, and then drag them around on the screen. As soon as you have 3 on the list of squares, you COULD be drawing a spline. Cool!

As I said, if you want to know why splines work you can look at the section in the back, but if you just want to see the demo now, Here are the mods you can make to Squares to see a spline.

First add spline drawing function to your G class.

  // parabolic spline
  public static void spline(Graphics g, int ax, int ay, int bx, int by, int cx, int cy, int n){
    if(n==0){g.drawLine(ax, ay, cx, cy); return;}
    int abx = (ax + bx)/2, aby =(ay + by)/2;
    int bcx = (bx + cx)/2, bcy =(by + cy)/2;
    int abcx = (abx + bcx)/2, abcy =(aby + bcy)/2;
    spline(g,ax,ay,abx,aby,abcx,abcy,n-1);
    spline(g,abcx,abcy,bcx,bcy,cx,cy,n-1);
  }

Second, add a flag to the Squares class so that we and turn on or turn off the display of Splines.

  public static boolean showSpline = true;

Finally, write the code to detect if the list has the required 3 points, and if so, fetch out the first 3 points and pass them to the spline routine. This code goes into paintComponent.

  if(showSpline && squares.size() >2){
    g.setColor(Color.BLACK);
    G.V  a=squares.get(0).loc, b=squares.get(1).loc, c=squares.get(2).loc; // unpack coords
    G.spline(g,a.x, a.y, b.x, b.y, c.x, c.y, 4);
  }
 
Draw 3 boxes on the screen, drag them around and look at how the spline changes.
 
Remember to turn OFF the drawing of splines when you are done playing for the next section.

::S Animation
==Animation

I will NOT be doing much of anything with animation in this course. However there are always people that primarily want to write video games and it seems wrong to be RIGHT at the place where I can show them how to do it and then NOT SHOW THEM! So this section like the one on splines is essentially a sidebar - I will show you the basic extra stuff for doing some animation and then you can either entirly forget it OR you can finally start your life's work as a computer animator.

Since animation is NOTHING other than showing one picture after another so rapidly that the eye blends them toghther and thinks that it is seeing continuous motion all you need to do is draw a picture, show it to the screen, then draw another slightly different picture and show it and then draw another ...

This infinite loop, is the animation loop. You need code that will calculate what the next frame will look like, i.e. claculate all the slightly new positions that things will be located at as they move from frame to frame AND you will need a Timer that will call your function to do those updates and to repaint your screen.

I am going to come at this animation in a couple of steps. First I am going to add a random velocity vector to each square. 

Basically to move a point at a constant velocity from one frame to the next you create a "velocity vector", dv, which is the distance in x and y that the point moves from one frame to the next. So if your velocity vector is (2,3) and You started a point at 100,100 then at the next frame it moves to 102,103 and at the next frame it moves to 104,106 then 106,109 and so on. This means that we will need to ADD velocity vectors to location vectors - so be sure that you included this function to the G.V class so that we can do vector addition:

  public void add(V v){x += v.x; y += v.y;} 

Rather than have a split between the code that UPDATES the position of all elements from the code that DRAWS all the elements. I will just do the update as a SIDE EFFECT of drawing a Square. Thus paintComponent which DRAWS the full list of square, both DRAWS them AND MOVES them.

We will skip the timer for just a moment because we already know a simple way that we, as a user, can force a call to paintComponent - we just grab the lower corner of the window and shake it to resize the window. (This is just the poor man's animation timer! And it is also the reason that I use what is technically a bad structure - making motion a side effect of drawing - it means that by forcing drawing, which is easy, I can force frames. Bad structure BUT it make debugging your animation easy.)

So modify the Square class to add an additional field right after its color.

  public G.V dv = new G.V(G.rnd(20)-10, G.rnd(20)-10); // random velocity between -10 and 10 in both x and y
  
And modify the draw routine so that it both draws the square and moves the location. I put this line into the Squares class so that a square could draw itself

-- add to Square
  public void draw(Graphics g){fill(g,c); loc.add(dv);}
  
and then updated the draw routine in the List class to call Square draw:

-- add to List
  public void draw(Graphics g){for(Square s : this){s.draw(g);}}

Stylistically, I should have done this earlier, when I first put a draw routine into list. Squares DO have an onscreen look, you SHOULD have a draw rouine in the Square class so that a square could draw itself. And the list class should have asked the square to draw itself instead of invoking a function down in the VS class.
  
Check it out! Notice that just as you would expect, each time you add a new square all the previous ones move, because you are forcing a repaint. Also notice that since we never limited the locations of the squares they will all eventually fly off screen never to be seen again (well actually, due to the limits of your integer size eventually the coordinates will wrap from positive 2 billion to negative 2 billion and will POSSIBLY eventually get back into the range where they would show up briefly on your screen.)

So our next step is to show you how to make things bounce. It is not difficult, it just means occasionally flipping the sign of a component of your velocity vector.

If you notice that the loc.x for your square is now less than the minimum coordiante for your screen (which is zero) AND if your dv.x was negative, it was that negative value of your x velocity that drove you into the left wall and when you bounced, your x velocity vectory should now be positive making you increase continually increase instead of decreasing. Likewise for your Right margin and likewise for your y values.

--in Squares add moveAndBounce
  public void moveAndBounce(){
    loc.add(dv);
    if(loc.x < 0 && dv.x <0){dv.x = - dv.x;}
    if(loc.x > 1000 && dv.x >0){dv.x = - dv.x;}
    if(loc.y < 0 && dv.y <0){dv.y = - dv.y;}
    if(loc.y > 800 && dv.y >0){dv.y = - dv.y;}
  }

And of course, you now need to modify the draw routine so that it calls that moveAndBounce() routine.

--in Squares modify draw()
  public void draw(Graphics g){fill(g,c); moveAndBounce();} 
  
Check it out! Notice: If you are quick, you can still resize squares that you draw - the trouble being that your drag code, that was supposed to be rubberbanding your rectangle, is calling paintComponent over and over and thus continually moving the rectangle. Also notice, in our bounce code we are testing for when the UPPER-LEFT corner hits the wall NOT when the appropriate side of the rectangle hits the wall. It is of course an easy calculation to add the size vlaue to the loc value when necessary to fix this calculation and we will do that, BUT we will fix it in the VS class rather than in this Bounce code. The reason is simple: we will be working with these VS rectangles alot and we will often want to know where several other coordinates are as well. I have found it convenient to know 6 values, the lo, mid, and hi values of both x and y. So here are the helper functions to add to G.

  public int xL(){return loc.x;}
  public int xH(){return loc.x + size.x;}
  public int xM(){return (loc.x + loc.x + size.x)/2;}
  public int yL(){return loc.y;}
  public int yH(){return loc.y + size.y;}
  public int yM(){return (loc.y + loc.y + size.y)/2;}


And with those installed we can fix moveAndBounce:

  public void moveAndBounce(){
    loc.add(dv);
    if(xL() < 0 && dv.x <0){dv.x = - dv.x;}
    if(xH() > 1000 && dv.x >0){dv.x = - dv.x;}
    if(yL() < 0 && dv.y <0){dv.y = - dv.y;}
    if(yH() > 700 && dv.y >0){dv.y = - dv.y;}
  }
  
Check it out! If you quickly drag out a BIG box, you should be able to see that it is now bouncing its right hand side off the right hand wall and it bottom side off the bottom of the window.

==Swing.Timer
And now finally, the magic dust, the Timer code that you have been waiting for so that you don't need to shake the window.

Timers are easy. Their constructor requires two arguments. The first is a time interval in thousandths of seconds (aka milliseconds) for how frequently you want to be called. So 1000 means call me each second, 2000 is every 2 seconds, 33 is about 30 frames  a second which will be fine for our tiny little animation example. The second argument is an ActionListener.

WHAT? What is an ActionListener? An ActionListener is anything that implements the ActionListener interface which consists of a single function void actionPerformed(ActionEvent ae). So you need to tell the Timer at the time you construct it which object is going to sit around and wait around for the actionPerformed call.

Well in our case, since what we want to do is repaint the screen, it should be our Window object which is the single Squares object that we created in our main routine. This means that we need to make our Squares class into an Action Listener

  public class Squares extends WinApp implements ActionListener{
  
Then we create the actionPerformed function

  public void actionPerformed(ActionEvent ae){repaint();}
  
And we will want a place that can hold the timer. We will just put the timer into a static variable in the Squares class since we will only need one Timer. Then we will modify the constructor of the Squares class to both create and initialize that timer. Oh, Important point, we are talking Swing Timers here not java.util Timer. Make sure that you import the correct class!

  public static Timer timer;
  public Squares(){
    super("Squares", 1000, 800);
    timer = new Timer(30,this);
    timer.setInitialDelay(5000); // I give myself 5 seconds before the timer starts
    timer.start(); // start the timer
  }
 
Now you should have squares flying around on the screen. Pretty cool!

==Game: Stop the Squares

Actually, we might as well finish. We have nearly enough for a game right here.

We already have code that lets us drag a square around. On mouse pressed if we clicked on a square we put in into the lastSquare variable. Let us just set the velocity for that square to zero. Thus clicking on a square stops it. 

Let us create a static variable to track where the mouse was when we clicked it to stop the square

  public static G.V pressedLoc = new G.V(0,0); // we will set this when the mouse is pressed

Now we can modify the dragging case of mouse pressed to record the pressedLoc and to kill the velocity.

  } else {
    dragging = true;
    lastSquare.dv.set(0,0);  // Stop the clicked square
    pressedLoc.set(x,y);   // Record the mouse loc
    mouseDelta.set(lastSquare.loc.x - x, lastSquare.loc.y - y);
  }

And finally we will add a mouseReleased function that looks to see if we had stopped a box and if so, it will start it moving again by setting the velocity to be the difference between where you clicked down to stop the box and where you moved to BEFOR you released it. So if you click down on a box and flick to the right, you will be setting the box from whatever heading it used to be on to now moving to the right.

  @Override
  public void mouseReleased(MouseEvent me){
    if(dragging){
      lastSquare.dv.set(me.getX() - pressedLoc.x, me.getY() - pressedLoc.y);
    }
  }

Your Mission: Create some boxes and then stop them. Be careful. If you flick the mouse too hard when stopping a box you set it flying off in a different direction. If you miss the box that you were trying to stop you will have just created a new box moving is some other direction. Good Luck!

Games are like so cool. Who wouldn't want to be a computer animator and spent all their time writing and playing games? Why am I teaching this course? I could, like, start a game company - Oh wait, I did that already. Sold it.

Sorry, I got carried away, that is enough animation for this course.
 
::S UC and I
==UC and I

This next section is about a couple of name-convention tricks that I use to deal the complexity of mid-sized projects with dozens or hundreds of classes. I have found them convenient and I will use them in this project.

They serve two different purposes but they are based on the same basic organization principle, namely collecting several different things into a single file.

==I

I keep all my interfaces as static nested interfaces inside a single interface named I. The outer interface I does nothing except change the names of all my nested interfaces. So if I need three interfaces, React, Hit, Draw, I will create them like this:

  public interface I{
    public interface Draw{ public void draw(Graphics g);}
    public interface Hit{ public boolean hit(int x, int y);}
    public interface React{ 
      public int bid(Gesture g);
      public void doit(Gesture g);
    }
  } 
 
I collect my interfaces together for 2 reasons. First, there is now only one single place where I go to look at all my interfaces. Secondly and more importantly, it gives my interfaces all a distinctive name. The interfaces like Hit and Draw that I defined above, because they are nested, actually have full names I.Hit, and I.Draw - This makes it clear that they are all interfaces and it allows me to do things like this:

  public class Foo implements I.Foo{...}
  
Where I build a single class Foo that does what I want by implementing the interface I.Foo - I find this to be a better naming convention than the sort of thing that shows up in the Java libraries where you have an interface like MouseListener and a class that implements that interface like MouseAdapter.

I don't claim that this convention is useful for monster sized projects that may have hundreds of interfaces but I have found it useful in the past for my mid-scale projects and we will use this convention in this project - so you can go build I.java now. 

--create interface I in the music package

==Universal Constants

In a very similar manner to the trick of collecting all my interfaces into a single file, I do the same thing with most of my static constants which are generally used to hold Magic Numbers.

In most of the projects that you have built previously you have probably been taught to eliminate magic numbers by declaring them as final static values in the class that needs them. So if you have some Buffer class and you have some standard size that you use to allocate your arrays you might have:
  
  public class Buffer{
    public static final int SIZE = 1000;
    public int[] buffer = new int[SIZE];
    ...
    
This is all well and good, but there is an organizational problem with this simple design. The problem is that some day someone from marketing will come tell you that you need to build a User Interface for a control panel so that the user can get in and change those default colors. They want the background color for the windows to be Green instead of White, and they want their buffers to be a little smaller like 500, and "we should let the user get in an customize everything! Oh and they will need meaningfull names that they can understand from their viewpoint as a user of the product not the technical name that you understand as an engineer"

That is when you realize that you have hundreds of little names for magic numbers scattered across dozens of classes and it will be a royal pain to locate them all and build some system that allows you to change them all. SO our trick here is to anticipate that we will get asked to do something like this one and to collect all our magic numbers into one single place.

I generally name that class that will hold all of my magic numbers, UC, which stands for UniversalConstants. And because it is a stand alone class I get to use double name if I want. Here is what I mean:

In the class US I typically define things using rather long names - those are the user friendly name, the names that work from a GLOBAL perspective. This is useful for maintainence and it deals with the fact that when I collect all the names acrosss the entire project into one single UC file I have a big name space where I MUST think of global meanings. Then in my individual classes like Buffer, I can essentially use a smaller more suscinct engineering name if I want to.

So I may have this in UC

  public static final defaultBufferSize = 1000;
  public static final dictionarySize = 20000;
  public static Color mainWindowBackgroundColor = Color.White;
  public static Color dialogBackgroundColor = new Color(0,0,10); // light blue
  
Then over in my classes I can do things like this:

  // in my Buffer class
  public static final int MAX = UC.defaultBufferSize; // <-- inside this class I can use the name MAX
  public int[] buffer = new int[MAX]; 
  static{for(int i = 0; i<MAX; i++){buffer[i] = UC.bufferInitializationValue;}}
  // in my MainWindo class
  public static final Color BG = UC.mainWindowBackgroundColor;
  // in my dialog class
  public static final Color BG = UC.dialogBackgroundColor;
  // and of course, if you DON'T want a different short name in your class you can always use UC directly
  g.setColor(UC.dialogBackgroundColor); //<-- the UC class just gives you the OPTION to rename.
  
This design allow me to 1) collect my magic number into one place, 2) modify any of them in that one place. 3) think of my names GLOBALLY in a way that makes sense for the entire project when I define them in UC and yet 4) have names that make sense locally within the scope of a class. 

There is of coure NO NEED to do ANY this, I have just found it a usful notion for the projects that I tend to build. This is the reaon that I have NOT cleaned up my magic numbers so far. I made my window 1000 by 800 because I had NOT built my UC class yet. Now that you know this trick it is time to clean that up. Put UC all the way up in the marlin package and start defining your constants there.

  public class UC{
    // -- ints --
    public static final int mainWindowWidth = 1000;
    public static final int mainWindowHeight = 800;
  }  

::S Areas
==Areas

For this next section we are going to do a bit of refactoring that will be more useful later on when we get to gesture recognition than it will be right now, but I can already see the need for it in the Squares application.

I hope you noticed the difference between our mouse pressed and dragged routines when we were doing Paint versus doing Squares. In Paint, we did ONE SINGLE THING on mouse down, we drew a new line. As a result both the pressed code and the dragged code were very simple, a line or two to add a point to a growing line. However in Squares, we had to detect whether we had clicked on an existing square or on white space and had TWO completely different behaviors depending on whether we were dragging an existing square or creating a new one. We had to set a boolean, dragging, in pressed, test it in mouseDragged and suddenly our code ballooned up to half a dozen lines of code.

This is not a big problem, YET, but imagine if you wanted to have an app where instead of just two behaviors you needed to do three or five. The code would quickly become unmanagable. When we get to our gesture based music notation editor we will probably have at least 3 different behaviors: 

1) we will want to do gestures. These should leave ink on the screen while we are dragging, but as soon as you let up, that gesture gets recognized,and the trace on the screen is removed - it was just there so the user could see the gesture while they were making it. 

2) there will be times when what we draw on the screen is genuine ink - the user is just scribbling something on some part of the music score. In that case we will still want the ink showing up during the draw just like in the gestures, BUT on release instead of recognizing a gesture we will want to actually save an ink ojbect to leave the ink on the screen. 

3) there will be times when we want to drage a handle to adjust some parameter, like resizing something. In those cases we do NOT want to have ink showing up on the screen as we drag some handle back and forth. 

4) We will probably want to have buttons that you can click on to fire up an activity that also should NOT be leaving ink on the screen as you drag them (and buttons probably shouldn't drag either - typical button activity on a drag is to NOT fire the button on mousePress but on mouseRelease. This allows you to click down on a button, and while still holding it down drag it off so you can realase while not on the button if you change your mind. Buttons typically only fire if you both went down on the button and released on the button.

For our improved design we will use the following model. The screen will be covered with rectangular Areas. On the first mouse down, we will run that list of areas, find out which one was hit and make that one our current area. That Area will then hold the behavior of how to interact for the initial mousePressed, for all the dragged events and for the final release. So an Area will be something that implements this interface:
 
--add to I
  public interface Area{
    public boolean hit(int x, int y);
    public void dn(int x, int y);
    public void drag(int x, int y);
    public void up(int x, int y);
  }

Once we get to the the music application that list of areas will actually be fairly small. Basically the entire screen will be a single gesture recognition area so that list will often consist of but a single element. However we will then have the option of sprinkling on top of that single gesture area a few small handles or possibly some buttons and thus giving us a screen where we can mostly just do gestures BUT it will let us click on buttons and drag on handles easily.

==Adding Areas to our Squares App

I want to go back to our squares app the way is was before we added all that animation. I suppose I should have saved a copy before I hacked it up, but I didn't. So I am just going to effectively shut off the motion by changing the one line where we assigned random velocity to the squares and set them all to zero velocity and commenting out the mouse release code that was changing the velocity. Suddenly everything stops moving. True, we are still in an animation loop but it sure looks like a static picture.

  //public G.V dv = new G.V(G.rnd(20)-10, G.rnd(20)-10);
  public G.V dv = new G.V(0,0); // stop the motion!
  
In our Squares app we have two behaviors that we want to encode as Areas. The dragging of an existing box becomes one behavior, and since that is triggerd by clicking on the square, we can just make each Square into an Area i.e. class Square will implement I.Area. We will also need another Area to represent the act of creating and rubberbanding a square. Rather than build another Area class to do that I will just create a single square and use an anonymous class to be the Background Area. I know, this may be new to you, that's OK I will show you how. 

Let us first make our squares into Areas. 

--add implement I.Area
  public static class Square extends G.VS implements I.Area{

As soon as you add that line, the IDE whines that you did not implemen the required functions. Go ahead and let it implement them for you. That will just add place hoilders for the functions. It will add:

  @Override
  public void dn(int x, int y){}
  @Override
  public void drag(int x, int y){}
  @Override
  public void up(int x, int y){}


We will come back an fill in those functions later.

Now that squares are Areas, we can simplify our mousePressed() and mouseDragged functions so comment out the old ones so that you can remember what you used to dp and replace them with this:

--in Squares modify mousePressed and mouseDragged
  public static I.Area curArea; // set by mousePressed()
  @Override
  public void mousePressed(MouseEvent me){
    int x = me.getX(); int y = me.getY();
    curArea = squares.hit(x,y); // should always succeed because of BACKGROUND
    curArea.dn(x,y);
    repaint();
  }
  @Override
  public void mouseDragged(MouseEvent me){
    curArea.drag(me.getX(), me.getY());
    repaint(); // notice: I repaint here in Squares NOT in each little Area  
  }

Next, we want to fix the List class so that it starts out with a special single special square named BACKGROUND. Let us first build that special square in the square class:

--in Square add
  public static Square BACKGROUND = new Square(){
    public void dn(){}
    public void drag(){}
    public void up(){}
  };
  
  private Square(){ // special constructor for BACKGROUND
    super(0,0,3000,3000); c = Color.WHITE;
  }

I have also not yet filled in the dn, drag, and up routines for our special BACKGROUND square. I will do that in a moment. 

We need to make sure that ALL Square Lists start with a copy of the BACKGROUND Square. 

--add a constructor to list
  public List(){super(); add(Square.BACKGROUND);}

I want you to first see what an anonymous class is. 

==Anonymous Class

Normally, I create a class Square by calling new on a constructor. Since the background do NOT have random color and has a special location and size, I built a second constructor that I can use only to create a background square. 

Java allows you to have several functions, including constructors, that all have the same name as long as the parameter types in those copies are different. The original constructor took two ints, this one has none so they are different. That is how java knows which one you want. new Square(3,4) calls our first constructor because it has two ints. new Square() calls the second because it has NO ints. (and new Square("Hello") is an error because java needs to fins a constructor that wants a single String parameter and you haven't yet built one of those!)

In that line where we called that special constructor, we did NOT immediately end the line with a semi-colon right after the function call. Instead we put ins a block with braces. That is the anonymous class part. 

Normally when construcing an object you would just call "new Square();"" - with semi-colon immediately follows the constructor call. When you do that, you just get a new Sqwuare that works like any other Square. 

HOWEVER, if immediately after the constructor call you put in some braces - you can override any of the normal Square functions with special ones just for this object. This is an anonymous class. You are basically saying, "hey, I need a class that extends my old class Square and it overrides these function - but I don't need to give that class a name because I am only using it once, right here for this one single object, a class with no name - it is just an object, a single Square with these special functions."

So most Squares will use the dn, up, and drag that you define in the Square class but this one BACKGROUND square uses the functions that are defined in the block right after you created that background square.

At this point we now have TWO sets of dn, drag, up Area functions that we need to define. One set is in the base Square class which will be used for square dragging, and the other is in our BCKGROUND square that we use for creating new squares. And the code that we need for those is that code that used to be in those two parts of our formaer mousePressed and mouseDragged routines.

Here are the two definitions:
--in our BACKGROUND Square:
  public void dn(int x, int y){lastSquare = new Square(x,y); squares.add(lastSquare);}
  public void drag(int x, int y){lastSquare.resize(x,y);}

Note: we do not need to implement up() for the background square. We don't do anything on up, either for normal squares or the background. The normal squares must define it because it IS required by the interface, but the anonymous class inherits everything in the normal class and we only needed to modify/override dn() and draw()  

--in the Square class 
  // Squares already implement hit so we need 3 more routines.
  public void dn(int x, int y){mouseDelta.set(loc.x - x, loc.y - y);} // calculate drag offset
  public void drag(int x, int y){loc.set(mouseDelta.x + x, mouseDelta.y + y);}
  public void up(int x, int y){}
  
With these changes in place, Squares looks exactly like it did before we added the animation. You can rubberband new squares and you can drag old squares. 

Conclusions: 

One of the primary thing that you get from objects is that because objects can have different code attached to them, they can behave differently. As a result different classes of objects can often be used to REMOVE IF statements that are testing which branch of the code you are on and what behavior you need. We did that in this case by effectively creating two I.Area classes, one of them, the default one, is for dragging squares, the other one, which we only needed in one single place so we did it anonomously, is for rubberbanding. With these two classes, we were able to eliminate the conditional branching from our mousePressed and mouseDragged routines.

Note: that we did NOT reduce the amount of lines of code. If anything the class is now longer than it was. It is more complex because we now have extra interfaces and extra classes BUT we have taken a long chunk of code (8 lines or more with conditional branches in our original mousePressed) and reduced it down to just a couple lines.

The benefit is that now we can read our mousePressed routine. "Oh, just find the Area that you clicked on, make it current, call its pressed routine, and repaint." AND you can see that it will be easier to extend IF we decide that we need to add yet another mouse behavior.

The two new classes that we created are each simpler than our original class because now one class (Square) contains ONLY the code for dragging and the other (our single anonymous override) had ONLY the code for rubberbanding. So we still have ALL the code that we did, but it is now wrapped up in classes instaed of being branches of an if statement. This is what you are tyring to achieve with "Separations of Concerns". Let one class do ONE thing.

It is very hard to see all this in advance of building something. So what you try to do is to notice when you have too many IF statements branching between different behaviors and ask yourself, "Could I simplify this by having those two different behaviors in two different classes."

::S Squares.java
Because we have done a lot of changes, here is a version of Squares.java
==Squares.java
  package sandbox;
  import graphics.I;
  import graphics.WinApp;
  import graphics.G;
  
  import javax.swing.*;
  import java.awt.*;
  import java.awt.event.ActionEvent;
  import java.awt.event.ActionListener;
  import java.awt.event.MouseEvent;
  import java.util.ArrayList;
  
  public class Squares extends WinApp implements ActionListener{
    public static G.VS theVS = new G.VS(100,100,200,300);
    public static Color color = G.rndColor();
    public static Square.List squares = new Square.List();
    private boolean dragging = false;
    private static G.V mouseDelta = new G.V(0,0); // set in mousePressed.
    public static boolean showSpline = true;
    public static Timer timer;
    public static G.V pressedLoc = new G.V(0,0);
      
    public Squares(){
      super("Squares", 1000, 800);
      timer = new Timer(30,this);
      timer.setInitialDelay(5000); // I give myself 5 seconds before the timer starts
      timer.start(); // start the timer
    }
    
    @Override
    public void paintComponent(Graphics g){
      G.fillBack(g);
      squares.draw(g);
      if(showSpline && squares.size() >2){
        g.setColor(Color.BLACK);
        G.V  a=squares.get(0).loc, b=squares.get(1).loc, c=squares.get(2).loc; // unpack coords
        G.spline(g,a.x, a.y, b.x, b.y, c.x, c.y, 4);
      }
    }
    public static Square lastSquare;
  
    public static I.Area curArea; // set by mousePressed()
    @Override
    public void mousePressed(MouseEvent me){
      int x = me.getX(); int y = me.getY();
      curArea = squares.hit(x,y); // should always succeed because of BACKGROUND
      curArea.dn(x,y);
      repaint();
    }
    @Override
    public void mouseDragged(MouseEvent me){
      curArea.drag(me.getX(), me.getY());
      repaint(); // notice: I repaint here in Squares NOT in each little Area  
    }
    @Override
    public void mouseReleased(MouseEvent me){
      if(dragging){
        lastSquare.dv.set(me.getX() - pressedLoc.x, me.getY() - pressedLoc.y);
      }
    }
    @Override
    public void actionPerformed(ActionEvent ae){repaint();}
    public static void main(String[] args){PANEL=new Squares();WinApp.launch();}
  
    //-----------------Square------------------------------
    public static class Square extends G.VS implements I.Area{
      public static Square BACKGROUND = new Square(){ // create and size square
        public void dn(int x, int y){lastSquare = new Square(x,y); squares.add(lastSquare);}
        public void drag(int x, int y){lastSquare.resize(x,y);}
      };
  
      public Color c = G.rndColor();
        // dv = random velocity between -10 and 10 in both x and y
      //public G.V dv = new G.V(G.rnd(20)-10, G.rnd(20)-10);
      public G.V dv = new G.V(0,0);
        
      private Square(){ // special constructor for BACKGROUND
        super(0,0,3000,3000); c = Color.WHITE;
      }  
      public Square(int x, int y){super(x,y,100,100);}
      
      public void resize(int x, int y){
        if(x>loc.x && y>loc.y){size.set(x - loc.x, y - loc.y);}
      }
      public void moveTo(int x, int y){loc.set(x,y);}
      public void draw(Graphics g){fill(g,c); moveAndBounce();}
      public void moveAndBounce(){
        loc.add(dv);
        if(xL() < 0 && dv.x <0){dv.x = - dv.x;}
        if(xH() > 1000 && dv.x >0){dv.x = - dv.x;}
        if(yL() < 0 && dv.y <0){dv.y = - dv.y;}
        if(yH() > 700 && dv.y >0){dv.y = - dv.y;}
      }
  
      @Override  // required by I.Area
      public void dn(int x, int y){mouseDelta.set(loc.x - x, loc.y - y);} // calculate drag offset
      public void drag(int x, int y){loc.set(mouseDelta.x + x, mouseDelta.y + y);}
      public void up(int x, int y){}
  
      //------------------List----------------------------
      public static class List extends ArrayList<Square>{
        public List(){super(); add(Square.BACKGROUND);}
          
        public void draw(Graphics g){for(Square s : this){s.draw(g);}}
        public void addNew(int x, int y){add(new Square(x,y));}
        public Square hit(int x, int y){ // can return null
          Square res = null;
          for(Square s: this){if(s.hit(x,y)){res = s;}}
          return res;
        }
      }
    }
  }
  
::C Reaction Architecture
::S History
--Day 4

I believe that we now have enough background to start on our main project for this mid level java course, the Gesture based Music Notation application. That last section that I showed you on I.Area was really done to manage some of the complexity that we will run into in our Music App and the next classes that we build have even more to do with it. I could just continue to work bottom up, introducing helper functions and classes, "Hey look at this neat thing that you can do," without telling you why we are building those helpers and What exactly they are going to help with. 

However, there really is an overreaching architecture that we are trying to build and you will probably have a better understanding of WHY we are building the helpers that we construct if you have some idea of where we are heading so the few sections of this book are less code and more historical in nature telling you how some of the ideas for this Reaction Architecture evolved. So this next chapter is not code, but an outline of what we are trying to build for our main project. 

==Gesture Applications

Way back in 1990 I was the manager of a group at Microsoft that was working on software for tablet machines. This was a type of machine that no one was making at the time but which people were predicting would be all over the place in a few years. The key feature of a tablet machine was that it would have no keyboard at all and you would do all your entry by either using a stylus or by touching the screen.

It is almost impossible for anyone alive today looking at all the current smart phones and tablets to understand that while these types of machines are legion today that there were practically no such machines back in 1990. Tablet machines were imagined but few were built and of the few that were built even fewer were sold. The excitement of 1990 was mostly gone by 1992 when the market didn't rapidly develop. Everyone that had been in that industry scaled back their development efforts.

None the less back in those early days, when we were thinking about how application interfaces would change when you have keyboard-less tablet machines, I developed the notion of 2D parsing. This was nothing other than a name that I had for a technology that I believed COULD be built though I had no idea of how to build it.

It occurred to me that there are many diagrammatic languages, things like math notation, music notation, architectural floor plans, flow charts, blue prints, electrical circuit diagrams, chemistry formulae - all things that are not particularly easy to input on a machine with a keyboard because they are primarily graphical (i.e. 2 dimensional) in nature. While these are hard to input with a keyboard, they can be fairly easy to scribble down on a napkin or a sheet of paper. What was needed was a way to recognize what you were doing when you drew a circuit diagram. You needed to recognize that this line was a way of connecting this point to that point and that this zig-zag line meant that you wanted a resistor here and so on. 

"Parsing" is the name of the step that you perform in a normal compiled computer language when you recognize the chunks of text that show up in source code for what they are: "Oh, that is a variable name, and this is an assignment statement, so that must be a function call." Parsing, as it is normally defined, is something that is done on a one dimensional stream of text, one character after another. I wanted to do the same sort of thing except that in a diagrammatic language you don't have that convenient feature of the one dimensional order of the characters. You might draw this something up here and then something else down there and then much later connect that upper thing to that lower thing. Yes, there is the order that the person drew the strokes but typically the structure of a diagram has nothing what so ever to do with the order that someone drew the components of that diagram.

As I said, back then in 1990 all I had was a name but no real idea of how I would implement any such thing. The idea languished.

Almost 15 years later I once again had a chance to work on some software for a tablet machine. The company had produced a tablet machine for viewing sheet music and had some vague notion that it would be useful if they had some music notation software that would run on that machine. So I resurrected my notion that 2D parsing might be a useful notion and started working on ideas for a gesture based music notation application. That was not my primary job for the company, it was just a project I worked on in the background mostly for my own amusement.

I spent nearly two years trying out ideas and mostly discarding them until one day in 2005 I had an Ah-HA! moment, and saw a clean way to do the 2D parsing that I had wanted to do more than a decade ago. I threw out nearly all the code that I had written in the past two years, started from scratch and in 3 weeks of mad coding had a demo of a music notation app. This was just a demo. It would not Open files or Save files, but you could create complicated musical notation entirely with gestures as desired. However by that time the company's interest in music notation had wained and they were not interested in spending resources to complete the application, so once again development lapsed.

It was five years after building that music notation demo that Apple launched the iPad in 2010, a full two decades after I had first coined the notion of 2D parsing. 5 years after the launch of the iPad, in 2015, I still saw virtually no one building gesture aware applications. I keep waiting for someone else to do this work so that I don't have to publish it myself and it has yet to happen. So I finally gave up and decided that I will just have to explain how it is you can do this.

What we will build in this next project is NOT really a music notation application, or if we do build any music notation, we will build only parts of it, just enough to test/demonstrate the framework for the reaction architecture. This word "framework" is basically what we used to call a "library" though it is typically a little more focused than an entire library. I have mentioned the term "helper function" previously, a short little piece of code that saves you some work and makes it just a little easier to do something. Well, a "framework" is like a helper function on steroids. Instead of one or two helper functions it is dozens or hundreds that make it easier to build something.

There are many frameworks. JQuery is a very popular Javascript framework that helps you create animated web pages. Swing is a framework that helps you build GUI programs. Few people write new computer languages, but lots of people build frameworks these days. The notion of Computer Language Design continues on in the development of frameworks. The framework that we will build to help us build gesture based applications is called the "Reaction Architecture".

Just so you have an idea of the scope of this course before we wade into it is that the framework in an early design had twenty-eight classes. That is 28 classes of helper functions. That is the point of this course, to show you that your mind is not limited to understanding projects that have only one or two classes, you can have dozens or even hundreds of classes and still make sense of it all. In fact from my viewpoint that is the purpose of classes, they are file cabinets to hold and organize your stuff. It is time to look at organization from the standpoint of a system that is large enough that without that organization you would be lost. I can't honestly say that we will build all 28 in this one semester course - we will eventually run out of time. We will probably not finish, however we will build enough of this framwork for you to understand it and to be able to both use it for your own projects and to be able to extend it if you wish.

Just for the record, for those of you that are actually taking my one semester course and not just reading this online, my course meets 4 hours a week for about 10 weeks for a total of 40 hours. Technically that is one single week's work if you had a job (that would be one of those non-existant programming jobs where you only work 40 hour weeks instead of 50 or 60). And it actually took me 3 weeks to build my demo - of course, now that I know what I am doing I can presumably avoid some of the dead ends. So the fact is that everything that we do in this one semester class COULD/SHOULD be done in a single week's work. IMHO It is actually EASIER to write this and get it all working if you do it all in a week instead of stringing it out slowly over 10 weeks. By week 9 you are forgetting decisions that you made in week 2 - "Did class Foo extend Bar or did it just have a bar element in it?". As a manager of software developers I would have NO problem assigning this entire course as a one week project - go read that article, build all the code that they mentioned, and then we can start on the rest of the design.

Now, in this section, I have only mentioned the history of where this framework came from. In the next section I will start explaining what the reaction system will do and give you an idea of how it will do it.

::S Reactions
==The Problem of Context?

One of the problems of any pattern recognition system is to how deal with the problem of context.

Let us consider the music notation input system. Suppose you draw a vertical line. That vertical line has several possible interpretations in a music system. It could be an up-stem on a note head, it could be a down-stem on a note head, it could be a measure bar. Similarly a horizontal line could be a staffline, a ledger line, a beam between two stems, a hyphen in the lyrics, a tie between two note heads. How do you determine the intended meaning?

The basic answer is: context. If your vertical line went from the top line of a staff to the bottom line of a staff that is exactly what a measure bar should do, so it is probably a measure bar. On the other hand, if your vertical line passed exactly to the right of a note head that needed a stem it is probably an up-stem for that note. However, problems remain. What if the stroke doesn't go EXACTLY from top line to bottom line, what does "exactly to the right" mean? Yet another problem is what should you do if both criteria hold? What if the line mostly goes from the top line to a bottom line so it should be a measure bar AND it also goes right by a notehead at the same time and thus should be a stem?

The basic notion is that your context decisions should be done in a probabilistic manner. Instead of just having a simple threshold that returns a boolean, for example "if the top y coordinate of your vertical bar was within 10 pixels of the top line of a staff AND ... THEN it is a Measure bar"; you instead build a distance function (a Metric) that measures how close you are to meeting the conditions. If you meet them perfectly you return 0, if you are close but not exact you return a small number, if you are not close you return a big number, and if you don't like the match at all you return a HUGE number, a NO_BID number. This distance function allows you to easily decide between dueling contexts. "The distance between your vertical input stroke and a perfect measure bar is 17. On the other hand the distance between your input stroke and a perfect up-stem was 29 - clearly the measure bar was the closer interpretation so use that one."

This one simple notion - using a distance metric for all your context evaluation and allowing the best context match to win the rights to interpret the stroke - is the fundamental idea that underlies the reaction architecture. There are of course many other components which we will cover in time but this one is the heart of the matter. So now I will leave the language of a specific music example behind and describe the process again in general terms using the Reaction vocabulary (Some class names and interface names) to describe the architecture.

==Reaction Vocabulary

Let us suppose that the user has already drawn some stuff on the screen leaving it in some partially completed state. There will be some visible stuff on the screen. We will call each visible item a !nMass. In java terms: abstract class Mass implements !nI.Show. Showable items are generally masses. I use the term Mass because I think of the visible items on the screen as being similar to planetary masses complete with gravitational fields. The masses are in some sense contexts that are trying to suck in the user's input strokes - the closer the input gets to a mass the more likely it is that the mass will attract the stroke. The user, who is looking at all those masses on the screen will draw some stroke, a !nGesture, which may be far from any of the masses, it may be related to a single mass, it may be a connection between a pair of masses, it may even just be a single up/down click on a button. The Gesture which the user draws will in general be recognized into a !nShape. Each Mass on the screen will have its own private collection of !nReactions. A reaction object is just something that has a "bid" routine that gets to look at the stroke and bids for how badly it wants to interpret the stroke. (The bids are just those distance functions; zero is a perfect match while larger numbers reflect less interest). All the Masses hang onto Reactions which bid on the input stroke and the winning bid gets to interpret the stroke. Thus a Reaction is something typically owned by a Mass and which implements an !nI.React interface. I.React is nothing other than the two functions, bid(Gesture s) and act(Gesture s).

The !iact routine in a reaction is of course free to do anything it wants but typically it will either add some new Mass to the screen or it may just modify the Mass that owned the Reaction.

If you are familiar with the notion of parsing in a traditional language, parsing is mostly done by having a state machine (that is always in some single state) and when each new character comes in, the parser gets to look at the input character and based on its current state gets to shift to another state. What we are doing here is an extension of that one dimensional notion of parsing to a two dimensional notion. Each different mass is essentially a pile of reactions (those are state transitions that that single mass could possibly perform) that cloud of reactions (possible transition) are are essentially the state of the mass, just hiding behind the scenes and waiting for an input character. When a stroke comes in, every one of those masses on the screen gets a chance to bid for how badly it wants to be the one to consume that stroke input. There will be at most one wining reaction and that is the state transition that will be fired by the input stroke.

Thus from the viewpoint of traditional language parsing, a Reaction object is a state transition that is hanging around invisibly in the background waiting to happen. The only difference is that in traditional parsing, from whatever state you are currently in, there is only one transition that you can take if you see the letter 'a'. In our 2D parser, from the one state you are in (every thing currenly on the screen), there may be several different Reactions hanging around all watching for the letter 'a' and they will bid for the right to be the winning transition.

I think at this point I will just wade into vocabulary, most of which is just names of classes or interfaces because, no surprise, nearly every different thing that we needed to do in the system required some type of object in order to fill that role, so our class names are pretty much an outline of all the roles that need to be filled.

::S Vocabulary
==Interfaces, 4 - I.Act, I.React, I.Show, I.Area
Our reaction system will have several interfaces, and like most interfaces they are so simple I can just show you the code. And yes, you should go ahead add this to your project.

::I java
  public interface I {
    public interface Act{public void act();}
    //public interface React extends Act{public int bid(Gesture g);}
    public interface Show{public void show(Graphics g);}
    public interface Area{ // we've already seen this one
      public boolean hit(int x, int y);
      public void dn(int x, int y);
      public void drag(int x, int y);
      public void up(int x, int y);
    }    
  }
  
I commented out the React interface because it refers to a class, Stroke, that we have not defined yet. With any luck I will remember to tell you to uncomment that line when we finally need it.
  
==Output, 2 classes - Mass, Layer
The output of a typical application can be quite large - think music notation; you have beams, stems, head, accidentals, clefs, staff lines, ledgers, measures, ties, slurs, mordents, guitar chords... the list goes on. But those are all application specific. The framework itself has practically nothing on the output side, just a few helper routines that will be used over and over by any particular application. I already mentioned the main one, the abstract class !bMass which holds reactions. Every one of those music things that I mentioned above probably gets its own class in a music application and since every one of those is something that you would render onto the screen and that would hang onto reactions (for example: you draw a note head on a staff and the staff had a reaction to recognize a note head and put it on the staff. The note head that you just added is a new Mass and does not yet have a stem so it has a cloud of reactions that look for stems being added to the note head). Because every music element renders and hangs onto a cloud of reactions all those music element classes will descend from Mass. And Mass is abstract because a Mass all by itself does not have any idea what it should render. The job of the Mass, the thing that it frees up every single one of those music classes from doing is the business of hanging onto a list of reactions, groveling though that list on every input to see if one of the reactions fires off, etc. Every music element should just inherit all that Reaction management code.

The one other output function that shows up in nearly every GUI application is !bLayers. IF all you are doing is presenting a single thing in black and white, layering is mostly unnecessary. As soon as you introduce color, then you need to deal with the "Painter's Algorithm" also sometimes know as "Z-Ordering" your output. All this means is that you want to paint background objects first and foreground objects later so that the foreground objects appear in front of the background objects. Clearly you can have more than just two layers (in the music app I typically used 4 or 5 - Staff lines in the deep background in grey, things on the staff like note heads in the next layer, things like ties, slurs, hairpins that look like editorial comments on top of the music in layer 3, Genuine user added mark up i.e. scribbling on top of the the page in layer 4 and finally handles and buttons i.e. all user interface controls need to appear in front of even the scribbling that the user did - it is not good to have the button that deletes the user's scribbling hidden underneath all that scribbling.)

==App Level - MusicEd, WinApp, Area, Undo
0. !bMusicEd - the app holds the Undo stack, the list of masses, and the list of Areas
2. !bWinApp - the Swing garbage
2. !bArea - Areas are basically the mouse Listeners, you may need several different kinds.
2. !bUndo - a list of I.Act objects, you can rebuild the entire world by redoing the Undo list
3.

==Shape Recognition - Polyline, BoundingBox, Shape, Gesture
Without going into the details yet of how we do shape recognition, or even what shapes we expect to recognize, we can list the classes that are necessary for collecting the pen input to the screen and which we will recognize into shapes and strokes.

0. !bPL - this is a polyline, just a sequence of xy-coordinates drawn on screen from mouse down to mouse up.
2. !bBBox - A single PL is bounded above, below, left and right. The box tracks those numbers.
2. !bNorm - this is a PL that has been reduced to a normalized coordinate system so that comparison is possible.
2. !bShape - a shape is a concept like the letter 'a' or a 'E-S'. There may be several diffent ways to draw a single shape so it will probably be a list of Norms
2. !bGesture - A Shape is just virtual, normalized coordinates. A Stroke on the other hand is the combination of the shape that was recognized, AND the rectangle that tells you where on the screen and what size it was. So Shapes are theoretical and Stroke are actually located at a place on the screen. It is the difference between "I am thinking of the number 7" - Shape vs. "I want the number 7 written right !ithere in a 12 point font" - Stroke. 
3.

Please note: in this system we have settled on the notion that we will recognize Gestures into Shapes. We do NOT technically recognize characters. The difference is just that some characters like 'x' and 't' require two strokes to draw them. The great bulk of what we want to recognize we can do with single simple strokes so we left it at that rather than do anything special to generalize up to multi-stroke characters. Technically in our system if you wanted to recognize an 'x' you would first recognize a '\' create a Mass that is a backslash, that Mass would create a reaction looking for a forward slash that crossed the existing backslash which could upgrade the backslash to an 'x'. Thus there is nothing that prevents us from recognizing multi stroke characters, but we have done NOTHING in the architecture to make it easy to recognize English text for you. Recognition of text is NOT the application that we are trying to support and it is NOT what this framework was built to do.

We also have the very standard very low level graphics helpers like !bV and !bVS that hold Points (Vectors) or Rectangles (Vector & Size)

::S Recognition
==Shape Recognition
In this system, a gesture is what happens during a single mouse drag. On mouse down we start capturing mouse coordinates, we continue capturing them as the drag happens, and we get our last point when the mouse is let up.

Those coordinates are a Polyline, PL. We take those coordinates and subsample them to a fixed number of coordinates (we used 25 xy pairs) either by throwing out points if there were too many or by duplicating points if there were too few. We did not interpolate between points. Next we scale them to a uniform coordinate system (we used 0 to 1000). That scaling is done isomorphically (meaning that we scale both x and y by the same value).

Once we have sub-sampled and normalized the input, we can compare the input to a list of prototypes (which are also just sub-sampled and normalized input - though we may have blended together several inputs in order to smooth a prototype by averaging). Each prototype is owned by a Shape. So for example one of the Shapes could be a "Circle". You may have several different ways of drawing a circle (for example you could start at the top and go clockwise, start at the bottom and go counter-clockwise, lots of possibilities!) and thus the circle Shape, which is a virtual abstract sort of notion, may have several different prototypes that are specific ways of drawing that particular shape.

When you want to match an input to a prototype, you just compute the Euclidean distance (a metric function) between the two, i.e. root sum of squared differences. (Note, because we only use the distance for comparison we don't actually need to take a square root because root(A) < root(B) only if A < B so it is sufficient to compare the squared distance rather than the actual distance.) The bigger the distance the less the one polyline matches the other.

This matching is known as "Nearest Neighbor Matching" You have a list of prototypes, each of which is classified as being of a given Shape. You find the prototype that is "closest" (in Euclidean distance) to the input shape, that would be the input's nearest neighbor in prototype space, and you declare that the input should be classified as being the same Shape as that matched prototype's Shape.

So the flow of information when we are recognizing gestures looks like this:

1. Ink.BUFFER - capture all xy coordinates from one mouse down to a mouse up.
2. Ink.BUFFER.bbox - compute the bounding box of the ink in the Ink.BUFFER
2. Ink.BUFFER.norm - sub-sample the ink in the buffer down to 25 points and normalize them
2. Go through all the Shapes in the Shape Database find the closest match.
2. Now that you have the recognized shape, create a Gesture(a Stroke) which is a Shape and the VS where it happened.
2. Reactions are classified by the Shape that they are looking for. So there is a Reactions.Map<Shape, ReactionList>
2. run the reactions on the ReactionList and find the winning bidder.
2. call the act() function for the winning bidder.
2. finally, place the Stroke on the Undo stack (so that you can undo/redo that gesture if necessary)
3.

In outline Here are some of the reaction classes, the ones involved with shape recognition, and their memebers

0. !bInk extends Norm - vs  // We normalize our ink but remember where it happend on the screen.
2. !bInk.Buffer extends PL - n, bbox  // we keep an array of points, n is how many, and bbox is the bounds
2. !bNorm extends PL    // a single polyline in the normalized coordinate system
2. !bNorm.List extends ArrayList&lt;Norm&gt;
2. !bShape extends ArrayList&lt;Prototype&gt; - name  // a name like "N-N" and all the ways of drawing that shape 
2. !bShape.Prototype extends Norm - nBlend // a single way of drawing a shape, nBlend is the count of averaging
2. !bStroke extends VS - shape  // a Stoke is WHERE a shape happened on screen
3.

::S Compass Gestures
== Compass Gestures - a set of easy to recognize shapes
One of the things that we learned while working on the handwriting recognition system at Microsoft is that a keyboard is a WONDERFUL input device. When a user types the wrong key and gets the wrong letter they always say to themselves - "oops, I messed up and hit the wrong key." they NEVER appear to say, "Hey, this system is screwed up and didn't recognize what I was typing." On the other hand, when the user gets to handwrite characters and the system gets the wrong result, it is nearly always perceived as a system screw up rather than as user entry error. Basically with stupid devices like keyboards and hammers, a mistake was obviously cockpit error because there was only one intelligent agent in the transaction. However, when a smart AI recognition system becomes involved in the transaction, suddenly mistakes are never the fault of the human; Oh no, it is always the fault of that STUPID AI! It is the job of the UI designer to understand these very human behaviors and build interfaces that live successfully within that context.

One of the ways to help achieve that success is to choose a set of shapes that are easy for the user to draw and that are pretty distinct from one another so that the user can be fairly sure that the system will recognize them with very few mistakes. The Compass Gestures is the set that I came up with that achieves this. Note, there is NOTHING in the code that we will write to recognize shapes that requires that you use compass gestures. If you want to use letters like 'a' and 'e' (or other one stroke characters) in your app, all you will need to do is enter the prototypes for them and there you go. However, I believe that high recognition accuracy is a very important feature and the compass gestures are a way to easily achieve that feature.

The compass gestures are a collection of strokes which land in one of these three categories:

1.Circles, big and small. Big ones are called circles and really small ones are called dots
2.Single straight lines in one of the eight compass directions (N, S, E, W, NW, SW, NE, SE)
2.Idealized V-shapes i.e. a straight line in one compass direction followed immediately by straight line in another compass direction. e.g. the letter 'V' the way that we would normal draw it is = SE-NE or if you draw it backwards it would be SW-NW, the greater than sign, &gt; is typically drawn SE-SW if you draw from the top down (or NE-NW from the bottom up),  the letter 'L' is S-E (or W-N).
3.
For simplicity in naming them, I named all the straight lines in the second category as being V-shapes where the second compass direction just happens to match the first direction, thus my name for a single line N is actually N-N.

Please note that direction IS important in this system. For example a single vertical stroke may be drawn either bottom up (N-N) or top down (S-S). In a similar manner, any distinct visual V-shape will have two differently distinguished drawing methods. Thus when I describe a compass gesture I am NOT describing the visual result, I am actually describing the drawing order. So even though N-N looks the same as S-S the computer can easily tell the different from a stroke that went up versus one that went down.

Since there are eight compass directions and two directions per V-shape there are 8*8 = 64 different V-shapes. If you then add in the dot and the circle, you have a vocabulary of 66 easily distinguishable shapes recognized by this recognizer.

The advantage of this recognizer is that the definition and direction of each shape is unambiguous and while it is possible to get recognition mistakes when you are drawing rapidly, if you are careful, it is almost impossible to make a mistake. Furthermore, you can do the same thing that I have done here, namely give names to the shapes and expect the user to understand what shape you are talking about. Whereas a shape like 'C' you would need to qualify: "Do you mean C drawn from the top down or from the bottom up."

Please note: the compass gestures are not magic. One can get into trouble if one is not careful (When I say, "One", I am talking about your users here). Consider an 'L' shape (Sorry, I mean a S-E shape!) I could draw it symmetrically both legs of the V of equal length. OR I could draw a long down leg and then only a short one going East or alternatively I could have a short down stroke and a long east one. Clearly, at some point our system will fail, that short down - long east V-stroke sure looked a lot like and E-E with maybe a little hook at the start. If your users do not Train the system with prototypes that hold the genuine variance with which they draw S-E, the system won't recognize a ShortS-LongE stroke very well and if they do train in a lot of those, then they may start to have problems recognizing a genuine E-E stroke. Training your users to do the right thing is a problem that all application developers must live with. I can't assure you that I know how to do that, what I can assure you is that I have almost no problems recognizing my compass gestures because I do understand how this system works and I don't try to train it to do impossible recognition tasks. 

==The Necessity of Undo
I do have a last comment on the Compass Gestures but it is really a comment on the necessity of UNDO in a recognition based system.

Recognition based systems are never 100% accurate and thus in addition to user mistakes (which are mostly rare) you will have some recognition mistakes (which when properly designed are also rare BUT which are unfortunately EXTREMELY ANNOYING to users). It MUST be very easy to undo both of these types of mistakes. I mean, let's face facts, the second most commonly pressed key on a keyboard after space is BackSpace, the "oops I need to undo the last char typed" button. Undo is just a property of good UI design, not some peculiarity of recognition systems.

However, in a gesture based system, you will most likely be performing that Undo action as a result of a gesture itself - WOE BE UNTO YOU if you design your system in such a way that you occasionally make recognition mistakes on that Undo gesture itself! 

It is !bSTRONGLY recommended that you reserve one single unambiguous easy to recognize shape, like a single upward stroke performed anywhere on the screen, and then EXCLUSIVELY reserve that shape as the undo gesture. Don't screw up Undo! 

In my music system I used N-N, the un-natural upward stroke, for this purpose and I would recommend using that stroke for ANY system. The N-N stroke has the nice feature that it is an un-natural stroke in any normal pen or pencil writing system because regardless of whether you are left or right handed, pulling a stylus down on paper is generally easier than pushing it upwards. As a result there is very little conflict between that single upward stroke and any natural writing system.
 

::C Recognition Subsystem
::S PaintInk
==PaintInk

We could just hack up our old Paint program thus obliterating what we have done so far in this class OR we could write it again from scratch to use more of our architectural components like I.Area and the Ink class that we are about to build. Let us be safe and move on to a new class, PaintInk. Build this class and don't forget to modify your main so that it will create a new PaintInk rather than a new Squares.

PaintInk is going to be our test harness as we build several of the little G components that we need, namely BBox and PL. We will evolve the Ink class at the same time to hold those paths. 

  package sandbox;
  import graphics.*;
  import java.awt.*;
  
  public class PaintInk extends WinApp{
    public PaintInk(){
      super("Paint Ink", UC.mainWindowWidth, UC.mainWindowHeight);
    }
    @Override
    public void paintComponent(Graphics g){
      G.fillBackground(g, Color.WHITE);
      g.setColor(Color.red); g.fillRect(100,100,100,100); // the graphics equivalent of "Hello World"
    }
  
    public static void main(String[] args){PANEL=new PaintInk();WinApp.launch();}
  }
  
Run it to verify that you are properly connected.

Now build the Ink class. Put it in the reaction package. This class is a place holder for what we want to build, but eventually Ink will be a class that will keep a list of ink objects that we can show out to the screen. and we will modify our PaintInk to keep a list and show it to the screen.

  package reaction;
  import graphics.*;
  import java.awt.*;
  import java.util.ArrayList;
    
  public class Ink implements I.Show{
    public void show(Graphics g){ // STUB
      g.setColor(Color.red); g.drawString("STUB- ink.show()",100,100);
    }
  
    //---------------------------List----------------------------------
    public static class List extends ArrayList<Ink> implements I.Show{
      public void show(Graphics g){for(Ink ink : this){ink.show(g);}}
    }
  }
 
Next we modify PaintInk to have a staic variable that is an InkList, a static block to 

  public static Ink.List inkList = new Ink.List();
  static {inkList.add(new Ink());} // add one single ink item so we can test showing a list
  
Finally we modify paint component to show our ink list (and remove the fillRect call which is now over in PaintInk

   public void paintComponent(Graphics g){
    G.fillBack(g);
    inkList.show(g);
  }

We won't see anything if we run that since the inkList is empty. We can test that it works though by adding a line in the PaintTest constructor to shove one new Ink onto the inkList.

  inkList.add(new Ink());

Test it and then remove that line.

==Ink.Buffer
We will want an Ink.Buffer class to hold the mouse trace as the user draws. That will be an extension of PL, which will our helper in G for polylines so we need to go build that first over in G

  public static class PL { // Polyline
    public V[] points;  // we keep an array of points
    public PL(int count){  
      points = new V[count]; // allocate the array 
      for(int i = 0; i < count; i++) { points[i] = new V(0, 0); } // populate it with V objects
    }
    public int size(){return points.length;}
    public void drawN(Graphics g, int n){  // used to draw an initial portion of the full array
      for(int i = 1; i < n; i++) {
        g.drawLine(points[i - 1].x, points[i - 1].y, points[i].x, points[i].y);
      }
    }
    public void draw(Graphics g){drawN(g, points.length);} // draws the whole array.
  }

Now with that class we can build our Ink.Buffer class

  //----------------------------Ink.Buffer----------------------------
  public static class Buffer extends G.PL implements I.Show, I.Area{
    public static final int MAX = UC.inkBufferMax; // maximum size of buffer
    public int n; // how many points are actually in the buffer.
    private Buffer(){super(MAX);} // create the PL with MAX points
    public void add(int x, int y){if(n<MAX){points[n].set(x,y); n++;}} // adds new point to buffer
    public void clear(){n = 0;} 
    public void show(Graphics g){this.drawN(g, n);} // Only draw existing points
    public boolean hit(int x, int y){return true;} // any point COULD go into ink
    public void dn(int x, int y){clear(); add(x,y);} // add first point
    public void drag(int x, int y){add(x,y);} // add each point as it comes in
    public void up(int x, int y){add(x,y);}
  }

We will need to define inkBufferMax in UC. I think 500 should be good enough.
  public static final int inkBufferMax = 500;  

Note: we have made our buffer showable. It just draws out the n points that are in the buffer, and it was for this purpose that we put that drawN function into PL.

We have also make the buffer implement I.Area. So when we want an area that collects ink, we can just ask the Ink.BUFFER to do that.

We made our Buffer constructor private. This is almost always an indication that we have a singlton - and that is true. We do not want other classes createing Ink.Buffers. The Ink class will create only one of these which it will keep as a static member. And we might as well make Ink a little more like the Ink that we want - we will make it an extension of PL and we will make the ink constructor copy the points from the BUFFER:
  
  public class Ink extends G.PL implements I.Show{
    public static Buffer BUFFER = new Buffer();
    public Ink(){
      super(BUFFER.n); // allocate a PL large enough to hold the n points in the buffer
      for(int i = 0; i<BUFFER.n; i++){points[i] = new G.V(BUFFER.points[i]);}
    }
    public void show(Graphics g){g.setColor(UC.inkColor); this.draw(g);}
    
Note: We need to create a second G.V constructor that will make a new V which is a copy of the values in an existing V so that the above for loop will work.

--add to G.V
    public V(V v){x = v.x; y = v.y;} // copy existing V

Lastly - We need to fix up our app, PaintInk. We want it to show not only the inkList but also the Ink.BUFFER as we draw into it. And we need to connect the mouse routines in the App to those over in the buffer.


  public void paintComponent(Graphics g){
    G.fillBack(g);
    inkList.show(g);
    g.setColor(Color.RED); Ink.BUFFER.show(g);
  }
  
  public void mousePressed(MouseEvent me){Ink.BUFFER.dn(me.getX(),me.getY()); repaint();}
  public void mouseDragged(MouseEvent me){Ink.BUFFER.drag(me.getX(),me.getY()); repaint();}
  public void mouseReleased(MouseEvent me){
    Ink.BUFFER.up(me.getX(), me.getY());
    inkList.add(new Ink()); 
    repaint();
  }

Yes, that was a lot of changes But here are the two chunks

==PaintInk.java
  public class PaintInk extends Window{
    public static Ink.List inkList = new Ink.List();
  
    public PaintInk(){super("Paint Ink", UC.mainWindowWidth, UC.mainWindowHeight);}
    
    public void paintComponent(Graphics g){
      G.fillBack(g);
      inkList.show(g);
      g.setColor(Color.RED); Ink.BUFFER.show(g);     
    }
    
    public void mousePressed(MouseEvent me){Ink.BUFFER.dn(me.getX(),me.getY()); repaint();}
    public void mouseDragged(MouseEvent me){Ink.BUFFER.drag(me.getX(),me.getY()); repaint();}
    public void mouseReleased(MouseEvent me){
      Ink.BUFFER.up(me.getX(),me.getY()); 
      inkList.add(new Ink()); 
      repaint();
    }
  }

==Ink.java
  public class Ink extends G.PL implements I.Show{
    public static Buffer BUFFER = new Buffer();
    public Ink(){
      super(BUFFER.n); // create PL big enough to hold the n points in BUFFER
      for(int i = 0; i<BUFFER.n; i++){this.points[i] = new G.V(BUFFER.points[i]);}
    }
    public void show(Graphics g){g.setColor(UC.inkColor); this.draw(g);}
    // ---- List ------
    public static class List extends ArrayList<Ink> implements I.Show{
      public void show(Graphics g){for(Ink ink : this){ink.show(g);}}
    }
    // ---- Buffer ------
    public static class Buffer extends G.PL implements I.Show, I.Area{
      public static final int MAX = UC.inkBufferMax;
      public int n = 0; // tracks how many points are in the buffer.
      private Buffer(){super(MAX);}
      public void add(int x, int y){if(n<MAX){points[n].set(x,y); n++;}} // adds 1 new point to buffer
      public void clear(){n = 0;} // reset the buffer
      public void show(Graphics g){this.drawN(g, n);}// draw the n points as a line.
      public boolean hit(int x, int y){return true;} // any point COULD go into ink
      public void dn(int x, int y){clear(); add(x,y);} // add first point
      public void drag(int x, int y){add(x,y);} // add each point as it comes is
      public void uo(int x, int y){}
    }
  }
  
Homework:

As written, the app leaves red ink (the buffer) on the screen when you finish drawing the stroke, while all the other ink is black. What is the minimal change that will make the ink turn black when you mouse up.

Hint: don't try to change the mouse released code. Just change paint component.

Draw a LONG line and see if you can max out our 300 point ink buffer. (You MUST do this to test the guard that you put into the code to prevent overwriting the buffer!)

Kind of makes you wonder how many points you typically use in a single short stroke. Time to start learning how big typical short gestures are. Add some code so that PaintInk will show you the size of the last Ink stroke that you drew. Just draw a number/message somewhere up toward the upper left corner of the window.


::S Bounding Box
==Bounding Box
--Day 5
In order to recognize Shapes we need to normalize the ink, and this means finding out the size of the ink so that we can scale it up or down to the standard size.

A bounding box for graphics is just 4 numbers, the minX, minY, maxX and maxY for a set of points. We will keep those 4 numbers as two Ranges, a horizontal range and a vertical range. We call those ranges LoHi because a range is just a pair of numbers, a lo one and a hi one. 

We will do one tricky thing in our range class, LoHi. Normally the size of an interval would be just be hi-lo, however this means that an interval with but a single point in it has zero width. Since scaling involves dividing one range by another, and since division by zero is not allowed we will force the size of our ranges to be at least 1.

LoHi will be the helper class to track ranges and BBox will be the two LoHi values that we need. Notice that a BBox is also type of rectanlge and so we could have made it a VS. We have two different classes here that keep track of rectangles because we have two different behaviors. The primary behavior of a BBox is to grow as you add datapoints. The VS on the other hand is primarily there to hold the values of a rectangle that we can draw on the screen or use to scale something (like a Norm) so that we can render it to the screen. We will include a function in the BBox class that will allow us to convert the BBox, once it has collected all the points in a single mouse stroke, into a VS for rendering purposes

  public static class LoHi{ // range from lo to hi
    public int lo, hi;
    public LoHi(int min, int max){lo = min; hi = max;}
    public void set(int v){lo = v; hi = v;} // first value into the set
    public void add(int v){if(v<lo){lo=v;} if(v>hi){hi=v;}} // move bounds if necessary
    public int size(){return (hi-lo) > 0 ? hi-lo : 1;}
    public int constrain(int v){if(v<lo){return lo;} else return (v<hi)?v:hi;}
  }
  
  public static class BBox{ // Bounding Box
    LoHi h, v;  // horizontal and vertical ranges.
    public BBox(){h = new LoHi(0,0); v = new LoHi(0,0);}
    public void set(int x, int y){h.set(x); v.set(y);} // sets it to a single point
    public void add(int x, int y){h.add(x); v.add(y);}
    public void add(V v){add(v.x, v.y);}
    public VS getNewVS(){return new VS(h.lo, v.lo, h.hi-h.lo, v.hi-v.lo);}
    public void draw(Graphics g){g.drawRect(h.lo, v.lo, h.hi-h.lo, v.hi-v.lo);}
  }
  
Once we have those helpers written it is an easy manner to fix up our Ink.Buffer so that it has a BBox attached which it clears out on each mouse pressed, and which it updates as the mouse comes in. For the purposes of testing we will modify the Ink.Buffer show routine to draw out the Bounding box as the ink is collected. After you have seen that work you should comment it out.

--  ...Ink.Buffer..
  public int n = 0; // tracks how many points are in the buffer.
  public G.BBox bbox = new G.BBox();
  public void add(int x, int y){if(n<MAX){points[n].set(x,y); n++; bbox.add(x,y);}} // update bbox too
  public void show(Graphics g){this.drawN(g, n); bbox.draw(g);} // show bbox for now to test
  public void dn(int x, int y){clear(); bbox.set(x,y); add(x,y);} // first point resets bbox
  // we don't need to update dragged because add has been modified to add to the bbox as well.  
      
::S Subsampling
==Subsampling

When you draw a single stroke on the screen, like for example a character V how many points do you actually draw? You probably don't know and neither do I. Lets modify PaintInk and test it. Add this line to paintComponent:

  g.drawString("points: "+Ink.BUFFER.n, 600,30);

Now draw some lines and see what you get.

On my machine. A short quick horizontal line was on the order of 15 points. A V shape, not particularly big was about 40 points. A Slowly drawn V shape that filled the screen takes nearly 400 points. When we get to the point that we want to recognize that large screen filling V as being the same shape as the little small V we will need to deal with 3 things. We don't care where on the screen we drew it, we don't care what size we drew it, and we don't care how many points we actually captured from the mouse. If the user draws slowly, they get lots of mouseMove events, if they draw rapidly the get fewer mouse move events. Basically for our recognition we want Translation, Scale and SampleSize invarience. We are going to deal with the last of those first.

Subsampling is the trick of taking some variable number of data points and either throwing some of them out or adding some new ones in to get the number of data points to a single exact number like 20. There are fancy ways of doing that, where you interpolate between existing points but we will do nothing fancy here. If we have too few we will replicate a few points, if we have too many we will just throw them out. 

Here, where we are drawing 2D graphic points on a screen over time, there are several basic ways that we COULD subsample, we could look at how far apart the datapoints are on the screen and try to pick ones that are a representative distance apart (this is called "Spatial Subsampling") OR we could just pick points that a equally spaced in time (like throwing out ever third point - called "Temporal Subsampling"). There is another method that looks for places of maximum curvature i.e. trying to find the most extreme turning points and I don't know if that method has a standard name. The purpose of these different subsampling methods is simply to preserve as much information about what matters to you as possible.

The points that we collected from the mouse were already a sampling of all the points that COULD have been between the beginning and the ending of your stroke. They are NOT being sampled in time because we do NOT have a timer firing off every second giving us another mouse point. When the mouse does NOT move we get NO points. Once the mouse IS moving we are pretty much sampling in time, because it takes a certain amount of time for the system to read in one mouse value and be ready for the next one. So the mouse is closer to time sampled than it is to spatialy sampled. On the other hand, if the user is drawing slowly, time does NOT matter, every time the mouse MOVES by one pixel, that would be enough to fire a mouse event and then you ARE sampling by space rather than by time.

Humm.. what is really going on with that mouse. What do those points actually look like? Time to modify PaintInk and see what is going on. (By the way, that is part of what I am actually showing in this lesson. When you want to know something about what is going on with your computer - WRITE SOME CODE AND FIND OUT! Do not just Google and read garbage!)

Modify the Ink draw routine. It was just drawing lines between the points, so we can't actually see the points. I still want to see those lines but now I want you to draw little circles on top of each point that was actually on the line. (Oops - we can't actually do that - Ink draw is just chaining down to PL and its drawing routine, so lets add another drawing routine called drawDots to G.PL)

--in G.PL
    public void drawNDots(Graphics g, int n){
      g.setColor(Color.GREEN);
      for(int i=0; i<n; i++){g.drawOval(points[i].x-2, points[i].y-2, 4,4);}
    }

Actually I don't like that code. I am tired of drawing ovals from the upper right corner when what I want is a circle of a given radius drawn about the center point. I am going to build a static helper function in G and then rewrite that draw code for PL

  public static void drawCircle(Graphics g, int x, int y, int r){g.drawOval(x-r,y-r,r+r,r+r);}
  
  public void drawNDots(Graphics g, int n){
    g.setColor(Color.GREEN);
    for(int i=0; i<n; i++){drawCircle(g, points[i].x, points[i].y, 4);}
  }
  
And now temporarily I will modify the drawN routine to drawNDots in addition to drawing lines.

  public void drawN(Graphics g, int n){
    for(int i = 1; i < n; i++) {
      g.drawLine(points[i - 1].x, points[i - 1].y, points[i].x, points[i].y);
    }
    drawNDots(g,n);
  }

    
Now when you draw, if you see nothing but green dots if you are drawing slowly. If you see black lines between green circles you are seeing time sampling, because you moved quite a ways before you got another mouse event. 
   
So what sampling method are we going to use? We will use yet another method called "Linear Sampling". This the the quick and dirty method. If we have twice as many points as we need, we just throw out every other one. If we have three times as many as we need we will keep every third point. Similarly in doubling them up, we will just replicate points as often as we need to get the number that we want.

So how do you do linear sampling? It is pretty easy, particularly when you are taking an array with N points and going to an array with K points (we are sub-sampling to K from N). It looks like this:

  for(int i = 0; i<K; i++){subSample[i] = sample[i*(N-1)/(K-1)]}
  
Why that formula? Well, first remember that the last element in the array of N is really at N-1, likewise the last one in the K array is at K-1. SO when the index i (which is marching from 0 to K-1 in the K array) finally gets all the way up to K-1 which is the last index in the sub-sample, we want to be using the last index from the sample. So when i is K-1 that multiplier changes it to N-1. It is also easy to see that when i is zero, you moved from slot 0 to slot 0. And finally the magic of linear functions: a line is defined by 2 points. This formula which is a single multiplier IS a linear function and it matched at the first point and it matched at the last point so it IS the linear function at any integer value between those two points.

Let us write a routine (in Ink.Buffer) that will the n points in the ink buffer into a supplied PL. 

--in Ink.Buffer
  public void subSample(G.PL pl){
    int k = pl.size();
    for(int i = 0; i<k; i++){pl.points[i].set(this.points[i*(n-1)/(k-1)]);}
  }
  
Note: the above code requires yet another change to G.V - we need a set function that instead of taking in an x and a y, takes in a single V. And when we go write that function, it looks just like the constructor that we added to take in a V arguemet as well. If we had written this new set function first, we could have used that in that second constructor so we will make some fixes to G.V

--in G.V 
    public V(V v){this.set(v);} // copy existing V
    public void set(V v){x = v.x; y=v.y;}; 

And finally to see our subsampling in action, we will modify our Ink constructor so that instead of createing a PL that is ALL the points that were in Buffer, we will just sub-sample them.

  public static final int K = 10;
  public Ink(){
    super(K); // create the PL that is this Ink.
    BUFFER.subSample(this); 
  }

You know, green is to hard to look at. I am going to change the color of the circles to BLUE in G.PL.drawNDots. (I am not using a UC color for this because the dots are just debug code. We will throw it all out once we know that our code is doing what we want.)

Now this code is still drawing our BUFFER with all the dots, so when you finish your first stroke you will still see all the dots, but when you go to draw the second line you will see the first line sub-sampled.

If you draw a very long complicated shape you will see that the sub-sampling is throwing out so many points that the fidelity is lost. Another example where our version of sub-sampling will be bad can be seen by doing the following. Draw a V shape, but draw the first branch down to the tip very rapidly and stop, then draw the second branch very slowly. You are creating a V shape with very few points on the first branch and lots on the second branch and our recognition code will have trouble matching a shape like that to a more standard uniformly drawn V. We will NOT worry about these problems. Most drawing is done uniformly and the compass gestures are NOT long complicated strokes. 

What we are trying to do here is to figure out what would be a good sample size that will work for our recognition of compass gestures (and possibly some simple english letter shpaes like 'o' or 'a' - draw some a's and some o's and see how they look sub-sampled) I specifically wrote this code with the number 10 because in my opinion it is too small. Try a number like 25 and see the difference.

This is why we were printing out the number of points in our strokes and looking for the minimum. A short fast single line maybe gets away with about 10 points but if you turn a corner you will be taking 25 for sure and that is why 25 is about enough points to represent one of our simple V shapes. So we did all that work to create another value in UC.

   public static final int normSampleSize = 25;
   
And of course go ahead and change Ink to use that new constant. With that change, you should be able to write some single stroke letters, a,e,u,m and still be able to recognize them in spite of the sub-sampling.

::S Coordinate Transform
== Translate and Scale

We need to be able to do coordinate transfomration, going both directions from screen coordinates to a normalized system and for the purposes of rendering ink back the other direction from a normalized coordinate system to screen coordinates.

So we will build a transfom system that we can think of as mapping one VS box to any other VS box. Since we are not dealing with any kinds of rotations, our transforms consist of only two Geometric operations, Translation (which is accomplished by addition of coordinates) and the other is Scaling (which is accomplished by multiplication). Now there are two very traditional ways of doing the scaling, one called "isomorphic scaling" which uses a single scale factor for BOTH x and y, and the other is call "anisomorphic scaling" which allows x to scale differently from y.

Anisomorphic scaling - the one with two scale factors, will allow you to map a single rectangle to any other single rectangle. This scaling does not preserve aspect ratios. Isomorphic scaling, on the other hand, does preserve, any square will map to another square, and 1 by 2 brick will map to another one by two brick.

For our purposes of recognizing strokes we will want isomorphic scaling. The reason is simple: Imagine that you draw a "/" i.e. a SW-SW stroke. You could draw it almost vertically so that its height is large and its width is small, you could draw it almost horizontally so that it has large width and small height, and you could draw it as a genuine SW-SW stroke where the width and height are almost the same. IF you did anisompophic scaling when you normalized, you would stretch the width and height by different factors to make them come out the same. In other words you would turn that nearly vertical stroke, S-S, into a  SW-SW and similarly you would turn the nearly horizontal stroke W-W into a pure SW-SW. Basically anisomorphic scaling REMOVES any differences in aspect ratio from your original drawing, and there are times when that is what you want. However in this case, our compass gestures have important aspect ratio components. SO our transform will be isomorphic which means that we need a single scale factor instead of two different scale factors.

Knowing that we are ready to start building our Transform class. Since the purpose of transforms is to transform vectors we will make this a nested class of V. Also, just because of the way that we will use them we will build one single static transform, T, in the V class, which you can initialize to one value (like setting it to be the single transformation that we need to convert all the points in the ink buffer into a norm, or instead setting it to the single transform that we need to go from a Norm out to some place on the screen) and then we can use that single transform over and over until we decide to change it.

Our Transform will just need 4 numbers
--add to V
  //-----------------------Transform------------------------
  public static class Transform{
    int dx, dy, n, d;
  }
  
What are those fields in the transform? The single isomorphic Scale value is a fraction with a numerator, n, and a denominator, d. We then have  independent translations in the x and y direction which are the dx and dy. Here is the transform of one single old point,(x,y), converted by the transform to a new point, (x',y').

  (x',y') = (x*n/d + dx, y*n/d + dy)

We will create one single static Transform in the V class, that we will set up once before we do a bunch of points. Most of the work that follows is what we need to do to compute the proper values of dx, dy, n and d. But first, we can write the code that will do the transforms assuming that those values are set. Here is the on static Transfrom in the V class

--Multiply BEFORE Divide
Side note: I am doing multiplication and division with integers and there is something that you should know about integer arithmetic on computers. Integer division truncates. So 4/5 == 0, it just rounds down. It is not the NEAREST integer result, but it is close, only off by 1. 

From your math classes (where you did NOT do trunction) you have learned that if you want four fifths of seventeen, there is no difference between writing that as either 17 * 4/5 or 4/5 * 17. 

On computers with truncated division there is a massive difference. The first one is 17*4 which is 68 divided by 5 which is 13 (close to 13.6 the exact answer befor truncation). The second one is 4/5 which is 0 times 17 which is zero, which is massively wrong. 

When working in trucating integer math you MUST do all your multiplications (which makes numbers bigger) before you ever do you divisions (which makes things smaller AND truncates introducing error) to minimize your error. If you do divisions before your multiplications you are multiplying the error that the division introduced. So yes, when I write x*n/d in the code I mean it. I didn't want you to just copy the math and not know that the order matters!

--add to V
  public static Transform T = new Transform();
  

I then want to have methods in the V class that can use that single T to set the value of some V to be the transform of some other V.

  public void setT(V v){set(v.tx(), v.ty());} 
  public int tx(){return x*T.n/T.d + T.dx;}
  public int ty(){return y*T.n/T.d + T.dy;}

So those helpers, tx, ty, allow setT to apply the Transform T to the single point v.

We will also want a function in PL to transform an entire PL.

  public void transform(){for(int i = 0; i<points.length; i++){points[i].setT(points[i]);}}

Now we need to figure out HOW to initialize a transform to do the thing that we want. We will do this by imagining that we have one box of size and location that we want to move to another box with a new size and location.

Since we will set up a transform that way we make that a set function in the Transform clsss. The version we will use all the time is to convert from the oldVS that was the bounding box of the original ink into a normalized coordinate system. But, we also want to go the other way sometimes, going from normalized coordinates out to some particular box on the screen.

  public void set(VS oVS, VS nVS){...}

The first part of our calculation will be to set up the scale, i.e. the two values n and d.

To scale a value that was in an old coordinate system, you divide the value by the old size (thus scaling it to one) and then multiplying it by the new size (thus scaling it from one up to the new size). Thus our new size is the numerator and the old size is the denominator.

In anisomorphic scaling, where you have 2 scale factors, one for horizontal and one for vertical, the numbers are simple. xScale = newWidth/oldWidth and yScale = newHeight/oldHeight. When we want just one scale factor we have options. We could pick one or the other. We could average the two of them, or we could force fits, which is what I will do here. Basically we look at the old box, and if it was not a square, we choose either the width or the height, whichever was larger. We think of that as being the SIZE of the old box. We do the same with the new box and that ratio is the single scale factor. I call it force fit, because it takes the largest value in the input box, shrinks that down to one and makes it no bigger than the largest value in the output box. Thus everything in the input box is forced to fit in the output box.

  void setScale(int oW, int oH, int nW, int nH){
    n = (nW>nH)?nW:nH;  d = (oW>oH)?oW:oH;
  }

Next, to figure out the offsets, dx, and dy, we consider how we deal with just one single coordinate, like x.

Imagine a single line segment, starting at oX, and with width oW. We want to scale and translate it to be at nX and nW and we want the actual translation(s) to be mapping the center coordinate in the old coordinate system to the center coordinate in the new system.

The normal way to visualize performing this operation is to do it in 3 steps. first translate the original coordinates to the origin, then scale, then tranlate the origin up to the new coordinates.

  x' = (x -oX)*n/d + nX 
  
So in that expression we first subtract oX to translate upperleft coordinate to the origin. Then we scaled about the origin, fianlly we translate to the location of the new coordinate syste by adding nX.
  
As you can see, this expression is not in our ideal form of a single multiply followed by a single addition. However, now we can use algebra to simplify that above expression into one that has a single multiply followed a single final constant to add:

  x' = x*n/d + (-oX*n/d + nX)
  
So that single constant expression at the back is the single dx translation value that we needed in our transform. Because the y expression looks exactly the same, except using y and Height, we will build a single helper to help us calculate the offsets.

  int setOff(int oX, int nX){
    return -oX*n/d + nX;
  }
  
Finally, with these helpers we can flesh out the details of the set function that creates the transform that move us from an oldVS to a newVS:

  public void set(VS oVS, VS nVS){
    setScale(oVS.size.x, oVS.size.y, nVS.size.x, nVS.size.y);
    dx = setOff(oVS.loc.x, nVS.loc.x);
    dy = setOff(oVS.loc.y, nVS.loc.y);
  }
  public void set(BBox oB, VS nVS){
    setScale(oB.h.size(), oB.v.size(), nVS.size.x, nVS.size.y);
    dx = setOff(oB.h.lo, nVS.loc.x);
    dy = setOff(oB.v.lo, nVS.loc.y);
  }
 
I have included two versions of set, one that works from a BBox which we will probably need when normalizing Ink.BUFFER coordinates.

This was a long chapter because I know that some of my students have not done any math in a long time, so I took longer to explain how I think about the coordinate transform math. But of course when you boil it all down, there were really only two equations in the whole thing, the formula for doing the transform calculation (that shows up in tx, ty) and the calculation of the appropriate offset (setOff) when what you are given is one box that needs to move to another.
 
==Code Summary

--PL gets one new function:
  public void transform(){for(int i = 0; i<points.length; i++){points[i].setT(points[i]);}}

--V gets functions & a static class Transform:
  public static Transform T = new Transform();
  void setT(V v){set(v.tx(), v.ty());} 
  int tx(){return x*T.n/T.d + T.dx;}
  int ty(){return y*T.n/T.d + T.dy;}
    
  public static class Transform{
    private int dx=0, dy=0, d=1, n=1; 
    public Transform(){}
  
    private void setScale(int oW, int oH, int nW, int nH){
      d = (oW>oH)?oW:oH; n = (nW>nH)?nW:nH;
    }
    private int setOff(int oX, int oW, int nX, int nW){return (-oX-oW/2)*n/d + nX + nW/2;}
  
    public void set(VS oVS, VS nVS){
      setScale(oVS.size.x, oVS.size.y, nVS.size.x, nVS.size.y);
      dx = setOff(oVS.loc.x, oVS.size.x, nVS.loc.x, nVS.size.x);
      dy = setOff(oVS.loc.y, oVS.size.y, nVS.loc.y, nVS.size.y);
    }
    public void set(BBox from, VS to){
      setScale(from.h.size(), from.v.size(), to.size.x, to.size.y);
      dx = setOff(from.h.lo, from.h.size(), to.loc.x, to.size.x);
      dy = setOff(from.v.lo, from.v.size(), to.loc.y, to.size.y);
    }
  }  
  
==Test it

Now, in order to test this, we will just temporarily modify our Ink constructor to transform and move the ink from where it actually happened on the screen to some other box.

  public static G.VS TEMP = new G.VS(100,100,100,100); // for testing, a box that we will move ink to
  public Ink(){
    super(K); // create the PL that is this Ink.
    BUFFER.subSample(this);
    G.V.T.set(BUFFER.bbox, TEMP);
    transform();
  }

Try it out. Seems to work.

==Clean up

Technically, we have tested the code that went from a bounding box to our VS TEMP. We will next verify that we can in fact go the other direction (and simultaneously verify that our code to construct a VS from BBox works as well) by doing this in our ink constructor. We will leave the code that we have in place, which is converting from the BBox to some standardized coordinates (100,100,100,100) and then we will just compute the Transform that move it from the TEMP coordiante system back out to the VS that corresponds to the BBox that we started with. That should put the ink right back where it came from (though reduced in sample size).

    G.V.T.set(BUFFER.bbox, TEMP); // just to test transforms
    transform();
    G.V.T.set(TEMP, BUFFER.bbox.getNewVS()); // see if we can put the ink back where it came from
    transform();

Seems to work fine on my box.

We should in theory remove all that extra work from our Ink constructor, first normalizing and then immediately expanding it back out to where it was seems like wasted work. However there is a good possibility that before we are done we will ultimately want to actually keep Ink in Normalized coordinates with a VS so that we can move it back to where it came from rather than keep it in its raw form. Keeping it in normalized form allows us to do some compression - draw a letter 'a' on the screen - look at the count of the points it took to draw that raw image and remember that when we subsampled it down to 20 you saved space for every point that we are NOT keeping.

But before we get to that, now that we have subsampling and transforms we have all the tools that we need for Norms i.e. normalized coordinates.

::S Norms
--Day 6
==Norms

We are mostly going to move everything that we were doing in our ink constructor into a static nested class called Norm. And we are going to change Ink so that it no longer extends PL.

We will need a coordinate size for our normalized coordinates. 1000 should give us plenty of resolution and yet still be small enough so that when we start squaring them and adding them to compute euclidean distances the distance numbers will on the order of several million which will fit easily into the billion range of a 32 bit integer. So add this to UC.

  public static final int normCoordMax = 1000;


The Norm class in Ink will look like this: (And you will see that the Norm constructor is basically what we used to have for Ink.)

--add nested class to Ink
  //--------------------Norm---------------------
  public static class Norm extends G.PL{
    public static final int N = UC.normSampleSize, MAX = UC.normCoordMax;
    public static final G.VS NCS = new G.VS(0,0,MAX,MAX); // the coordinate box for Transforms
    public Norm(){
      super(N);
      BUFFER.subSample(this);
      G.V.T.set(BUFFER.bbox, NCS);
      transform();
    }
  }

Now unlike Ink, Norms can't show themselves. They are in an abstract coordinate system. However, we can show them AT some place if we have a VS so we will add a drawAt routine for our Norms:

    public void drawAt(Graphics g, G.VS vs){ // expands Norm to fit in vs
      G.V.T.set(NCS, vs); // prepare to move from normalized CS to vs
      for(int i = 1; i<N; i++){
        g.drawLine(points[i-1].tx(), points[i-1].ty(), points[i].tx(), points[i].ty());
      }
    }

And now we will modify Ink to consist of two fields, a Norm and a VS. Ink will implement I.Show and an Ink object will show itself by calling the norm's showAt routine.

  public class Ink implements I.Show{
    public Norm norm;
    public G.VS vs;
    public static Buffer BUFFER = new Buffer();

    public Ink(){
      norm = new Norm(); // automatically loads from BUFFER
      vs = BUFFER.bbox.getNewVS(); // where the ink was on the screen
    }
    public void show(Graphics g){g.setColor(UC.inkColor); norm.drawAt(g,vs);}     
    
Nothing has really changed, we have just moved where we used to do things in Ink over to where we want do do them in Norm. 

So we are ready to start adding to the Norm class. In particular we want to make it possible for a Norm to compare itself to another Norm.

    public int dist(Norm n){
      int res = 0;
      for(int i = 0; i<N; i++){
        int dx = points[i].x - n.points[i].x, dy = points[i].y - n.points[i].y;
        res += dx*dx + dy*dy;
      }
      return res;
    }
    
We will test that by modifying our PaintInk app to print to the screen the distance between the last two
elements on the inkList - so add to paintComponent:

    if(inkList.size()>1){
      int last = inkList.size()-1;
      int dist = inkList.get(last).norm.dist(inkList.get(last-1).norm);
      g.setColor(dist>500000?Color.RED:Color.BLACK); // black for same red for different
      g.drawString("Dist: "+dist, 600, 60);
    }

What we are looking for here with those distance numbers is this: Two shapes that are supposed to be the same should be close to one another. So if you draw two v's in a row the distance should be small, but if you draw a 'v' followed by an 'L' that distance should be large. I used the number 500K as a distinguishing number. I don't know if that number is even close to right.

I want to eventually construct a new UC integer, namely noMatchDist. Basically if the distance between two Norms is greater than noMatchDist then there is no way that I want to consider those two shapes to be the same. So I had this code write the numbers in Black if they might possibly be considered to be the same shape, but colered red if they should NOT be considered a match.

In fact, since I know that that is what I want to figure out, I should have added this value to UC:

  public static final int noMatchDist = 500000;

And then had this line in the code that I slipped into paintComponent in PaintInk:

  g.setColor(dist>UC.noMatchDist?Color.RED:Color.BLACK); // black for same red for different
  
What we are doing with that noMatchDist is limiting our nearest neighbor matching. Nearest neighbor takes an input point and DECLARES it to be the same type as whatever its nearest neighbor was. We are going to eliminate matches to neighbors that are farther than noMatchDist away. We would rather return NULL match than match something that is much too far away. So when we everntually tune this number, it will be to make a trade off from how often we returned a null as a result of our match vs returning something that doesn't match particulary well.

But now that we have working normalized coordinates we can start in on the next class that we will need to build, Shape.

::S Shape
==Shape

A !nShape is an abstract notion, mostly a name, like 'O' or 'S-E'. There may be many different ways to draw a single sahpe. For example you could draw your 'O' clockwise from the top, or counter-clockwise from the top, or possibly from the bottom. Those ACTUAL different ways of drawing that shape will be called called !nPrototypes. So in our system a Shape will be a Prototype List that has a name. A single Prototype is basically a Norm. Here is the outline of the Shape class that you should build now.

--add class Shape to reaction

  package reaction; 
  import java.util.ArrayList;
    
  public class Shape{
    public Prototype.List prototypes = new Prototype.List();
    public String name;
    
    public Shape(String name){this.name = name;}
    
    //------------------Prototype-----------------
    public static class Prototype extends Ink.Norm {
      int nBlend = 1;
      
      //-------------------Prototype.List-----------
      public static class List extends ArrayList<Prototype>{}
    }
  }


We have a field nBlend in Prototype so that we can average together several Norms in order to smooth them out. The nBlend keeps track of how many numbers you have averaged together so that you can incrementally modify the average. If you have not see this incremental average trick before it is both simple and convenient.

Normally to average n numbers together, I first add them and divide by n, so AVG = (a1+a2+a3+...+an)/n

Suppose that I have that average number and then along comes a new number X that I want to include in that average. IF I know how many numbers that there were in the previous collection then I can incrementally update an existing average and add in one more element. Basically newAvg = (n*OldAv + newVal)/(n+1).

So we will add a blend routine into G.V to do this for a single V

--in G.V
  public void blend(V v, int k){set((k*x + v.x)/(k+1), (k*y + v.y)/(k+1));}
    
And once you can do it for a single V, you can do it for every V in the list of points in a Norm

--in Ink.Norm
  public void blend(Norm norm, int nBlend){for(int i = 0; i<N; i++){points[i].blend(norm.points[i], nBlend);}}

And now that a Norm can get blended, a prototype that knows its blend count can be blended.

--in Shape.Prototype
  public void blend(Ink.Norm norm){blend(norm, nBlend); nBlend++;}

Now the main reason that we wanted Norms was so that we could compute the distance between them and use that to find matching prototypes and thus identify the shape of a stroke. Basically we take a single new input Norm and compare it distancewise to all the prototypes in all the shapes that we have and find the best match.

This means that we are going to want a function to find the bestMatch in a list of prototypes. And in fact we will want something just like it in the list of shapes. I wrote the function so that it returns the int distance of how close the match was and as a side effect it sets a static variable that points to the element on the list which produced that closest match.

--in Shape.Prototype.List
      public static Prototype bestMatch; // this is set as a side effect when running bestDist
  
      public int bestDist(Ink.Norm norm){
        bestMatch = null;
        int bestSoFar = UC.noMatchDist; // assume no match
        for(Prototype p : this) {
          int d = p.dist(norm);
          if(d < bestSoFar){
            bestMatch = p;
            bestSoFar = d;
          }
        }
        return bestSoFar;
      }

Notice: If we can't beat the noMatchDist that this routine will find nothing and bestMatch will be null.

The other function that I want to add, both so that I can see what the prototypes on the list look like, but also so I can see how many blends make up each one, is a show routine. I basically create a box that I march across the top of the screen and draw each successive prototype in that list of boxes.

--implement I.Show in Prototype.List
      private static int m = 10, w = 60; private static G.VS showbox = new G.VS(m,m,w,w);
      public void show(Graphics g){ // draw a list of boxes across top of screen
        g.setColor(Color.ORANGE);
        for(int i = 0; i<size(); i++){
          Prototype p = get(i); int x = m + i*(m+w);
          showbox.loc.set(x, m); // march the showbox across the top of the screen
          p.drawAt(g, showbox);
          g.drawString(""+p.nBlend,x,20);
        }
      }

Once we can search for matches, and can show a list we can hack up PaintInk to show us the results.

First add a static Prototype.List

--in PaintInk
  public static Shape.Prototype.List pList = new Shape.Prototype.List();
  
next make sure that your draw the list in paintComponent
--in paintComponent
  pList.show(g);
  
And finally hack up mouseReleased to populate the pList

  public void mouseReleased(MouseEvent me){
    Ink ink = new Ink();
    inkList.add(ink);
    if(pList.bestDist(ink.norm) < UC.noMatchDist){ // we found a match so blend
      Shape.Prototype.List.bestMatch.blend(ink.norm);
    }else{
      pList.add(new Shape.Prototype()); // new Prototype
    }
    repaint();
  }

Note: when we run this, IF noMatch is too big, we will find matches where we don't want them a possibly be blending stuff together that are really different shapes. On the ohter hand if it is too low, it doesn't see similar shapes as being similar. It is better to err on the side of making it too small. It simply means that you will need to collect more sample prototypes in order to recognize things as oppose to recognizing things incorrectly. You would rather that your AI say that it doesn't know what something is rather than making wild guesses.

Last but not least, just for fun AND for better data compression AND for extra smoothing, modify the Ink that you JUST threw into the inkList (it is right there in the variable ink) to share the norm with the prototype that you either just blended or just created. What I mean is to replace the norm that was in the ink object with the norm from a prototype.

Think about what this will do. You draw your first character. It is an 'a'. You match nothing because it is the first thing you drew so you create a prototype for 'a'. Now throw out the ink's norm and replace it with the norm from the first prototype. Nothing has changed, the prototype's norm was just a copy of the inks norm. But now if you draw another 'a' and it matches, the prototype blends. BUT the first ink object shares that object SO the old ink object on the screen now updates to be the smoother version that you just blended.

As you keep drawing the same shape over and over, all the copies of that shape on your page keep updating.

Here is the code with that modification:
  
  public void mouseReleased(MouseEvent me){
    Ink ink = new Ink();
    Shape.Prototype proto;
    inkList.add(ink);
    if(pList.bestDist(ink.norm) < UC.noMatchDist){ // we found a match so blend
      proto = Shape.Prototype.List.bestMatch;
      proto.blend(ink.norm);
    }else{
      proto = new Shape.Prototype();
      pList.add(proto); // new Prototype
    }
    ink.norm = proto;
    repaint();
  }

::S Refactoring
==Refactoring & Renaming

This section is a bit awkward. It is mostly a ghost from a previous version of this book, and yet the topic that it brings up, the necessity of refactoring and renaming, is worth mentioning so I have left this section here even though I have totally rewritten it.

The problem that I had been facing back when I wrote the original section was that I was both writing my code base and writing these notes on how to build the code at the same time, and I had hit a point where I wanted to refactor my code with some name changes.

In the past, I mean in the pre-IDE days of code development, re-naming was real work. You had to go through your code by hand and find every single place that you referenced a variable or a function and change the name.

It was not an insurmountable task because the compiler was actually helping you. What I mean is that if you FORGOT to change a name somewhere in the program, the compiler would detect that it didn't know what that old name was, throw an error, and you could fix it. 

Unfortunately, what the compiler did NOT help you fix was your documentation. If you wrote comments in your code like this:

  // the variable foo represents the screen coordinates NOT local coordiantes

The compiler, since it completely ignores your comments, does not even notice that this comment refers to a variable named foo and if you change it to bar, the comments are now out of synch with the code base.

That is of course still exactly the case today. The IDE will allow you to refactor and rename your  code variablesn with just a few keystrokes, but it won't see them and fix those names if you talk about the variable in your comments. 

It is part of the reason that comments in OLD code are a bit untrustworthy. The original programmer may have put in comments about how the code worked but the maintainence guy, who modified the code for some new purpose a decade later, either didn't see or fix the comments to match the new functionality.

Anyway, my problem back then was this: I was not only writing my gesture based music notation code, but I was also writing this TEXT document describing how I wrote the code and what I was doing. This online book is ALL comments on the code. While writing THESE notes I was AVOIDING changing any names, because even though it was trivial to do in the code base, a single refactor/rename in the IDE, I did NOT want to have to go back and re-edit this book.

But I had finally hit the limit. I decided that the code was more important than keeping this book in synch with it and that I should just TELL you all at this point to go refactor your code. I would do the same thing and we would both live with the fact that the code in the front of this book was NOT in synch with the code from the back of this book.

HOWEVER. I am now in the situation where I am completely rewriting this book. I can now fix the early code that I present in the book, using the names that I finally decided were better, and save you all from refactoring and renaming at this point. 

So in theory, I COULD just eliminate this section about refactoring and renaming entirely because I am doing the renaming in this rewrite to save you from having to do any of it at this point. In theory, this document will now be in synch with my code base. 

Unfortunately I am now confronted with a slightly different problem. This entire course was an attempt to show you HOW I develop a mid-level java project. I essentially wrote some code over in the IDE and simultaneously wrote this text over here telling you how I wrote that code. Easy!

HOWEVER, over the years, as I have gone over and over this same identical code base, and each time I teach the course I see things that I could do or should have done differently. Why did I do it THAT way? Why didn't I just do it this way? This is better! I am now faced with the question of; do I just show you the OLD junk that I wrote the FIRST time that I wrote this code, or do I just write it the way I would do it NOW.

Certainly, the old way IS an honest historical record of what I wrote, and how I wrote it back then, warts and all. Perhaps I should just leave the course the way that it is and the way that it has been.

And that, my friends, is what I CAN NOT DO! I am a programmer. I !ilive to change code. When I see a fix that I want to make, I DON'T spend my time agonizing over the amount of work it will take to change it. The code MUST be the BEST that it can be. The history does not matter. My effort and pain does not matter, the CODE gets to choose how it wants to be organized. I am just the AGENT that helps the code be what it can be. My code WANTS those names to be changed and I must comply.

So yeah, going forward, if my comments HERE don't quite fit the code. I apologize. The code does what it wants and if my documentation is a little out of synch, well that is just the nature of comments.

::S ShapeTrainer
--Day 7
== ShapeTrainer

Now that we have Shapes and Ptototypes and are able to match and blend them, we have tested building a single prototype list and looking throught that to find the best match BUT we have not yet tested our ability to go though a list of Shapes and find the Shape that best matches some input. Finding that matching Shape is of course exactly what our Nearest Neighbor shape recognition is supposed to do and we are essentially at the point where our code can do that, BUT in order to test it we will need to have some Shape data, several different prototypes of several different shapes for us to search through and do our matching.

In order to create that data we will build an app called ShapeTrainer that will allow us to give names to shapes and draw examples of those particular shapes to store as prototypes. We were going to need this application anyway. We need it for testing now, but we needed it to construct the actual data for the recognizer that we want to use in our application so let us just build it now.

In some sense, the ShapeTrainer will not be terribly different from what we are currently doing in our PaintInk app. In that app right now, we take all input, compare it to a single prototype list, blend it or add it as necessary. This is exactly what we want to do to train any single shape. All we will need to do to make it more robust is to allow us to type in a Shape name, and to have the system either create or find that Shape in the Shape.DB (A static map of all the shapes that we can recognize) and use that Shape's prototype list for additions and blending.

And I will warn you in advance. In the first several versions of this course, I wrote two stand alone applications. The first one which we are building now is the Shape Trainer that lets me build a database of Shapes so that we can recognize shapes. The Second one was the music editor which just creates music notation using our shape database to do recognition. 

My original conception was that createing the Shape Database was something that the engineers did, back at the factory, with the Sahpe Trainer, an "in house" tool. Then you ship the customer the "musicEditor" with the fancy gesture interface so that they can edit music. 

My current view is that we should instead build One application, a single integrted thing that lets you both edit music AND edit and change the Shape database. This will save US time in this class from having to continually shift back and forth between two different application when we are building it. This might not be the BEST design for an imaginary music application but it is BETTER for us in this class. It is better in 2 ways. We ge a more responsive system as we are building our Editor, and also, you get to see an example of how to refactor a simple application like a Shape Trainer into a more complicated app that is a combined ShapeTrainer/MusicEditor.

So while we are developing the Shape Trainer, we will just be building a single stand alone Shape Trainer app. That is the way I always did it. BUT when we get around to building the music editor, we/I will suddenly realize, "Hey, you know, maybe we should build an integrated application that is both the MusicEditor/ShapeTrainer and we will start refactoring all of the code that we will be writing in this and the next section.

==DOT

There is also one little gotcha that we must deal with eventually in shape recognition and I mention it now. There is ONE shape, the DOT, that does NOT use the general shape matching metric of comparing norms to prototype lists. DOTs are by definition a mouse dn, mouse up in quick succession. There was no collection of points. The BoundingBox was tiny. You do NOT want to blow that up to some normalized coordinate system and match coordinates - it would all be noise. So we special case the DOT shape. The recognizer should first look at the bounding box, and if it is TINY, below some UC.dotThreshold in both X and Y, then it declares it to be a DOT and never even looks at the norm.

This means that recognition is NOT based on Norms, it is actually based on Ink. We need the box (the VS) where the Ink occured so that we can quickly look at the box size and first determine if it was a dot BEFORE we look at the norms and do distance calculations.

I mention this now because when we build the ShapeTrainer there is one shape that we do NOT train prototypes for, namely DOT.

If the user, who is allowed to type in the name of a shape to train, happens to type in "DOT", we should notice that and refuse to train it.

This is not a bad thing. In fact when you get right down to it, there is a second shape name that we don't want to train. It would be BAD to train a shape named "", the empty string. We also probably want to block having spaces in names. And this actually leads us into a notion for how we will build the ShapeTrainer User Interface. We will be keeping a string that is the name of the shape that the user wants to train. We can look at that name and give the user feedback on that particular name. I see three possibilities: The shape name is KNOWN, i.e. we already have some prototypes for that shape, it is in the database - the shape name is UNKNOWN, i.e. we do NOT have that shape in the database yet but it is perfectly legal - and thrid, the shape name is ILLEGAL, we will NOT actually create or train that shape.

==Saving

We will eventually want to actually save all this data out to a file. We are NOT going to do that first pass BUT we will want to leave space in our layout for a button that will allow us to save someday.

==Selection Buttons

We will eventually want to allow the user to click through the list of all the different shapes and look at the prototypes that are stored for each one. We will not do this on the first pass either, but once again we will leave space for it and it should be clear that we will need to deal with some kind of button behavior eventually. We will deal with that in a later section as well.

==User Prompt

We will need a place on the screen where we will prompt the user, telling them WHAT shape is currently being trained and also giving them some feedback on that name, namely whether the name is KNOW, UNKNOWN or ILLEGAL.

==Prototype Deletion Buttons

It would be SO COOL if you could remove prototypes from the list that you think are bad. Since our PaintInk app currenly draws all the existing prototypes out to the screen, we could just let the user click on any one those prototypes they didn't want in the list and make that UI action that would delete that Prototype from the list.

Yeah, great idea. Let's leave that for version 2. Maybe we can assign that project to an Intern. 

What? Why not just do it now?

Sigh, because none of the showboxes that we used for drawing out those prototypes were saved anywhere, they don't actually exist eacept as an artifact of showing a Prototype.List. We would have to create those boxes, save them somewhere, make them into Areas, put them on an area list, locate the active area, react to them as buttons which we haven't even built yet and we want to SHIP this code by the end of today.

Great Idea though, we will do this FOR SURE, just not right away. For right now we will use the poor man's method of deleting bad prototypes which is - IF you enter a bad prototype then DON'T press the save button. Just shut down the app, lose everything that you have done so far, including the bad prototype, and start over.

(grumble, grumble) That doesn't sound very nice. Delete buttons would be better.

Yes, absolutely. You are right. Version 2. Now, go write the keyboard routines the we need and quit whining!


==Keyboard input

Finally, something that we MUST do on our first pass. We must let the user tell us which shape they want to train. We will let them type characters and each one will get appended to the growing currentName String - unless they type a space or return, in which case we will nuke the current name. So they can type "S-E" train a few of those then type, " N-N" (and the space at the front will clear out the old name) and then they train some N-N shapes.

We have not done any keyboard input previously so that is the FIRST step in building our ShapeTrainer - create a new App, make sure you call it from main and add the logic to READ keyboard events, either appending characters to a current String or nuking the current string when necessary. And noticing the State of the current string, in particular noticing whether or not the string is one of the few ILLEGAL ones. What I am pushing for here is the shortest easiest class that we can write that will do SOMETHING showing that we can indeed read the keyboard.

in reaction package add:
  public class ShapeTrainer extends WinApp{
    public ShapeTrainer(){super("Shape Trainer", UC.mainWindowWidth, UC.mainWindowHeight);}
    
    public static String UNKNOWN = " <- this name is currently Unknown.";
    public static String ILLEGAL = " <-this name is NOT a legal Shape name.";
    public static String KNOWN   = " <-this is a known shape.";
  
    public static String curName = "";  
    public static String curState = ILLEGAL;
    
    public void setState(){ // more work needed to actually detect KNOWN
      curState = (curName.equals("") || curName.equals("DOT")) ? ILLEGAL : UNKNOWN;
    }
    public void paintComponent(Graphics g){
      G.fillBackg);
      g.setColor(Color.BLACK);
      g.drawString(curName, 600,30);
      g.drawString(curState, 700,30);
    }
    public void keyTyped(KeyEvent e) {
      char c = e.getKeyChar(); System.out.println("Typed: " + c);
      curName = (c == ' ' || c == 0x0D || c == 0x0A)? "": curName + c; // x0D & x0A are ascii CR & LF
      setState();      
      repaint();
    }
  }
  
As you can see, we override keyTyped and call getKeyChar on the KeyEvent to see the char that was typed. Because this is your first time, in this class, with key events I will toss out some general comments.

The difference between keyPressed, keyTyped, and keyReleased is that your system may want to react to the exact moment that a key was pressed. For example, when the used presses and releases the shift key NO character was actually typed. However your user interface MIGHT have wanted to react immediately to the user pressing the shift key by painting an entirely different keyboard presentation on the screen to show them what keyEvent they would get if they hit some other key while they had the Shift key depressed. 

Another thing that you will have to look up someday (if you need it) is what sort of events are caused when the user presses the arrow keys (or backspace). There is no need to learn that until you need it and it is easy to look up.

Now that we can read keyboard events we will move on to the changes that we need in Shape to hold the Shape.DB

But first, write the main routine that you know you need in ANY WinApp, and run the ShapeTrainer as it currently is. It can NOT train anything. It has no mouse routines. BUT it can read the keyboard and let you type in the name of a shape and tell you if it is illegal or unknown.

::S Shape Database
== Shape Database

Conceptually this is a very simple thing. It is just the collection of all the Shapes that we are able to recognize. We could certainly keep this as a list of Shapes. I have said as much when I mentioned going back and forth through a list of Shapes in our ShapeTrainer, but we will also want that list to be kept in a Map organized by the name string. The reason is simple, when we write our Music Application and it wants to create a Reaction object that reaction will be tied to the shape name. we will be looking for a "S-S" stroke to draw that note stem, we will use a "E-W" shape to create a staff. The map is just a convenient way to get the appropriate shape (which is what our recognizer will be returning) associated with a given name.

Also there is lovely function in Map called "values" and to quote the Java Platform Docs
::I text
  Returns a Collection view of the values contained in this map. 
  The collection is backed by the map, so changes to the map are reflected in the collection, and vice-versa.
::I java

So we will think of the Map as being the fundamental representation of all our shapes. 

You haven't seen Serialization yet in this course. It is the way that we write information, in particular objects out to a file. So when I mentioned saving our shape database, in the back of my head I know that I want to have an object, preferably one single object, that holds all the information that I want to Serialize. That shape Map will be the object that we will read and write to a file. 

I will put a wrapper class around that Map. 

--in Shape add static class Database
  //--------------Shape.Database-----------------
  public static class Database extends TreeMap<String,Shape>{
    public static Database load(){  // stub
      Database res = new Database();
      res.put("DOT", new Shape("DOT"));
      return res;
    }
    public static void save(){}//stub
  }

I have essentially stubbed the load routine. It does no loading what so ever, instead it just creates an empty Map from scratch which is adequate for testing our ShapeTrainer. Similarly, save is also just a stub, doing nothing until we get around to the problem of actually reading and writing files. 

With that wrapper class in place, we can put a static variable, a singleton Database into the Shape class.

--in Shape add:
  public static Shape.Database DB = Shape.Database.load();
  public static Shape DOT = DB.get("DOT"); // fetch the DOT out. It is special
  public static Collection<Shape> LIST = DB.values(); // list of all shapes in the DB
  
    public static Shape recognize(Ink ink){...}
  
We don't need recognition for the shape trainer but it is pretty straight forward:
--in Shape add:
  public static Shape recognize(Ink ink){ // note: can return null
    if(ink.vs.size.x < UC.dotThreshold && ink.vs.size.y < UC.dotThreshold){return DOT;}
    Shape bestMatch = null; int bestSoFar = UC.noMatchDist; // assume no match
    for(Shape s:LIST){
      int d = s.prototypes.bestDist(ink.norm); 
      if(d < bestSoFar){bestMatch = s; bestSoFar = d;}
    }
    return bestMatch;      
  }

We will need a UC.dotThreshold. I used the number 5. If the mouse moves less than 5 pixels it is a dot.
    
Look at all that scary code over here in Shape that we have written none of which is tested yet. I want to get back to the Shape Trainer, but now that I have a database, I am thinking that I want to do just a bit of refactoring. 

We had written some code in the shape trainer to determine if a shape was Known, Unknown or Illegal. Well, the only thing that knows if it was known or unknown is the database. That strongly suggests that the trainer should be asking the DB for ALL this information. Let's add a few more routines to Database

--in Database add:

  boolean isKnown(String name){return containsKey(name);}
  boolean isUnknown(String name){return !containsKey(name);}
  boolean isLegal(String name){return !name.equals("") && !name.equals("DOT");}

Now we can get back to writing the ShapeTrainer.

::S Constructing Shapes
==Constructing Shapes  

Where we last left our shape trainer, it was able to update the curName based on key events. We had a setState routine to tell us whether the name was ILLEGAL or UNKNOWN. We want to fix that code so that it now uses the DB to determine the state. 

We will also, if it is a known Shape, want pull out a static variable that is the List of ptototypes that we will be updating.

  public static Shape.Prototype.List pList = null;

  public void setState(){
    curState = !Shape.DB.isLegal(curName) ? ILLEGAL : UNKNOWN;
    if(curState == UNKNOWN){ 
      if(Shape.DB.isKnown(curName)){
        curState = KNOWN;
        pList = Shape.DB.get(curName).prototypes;
      }else{ // it really is UNKNOWN
        pList = null;
      }
    }
  } 

We have set pList to null if this is an UNKNOWN name. We do that because we call this routine everytime the user types in a letter. They may still be typing. We don't know that they are at a name they want us to create until they actually draw a character. We should update paint component so that it will now show both the Ink.BUFFER as they draw the ink and we want to show the prototypes of the shape that they are training.

  public void paintComponent(Graphics g){
    G.fillBack(g);
    g.setColor(Color.BLACK);
    g.drawString(curName, 600,30);
    g.drawString(curState, 700,30);
    g.setColor(Color.RED);
    Ink.BUFFER.show(g);
    if(pList != null){pList.show(g);}
  }  
   
Note: I have guarded the drawing of the pList - becuase it could be null.

Finally we can put in the mouse code. It is very similar to what we had in PaintInk. In fact, I just copied that code and added a few changes, like wrapping the code in a IF block to prevent doing anything if the curName was actually ILLEGAL.   
   
  public void mousePressed(MouseEvent me){Ink.BUFFER.dn(me.getX(),me.getY()); repaint();}
  public void mouseDragged(MouseEvent me){Ink.BUFFER.drag(me.getX(),me.getY()); repaint();}
  public void mouseReleased(MouseEvent me){
    if(curState != ILLEGAL){
      Ink ink = new Ink();
      Shape.Prototype proto;
      if(pList == null){
        Shape s = new Shape(curName); // create the shape
        Shape.DB.put(curName, s);  // add it to the database
        pList = s.prototypes;      // use its prototype list as the current list
      }
      if(pList.bestDist(ink.norm) < UC.noMatchDist){ // we found a match so blend
        proto = Shape.Prototype.List.bestMatch;
        proto.blend(ink.norm);
      }else {
        proto = new Shape.Prototype();
        pList.add(proto); // new Prototype
      }
      setState(); // technically after adding the first prototype we now know this shape so fix the msg
    }
    repaint();
  }

Check it out. Enter a name and train some strokes. Change the name and notice that it is unknown. Make the first stroke on the new name and notice that the msg changes now that this state is known. Re-Enter the first name and see that it is now known. 

Looks good to me. Time to Serialize.

::S Serialization
==Serialization

Among the many BAD names in the CS world this is one of the worst, but EVERYONE in the industry uses it so get used to it. What it means is this: When you have a big complex application like Excel, some monster spreadsheet with numbers and formulae and column widths which the user has created is made up of hundreds or thousands of objects.

There they are sitting in memory, scattered around, little collections of data values and pointers to other objects that hold more data. It is a GRAPH - a large collection of node and edges with pretty much random access to any object or any node. When you want to save it all to disk,  those disk files consist of one ascii character written after another. Disk files are essentialy serial datastructures instead of random access ones. You must somehow convert that GRAPH that is all the objects in your spreadsheet into a single serial list of ascii characters so that you can save it to file, AND you want code that goes the other way as well, reading a serial string of characters and unpacking them all back into a pile of random access data objects in memory.

It sounds horribly messy and in a sense it is. Every object needs to be able to write itself out to disk AND since your graph could easily have loops (there is certainly no problem in code with having two different ways to get at the same object, it is even desireable to have multiple paths through your data). You will want to NOTICE when you have already written out one object and when you need to write it again you want to REFER to some previously written object rather than writing it all out again.

Fortunately, this is something that EVERY object needs to do and that means that you ought to put this code into the Object class and hey, that class was already written for you. Java has serialization built into the object class.

All you need to do is declare the classes that you want to be able to write out as implementing Serializable and then they can be serialized. Most of the Java Library classes like ArrayList and TreeMap, are already marked as Serializable so you just need to do this for the classes that you want to write. I did this for Shape, Shape.Prototype, Shape.Prototype.List, V, VS, PL, HiLo, BBox, Ink, Ink.Norm

That is step 1. Make your classes implement Serializable

The next step is to open up a file, make it into an object stream, and then you can write objects out into that file. Finally to load things back, you can open the file and read the objects back IN THE SAME ORDER THAT YOU WROTE THEM. I find that last condition to be troublesome. What if you change what you write to the file and forget to change the code that reads them back in. TOO SCARY - the easy thing to do is to NEVER write an object file with more than one object. What I mean is just this. Suppose you ACTUALLY needed to write 3 objects out to the file like A,B and C. Easy - build a class Foo with 3 members, A, B and C. Construct a new Foo(A,B,C) and write that one Foo object out to the file. When you want A,B & C back just read in the one Foo object and there they are in nice random access order just as GOD intended.

I never remember how to do this. But it is always the same so I just go copy code from whatever I wrote last that needed to Serialize. I wrote the stubs for these in the Shape class, time to upgrade them to actual serialization code.
--in Shape.Database change

  private static String filename = UC.shapeDatabaseFileName;
  
  public static Database load(){
    Database res = new Database();
    res.put("DOT", new Shape("DOT"));
    try{
      System.out.println("attempting DB load..");
      ObjectInputStream ois = new ObjectInputStream(new FileInputStream(filename));
      res = (Shape.Database) ois.readObject();
      System.out.println("Successful load - found" + res.keySet());
      ois.close();
    } catch(Exception e) {
      System.out.println("Load failed.");
      System.out.println(e);
    }
    return res;
  }
   
  public static void save(){
    try{
      ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(filename));
      oos.writeObject(DB);
      System.out.println("Saved " + filename);
      oos.close();
    } catch(Exception e) {
      System.out.println("Failed database save");
      System.out.println(e);
    }
  }

You will need to define UC.shapeDatabaseFileName:
  public static String shapeDatabaseFileName = "ShapeDB.dat";

Now that we have a function to call that will save the database, I need to call it from somewhere. What I decided to do was to add a line to the keyTyped routine. IF the user types an ASCII CR or LF (13 or 10) I not only clear out the curName, but I also save the database.

--add to keyTyped
    if(c == 0x0D || c == 0x0A){Shape.DB.save();}

==WARNING!

And now the BIG warning that comes with serialization, and here I am just propagating the warning that comes in the Java Docs.

Basically they tell you that you should NOT do what we just did, EXCEPT as an engineer testing your stuff out, and they are right. There are several problems. ONE - if you EVER change any of the fields in any of the classes that you serialized out, well, in that case whatever you saved previously is now in a different form, it is incompatible with what you now want and can no longer be read back in. I believe that the serialization methods in Java ATTEMPT to detect that the class that you are reading back has a different hash code from the one that you saved out so that at least you get an exception thrown when you try to read.

Secondly, even if you did NOT change any of the fields, but just gave someone your source code AND your serialized file there is NO assurance that data that was serialized on one machine with its JVM can be read by the same Java code running on a different machine which may have a different architecture and thus a different Java Virtual Machine. 

The warning is that, while you can use the built in Serialization system to serialize on your machine to create files that you can use, you should NOT assume that you have created a file format that you can use to transport files from one machine to another. Serialization as provided automatically by Java should NOT be considered a DEPLOYMENT solution, it is only a DEVELOPMENT solution. IF you want a genuine file format where users can trade files, then you MUST design and  write your own PROPER serialization format.

::S Test Recognition
--Day 8
==Test Recognition & Refactoring

Now that we can train shapes, we should train a few in and see how well the recognizer can distinguish between the multiple shapes in the database. We will just hack up the PaintInk app that we had for that purpose. I was keeping a single prototype list and adding, (either blending or adding any new strokes), to that list. We will maintain that behavior and just add one more step. It will also take the raw ink and attempt to recognize it into a Shape, and if it finds one (remember it can fail and return null) it will print its name to the screen.

So we add a static message to our PaintInk class

  public static String recognized = "";

We add a line to paint component

  g.drawString(recognized, 700, 40);
  
We add a line into the mouse Released code up at the top right after we construct the ink.

  Ink ink = new Ink();
  Shape s = Shape.recognize(ink); recognized = "Recog: " + ((s != null)?s.name : "UN-RECOGNIZED");

Draw some shapes and see if they match. Worked OK on my machine.

==Refactoring the ShapeTraining

On looking at the code that we just wrote to train shapes I am bothered by how long the mouseRealease method is. This is the way that we wrote it.

  public void mouseReleased(MouseEvent me){
    if(curState != ILLEGAL){
      Ink ink = new Ink();
      Shape.Prototype proto;
      if(pList == null){
        Shape s = new Shape(curName); // create the shape
        Shape.DB.put(curName, s);  // add it to the database
        pList = s.prototypes;      // use its prototype list as the current list
      }
      if(pList.bestDist(ink.norm) < UC.noMatchDist){ // we found a match so blend
        proto = Shape.Prototype.List.bestMatch;
        proto.blend(ink.norm);
      }else {
        proto = new Shape.Prototype();
        pList.add(proto); // new Prototype
      }
      fixMsg(); // technically after adding the first prototype we now know this shape so fix the msg
    }
    repaint();
  }
  
It does the job, BUT now that I reflect on it, I want all of that code located in diffferent places. Part of the refactoring is that I don't like the length of this routine. It far exceeds my prefered length for a function, but more importantly, if I move the code from here into various places in the Shape class it will make it possible to do something that I am going to want to do later, namely to train shapes on the fly. 

It would be NICE if I could write an app that needs a N-W stroke (which isn't in the database), and have the app notice that that shape is not in the database and have the app ask the user, "Hey, I need the shape N-W and I don't see it, could you draw me a few examples.." and it trains and saves the new shape. So if I move the training code from the app, ShapeTrainer, into the Shape class, like by adding train functions, it will be easier in the future to at least think about doing on the fly training.

So here is the refactoring notion:
  
1) we take the code that was either adding or blending the ink with a prototype into a "train" function which we put into the class Prototype.List:

  public void train(Ink.Norm norm){
    if(bestDist(norm) < UC.noMatchDist){ // we found a match so blend
      bestMatch.blend(norm);
    }else{
      add(new Shape.Prototype()); // didn't match so add a new one (from Ink.BUFFER)
    }    
  }  

2) we add some helper functions to the Database class

  private Database(){super(); String dot = "DOT"; put(dot, new Shape(dot));} // make sure DOT exists
  private Shape forceGet(String name){ // always returns Shape..
    if(!DB.containsKey(name)){DB.put(name, new Shape(name));} //..adds new if necessary
    return DB.get(name);
  }
  public void train(String name, Ink.Norm norm){if(isLegal(name)){forceGet(name).prototypes.train(norm);}}
  public static boolean isLegal(String name){return !name.equals("") && !name.equals("DOT");}
  
3) we modify Database load to use the new constructor that was adding DOT

  public static Database load(){
    Database res;
    try{
      System.out.println("attempting DB load..");
      ObjectInputStream ois = new ObjectInputStream(new FileInputStream(filename));
      res = (Shape.Database) ois.readObject();
      System.out.println("Successful load - found" + res.keySet());
      ois.close();
    } catch(Exception e) {
      System.out.println("Load failed.");
      System.out.println(e);
      res = new Database();
    }
    return res;
  }
    
4) and now with most of the training being done in the Shape classes, the mouse code in the shape Trainer
simplifies a lot.

  public void mouseReleased(MouseEvent me){
    Ink ink = new Ink();
    Shape.DB.train(curName, ink.norm); // this is safe because legal name testing is done in Database
    setState(); // possibly convert previously UNKNOWN to KNOWN
    repaint();
  }  


==Refactor the Training App 

We have already put much of the functionality of training into the Shape class. We will now add another nested class to Shape that will let us move more of the functionality out of the ShapeTrainer application into the shape class that will help us with the desire to eventually merge training with editing.


--Add Trainer class to Shape
  public static class Trainer implements I.Show, I.Area{
    private Trainer(){}; // singleton
  }

We will implement the I.Show and I.Area functions in just a moment. They are almost all copied entirely out of the old ShapeTrainer application.

--in Shape add the static single Trainer
  public static Trainer TRAINER = new Trainer();

I will hop ahead a bit and show you what the ShapeTrainer App will look like when we finish the refactoring:

  public class ShapeTrainer extends WinApp{
    public ShapeTrainer(){super("Shape Trainer", UC.mainWindowWidth, UC.mainWindowHeight);}
  
    public void paintComponent(Graphics g){Shape.TRAINER.show(g);}
  
    public void mousePressed(MouseEvent me){Shape.TRAINER.dn(me.getX(),me.getY()); repaint();}
    public void mouseDragged(MouseEvent me){Shape.TRAINER.drag(me.getX(),me.getY()); repaint();}
    public void mouseReleased(MouseEvent me){Shape.TRAINER.up(me.getX(),me.getY()); repaint();}
      
    public void keyTyped(KeyEvent ke) {Shape.TRAINER.keyTyped(ke);repaint();}
    
    public static void main(String[] args){PANEL= new ShapeTrainer(); WinApp.launch();}
  }

As you can see, the mouse events in the App just chain down to the TRAINER Area routines. The paintComponent() in the App just calls the TRAINER show routine. We build a keyEvent function into the TRAINER as well. And finally, we moved ALL the former static variables that tracked the current name and the state all into the TRAINER app as well. You just copy each chunk of code from the current ShapeTrainer into the Shape.Trainer class, and rename it. So paintComponent() turned into show().

In a sense, the only things that get left behind in the WinApp named ShapeTrainer are the calls to repaint(). That is a function that is only implemented by a WinApp, so you can call it from a WinApp function but NOT from something in the Shape class.

The final Trainer class looks like this:

  //----------------------Trainer---the App -----------------------
  public static class Trainer implements I.Show, I.Area{
    
    private Trainer(){}; // Singlton
    
    public static String UNKNOWN = " <- this name is currently Unknown.";
    public static String ILLEGAL = " <-this name is NOT a legal Shape name.";
    public static String KNOWN   = " <-this is a known shape.";
  
    public static String curName = "";
    public static String curState = ILLEGAL;
  
    public static Shape.Prototype.List pList = new Shape.Prototype.List();
  
    public void setState(){
      curState = !Shape.DB.isLegal(curName) ? ILLEGAL : UNKNOWN;
      if(curState == UNKNOWN){
        if(Shape.DB.isKnown(curName)){
          curState = KNOWN;
          pList = Shape.DB.get(curName).prototypes;
        }else{ // it really is UNKNOWN
          pList = null;
        }
      }
    }
  
    // I.Show functions
    public void show(Graphics g){
      G.fillBack(g);
      g.setColor(Color.BLACK);
      g.drawString(curName, 600,30);
      g.drawString(curState, 700,30);
      g.setColor(Color.RED);
      Ink.BUFFER.show(g);
      if(pList != null){pList.show(g);}
    }
  
    // I.Area functions
    public boolean hit(int x, int y){return true;}
    public void dn(int x, int y){Ink.BUFFER.dn(x,y);}
    public void drag(int x, int y){Ink.BUFFER.drag(x,y);}
    public void up(int x, int y){
      Ink.BUFFER.up(x,y);
      Ink ink = new Ink();
      Shape.DB.train(curName, ink.norm); // safe because legal name test is done in Database
      setState(); // possibly convert previously UNKNOWN to KNOWN
    }
  
    public void keyTyped(KeyEvent e) {
      char c = e.getKeyChar();
      System.out.println("Typed: " + c); // debug
      if(c == 0x0D || c == 0x0A){Shape.DB.save();}
      curName = (c == ' ' || c == 0x0D || c == 0x0A)? "": curName + c; // x0D & x0A are ascii CR & LF
      setState();
    }
  }

With those changes we will eventually be able to build a WinApp that will be able to swich between displaying the music app and displaying the training app with code that works something like this:

  public static boolean training = false; // high level mode switch
  
  public void paintComponent(Graphics g){
    I.Show view = training ? Shape.TRAINER : Layer.ALL;
    view.show(g);
    Ink.BUFFER.show(g);
  }


::S Summary
==Chapter Summary

We covered a lot in this chapter. We wrote bounding box code and LoHi/Range code to support it. We have covered coordinate transformation - translation and scaling, and implemented it with isomorphic scaling. We have implemented subsampling. We build a nearest neighbor matching system that essentially uses Euclidean distance on our normalized ink strokes. We wrote code to average multiple input shapes together to smooth out our prototype data. And we have built an application that allows us to train Shapes when we need them. We have serialization code that lets us save and load the shapes that we have trained. We wrote an app that did a bit of testing of the recognition AND that compressed ink by reusing chunks of ink that were similar to one another.  

The next section will be a code dump so that you can synchronize. Next steps, with recognition in place we are ready to start building the Reaction Framework.

::S JavaCode

==Ink.java
  package reaction;
  
  import graphics.*;
  import java.awt.*;
  import java.io.Serializable;
  import java.util.ArrayList;
  
  public class Ink implements I.Show, Serializable{
    public static Buffer BUFFER = new Buffer();
  
    public Norm norm;
    public G.VS vs;
  
    public static G.VS TEMP = new G.VS(100,100,100,100); // for testing, a box that we will move ink to
  
    public Ink(){
      norm = new Norm(); // create the PL that is this Ink.
      vs = BUFFER.bbox.getNewVS();
    }
    public void show(Graphics g){g.setColor(UC.inkColor); norm.drawAt(g, vs);}
  
    //--------------------Norm---------------------
    public static class Norm extends G.PL implements Serializable{
      public static final int N = UC.normSampleSize, MAX = UC.normCoordMax;
      public static final G.VS NCS = new G.VS(0,0,MAX,MAX); // the coordinate box for Transforms
      public Norm(){
        super(N);
        BUFFER.subSample(this);
        G.V.T.set(BUFFER.bbox, NCS);
        transform();
      }
  
      public void blend(Norm norm, int nBlend){
        for(int i = 0; i<N; i++){
          points[i].blend(norm.points[i], nBlend);
        }
      }
      
      public int dist(Norm n){
        int res = 0;
        for(int i = 0; i<N; i++){
          int dx = points[i].x - n.points[i].x, dy = points[i].y - n.points[i].y;
          res += dx*dx + dy*dy;
        }
        return res;
      }
      
      public void drawAt(Graphics g, G.VS vs){ // expands Norm to fit in vs
        G.V.T.set(NCS, vs); // prepare to move from normalized CS to vs
        for(int i = 1; i<N; i++){
          g.drawLine(points[i-1].tx(), points[i-1].ty(), points[i].tx(), points[i].ty());
        }
      }
    }
  
    //--------------------List-------------------------
    public static class List extends ArrayList<Ink> implements I.Show{
      public void show(Graphics g){for(Ink ink : this){ink.show(g);}}
    }
    
    //-------------------Ink.Buffer-----------
    public static class Buffer extends G.PL implements I.Show, I.Area{
      public static final int MAX = UC.inkBufferMax; // maximum size of buffer
      public int n; // how many points are actually in the buffer.
      public G.BBox bbox = new G.BBox();
      
      private Buffer(){super(MAX);} // create the PL with MAX points
      
      public void add(int x, int y){if(n<MAX){points[n++].set(x,y);bbox.add(x,y);}}
      public void clear(){n = 0;}
      public void subSample(G.PL pl){
        int k = pl.size();
        for(int i = 0; i<k; i++){pl.points[i].set(this.points[i*(n-1)/(k-1)]);}
      }
      public void show(Graphics g){this.drawN(g, n);bbox.draw(g);}
      public boolean hit(int x, int y){return true;} // any point COULD go into ink
      public void dn(int x, int y){clear(); add(x,y); bbox.set(x,y);}
      public void drag(int x, int y){add(x,y);} // add each point as it comes in
      public void up(int x, int y){add(x,y);}
    }
  }

==Shape.java
  package reaction; 
  
  import graphics.*;
  import java.awt.*;
  import java.awt.event.KeyEvent;
  import java.io.*;
  import java.util.ArrayList;
  import java.util.Collection;
  import java.util.TreeMap;
  
  public class Shape implements Serializable{
    public static Shape.Database DB = Shape.Database.load();
    public static Shape DOT = DB.get("DOT");
    public static Collection<Shape> LIST = DB.values();
    public static Trainer TRAINER = new Trainer();
    
    public Prototype.List prototypes = new Prototype.List();
    public String name;
    
    public Shape(String name){this.name = name;}
  
    public static Shape recognize(Ink ink){ // note: can return null
      if(ink.vs.size.x < UC.dotThreshold && ink.vs.size.y < UC.dotThreshold){return DOT;}
      Shape bestMatch = null; int bestSoFar = UC.noMatchDist; // assume no match
      for(Shape s:LIST){
        int d = s.prototypes.bestDist(ink.norm);
        if(d < bestSoFar){bestMatch = s; bestSoFar = d;}
      }
      return bestMatch;
    }
    //------------------Prototype-----------------
    public static class Prototype extends Ink.Norm implements Serializable{
      int nBlend = 1;
  
      public void blend(Ink.Norm norm){blend(norm, nBlend); nBlend++;}
      
      //-------------------Prototype.List-----------
      public static class List extends ArrayList<Prototype> implements I.Show, Serializable{
        private static int m = 10, w = 60; private static G.VS showbox = new G.VS(m,m,w,w);
        
        public void show(Graphics g){ // draw a list of boxes across top of screen
          g.setColor(Color.ORANGE);
          for(int i = 0; i<size(); i++){
            Prototype p = get(i); int x = m + i*(m+w);
            showbox.loc.set(x, m); // march the showbox across the top of the screen
            p.drawAt(g, showbox);
            G.V p0 = p.points[0]; int x0 = p0.tx(), y0 = p0.ty();
            g.setColor(Color.RED); g.fillOval(x0-1,y0-1,3,3); g.setColor(Color.ORANGE);
            g.drawString(""+p.nBlend,x,20);
          }
        }
        
        public static Prototype bestMatch; // set as side effect of bestDist()
        
        public int bestDist(Ink.Norm norm){
          bestMatch = null;
          int bestSoFar = UC.noMatchDist; // assume no match
          for(Prototype p : this) {
            int d = p.dist(norm);
            if(d < bestSoFar){
              bestMatch = p;
              bestSoFar = d;
            }
          }
          return bestSoFar;
        }
  
        public void train(Ink.Norm norm){
          if(bestDist(norm) < UC.noMatchDist){ // we found a match so blend
            bestMatch.blend(norm);
          }else{
            add(new Shape.Prototype()); // didn't match so add a new one (from Ink.BUFFER)
          }
        }
      } // end Prototype.List
    } // end Prototype
    
    //--------------Shape.Database-----------------
    public static class Database extends TreeMap<String,Shape>{
      private static String filename = UC.shapeDatabaseFileName;
  
      private Database(){super(); String dot = "DOT"; put(dot, new Shape(dot));} // make sure DOT exists
      private Shape forceGet(String name){ // always returns Shape..
        if(!DB.containsKey(name)){DB.put(name, new Shape(name));} //..adds new if necessary
        return DB.get(name);
      }
      public void train(String name, Ink.Norm norm){if(isLegal(name)){forceGet(name).prototypes.train(norm);}}
      
      public static Database load(){
        Database res;
        try{
          System.out.println("attempting DB load..");
          ObjectInputStream ois = new ObjectInputStream(new FileInputStream(filename));
          res = (Shape.Database) ois.readObject();
          System.out.println("Successful load - found" + res.keySet());
          ois.close();
        } catch(Exception e) {
          System.out.println("Load failed.");
          System.out.println(e);
          res = new Database();
        }
        return res;
      }
      public static void save(){
        try{
          ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(filename));
          oos.writeObject(DB);
          System.out.println("Saved " + filename);
          oos.close();
        } catch(Exception e) {
          System.out.println("Failed database save");
          System.out.println(e);
        }
      }
  
      boolean isKnown(String name){return containsKey(name);}
      boolean isUnknown(String name){return !containsKey(name);}
      boolean isLegal(String name){return !name.equals("") && !name.equals("DOT");}
    } // end Database
      
    //----------------------Trainer---the App -----------------------
    public static class Trainer implements I.Show, I.Area{
      
      private Trainer(){}; // Singlton
      
      public static String UNKNOWN = " <- this name is currently Unknown.";
      public static String ILLEGAL = " <-this name is NOT a legal Shape name.";
      public static String KNOWN   = " <-this is a known shape.";
  
      public static String curName = "";
      public static String curState = ILLEGAL;
  
      public static Shape.Prototype.List pList = new Shape.Prototype.List();
  
      public void setState(){
        curState = !Shape.DB.isLegal(curName) ? ILLEGAL : UNKNOWN;
        if(curState == UNKNOWN){
          if(Shape.DB.isKnown(curName)){
            curState = KNOWN;
            pList = Shape.DB.get(curName).prototypes;
          }else{ // it really is UNKNOWN
            pList = null;
          }
        }
      }
  
      // I.Show functions
      public void show(Graphics g){
        G.fillBack(g);
        g.setColor(Color.BLACK);
        g.drawString(curName, 600,30);
        g.drawString(curState, 700,30);
        g.setColor(Color.RED);
        Ink.BUFFER.show(g);
        if(pList != null){pList.show(g);}
      }
  
      // I.Area functions
      public boolean hit(int x, int y){return true;}
      public void dn(int x, int y){Ink.BUFFER.dn(x,y);}
      public void drag(int x, int y){Ink.BUFFER.drag(x,y);}
      public void up(int x, int y){
        Ink.BUFFER.up(x,y);
        Ink ink = new Ink();
        Shape.DB.train(curName, ink.norm); // safe because legal name test is done in Database
        setState(); // possibly convert previously UNKNOWN to KNOWN
      }
  
      public void keyTyped(KeyEvent e) {
        char c = e.getKeyChar();
        System.out.println("Typed: " + c); // debug
        if(c == 0x0D || c == 0x0A){Shape.DB.save();}
        curName = (c == ' ' || c == 0x0D || c == 0x0A)? "": curName + c; // x0D & x0A are ascii CR & LF
        setState();
      }
    }
  }

==PaintInk.java
  package sandbox;
  
  import graphics.*;
  import reaction.*;
  import reaction.Shape;
  import java.awt.*;
  import java.awt.event.MouseEvent;
  
  public class PaintInk extends WinApp{
    public static Ink.List inkList = new Ink.List();
    public static Shape.Prototype.List pList = new Shape.Prototype.List();
    public static String recognized = "";
  
    public PaintInk(){
      super("Paint Ink", UC.mainWindowWidth, UC.mainWindowHeight);
      //inkList.add(new Ink());
    }
    @Override
    public void paintComponent(Graphics g){
      G.fillBack(g);
      g.setColor(Color.RED); Ink.BUFFER.show(g);
      inkList.show(g);
      g.drawString(recognized, 700, 40);
      pList.show(g);
      //g.drawString("points: "+Ink.BUFFER.n, 600,30);
      if(inkList.size()>1){
        int last = inkList.size()-1;
        int dist = inkList.get(last).norm.dist(inkList.get(last-1).norm);
        g.setColor(dist>UC.noMatchDist?Color.RED:Color.BLACK); // black for same red for different
        g.drawString("Dist: "+dist, 600, 60);
      }
    }
  
    public void mousePressed(MouseEvent me){Ink.BUFFER.dn(me.getX(),me.getY()); repaint();}
    public void mouseDragged(MouseEvent me){Ink.BUFFER.drag(me.getX(),me.getY()); repaint();}
    public void mouseReleased(MouseEvent me){
      Ink ink = new Ink();
      Shape s = Shape.recognize(ink); 
      recognized = "Recog: " + ((s != null)?s.name : "UN-RECOGNIZED");
  
      Shape.Prototype proto;
      inkList.add(ink);
      if(pList.bestDist(ink.norm) < UC.noMatchDist){ // we found a match so blend
        proto = Shape.Prototype.List.bestMatch;
        proto.blend(ink.norm);
      }else{
        proto = new Shape.Prototype();
        pList.add(proto); // new Prototype
      }
      ink.norm = proto;
      repaint();
    }
  
    public static void main(String[] args){PANEL=new PaintInk();WinApp.launch();}
  }

==ShapeTrainer.java  
  package reaction;
  
  import graphics.*;
  import java.awt.*;
  import java.awt.event.KeyEvent;
  import java.awt.event.MouseEvent;
  
  public class ShapeTrainer extends WinApp{
    public ShapeTrainer(){super("Shape Trainer", UC.mainWindowWidth, UC.mainWindowHeight);}
  
    public void paintComponent(Graphics g){Shape.TRAINER.show(g);}
  
    public void mousePressed(MouseEvent me){Shape.TRAINER.dn(me.getX(),me.getY()); repaint();}
    public void mouseDragged(MouseEvent me){Shape.TRAINER.drag(me.getX(),me.getY()); repaint();}
    public void mouseReleased(MouseEvent me){Shape.TRAINER.up(me.getX(),me.getY()); repaint();}
    
    public void keyTyped(KeyEvent ke) {Shape.TRAINER.keyTyped(ke);repaint();}
    
    public static void main(String[] args){PANEL= new ShapeTrainer(); WinApp.launch();}
  }

==G.java
  package graphics;
  
  import java.awt.*;
  import java.io.Serializable;
  import java.util.Random;
  
  public class G{
    public static Random RND = new Random();
    public static int rnd(int max){return RND.nextInt(max);}
    public static Color rndColor(){return new Color(rnd(256),rnd(256),rnd(256)); }
    public static void fillBack(Graphics g){g.setColor(Color.WHITE); g.fillRect(0,0,3000,3000);}
    public static void drawCircle(Graphics g, int x, int y, int r){g.drawOval(x-r,y-r,r+r,r+r);}
  
    //-----------------------V------------------------
    public static class V implements Serializable{
      public static Transform T = new Transform();
      public int x,y;
    
      public V(int x, int y){this.set(x,y);}
      public V(V v){this.set(v);} // copy existing V
      public void set(V v){x = v.x; y=v.y;};
  
      public void set(int x, int y){this.x = x; this.y = y;}
      public void add(V v){x += v.x; y += v.y;} // vector addition
      public void blend(V v, int k){set((k*x + v.x)/(k+1), (k*y + v.y)/(k+1));}
      
      public void setT(V v){set(v.tx(), v.ty());}
      public int tx(){return x*T.n/T.d + T.dx;}
      public int ty(){return y*T.n/T.d + T.dy;}
      //-----------------------Transform------------------------
      public static class Transform implements Serializable{
        public int dx, dy, n, d;
  
        public void set(VS oVS, VS nVS){
          setScale(oVS.size.x, oVS.size.y, nVS.size.x, nVS.size.y);
          dx = setOff(oVS.loc.x, oVS.size.x, nVS.loc.x, nVS.size.x);
          dy = setOff(oVS.loc.y, oVS.size.y, nVS.loc.y, nVS.size.y);
        }
        public void set(BBox from, VS to){
          setScale(from.h.size(), from.v.size(), to.size.x, to.size.y);
          dx = setOff(from.h.lo, from.h.size(), to.loc.x, to.size.x);
          dy = setOff(from.v.lo, from.v.size(), to.loc.y, to.size.y);
        }
  
        void setScale(int oW, int oH, int nW, int nH){
          n = (nW>nH)?nW:nH;  d = (oW>oH)?oW:oH;
        }
        int setOff(int oX, int oW, int nX, int nW){
          return (-oX-oW/2)*n/d + nX + nW/2;
        }
        
      } // end of Transform
    } // end of V
  
    //-----------------------VS-----------------------
    public static class VS implements Serializable{
      public V loc, size;
      public VS(int x, int y, int w, int h){loc = new V(x,y); size = new V(w,h);}
      public void fill(Graphics g, Color c){g.setColor(c); g.fillRect(loc.x,loc.y,size.x,size.y);}
      public boolean hit(int x, int y){return loc.x<=x && loc.y <=y && x<=(loc.x+size.x) && y<=(loc.y+size.y);}
      
      public int xL(){return loc.x;}
      public int xH(){return loc.x + size.x;}
      public int xM(){return (loc.x + loc.x + size.x)/2;}
      public int yL(){return loc.y;}
      public int yH(){return loc.y + size.y;}
      public int yM(){return (loc.y + loc.y + size.y)/2;}
    }
    //-----------------------LoHi---------------------
    public static class LoHi implements Serializable{ // range from lo to hi
      public int lo, hi;
      public LoHi(int min, int max){lo = min; hi = max;}
      public void set(int v){lo = v; hi = v;} // first value into the set
      public void add(int v){if(v<lo){lo=v;} if(v>hi){hi=v;}} // move bounds if necessary
      public int size(){return (hi-lo) > 0 ? hi-lo : 1;}
      public int constrain(int v){if(v<lo){return lo;} else return (v<hi)?v:hi;}
    }
    //-----------------------BBox---------------------
    public static class BBox implements Serializable{ // Bounding Box
      LoHi h, v;  // horizontal and vertical ranges.
      public BBox(){h = new LoHi(0,0); v = new LoHi(0,0);}
      public void set(int x, int y){h.set(x); v.set(y);} // sets it to a single point
      public void add(int x, int y){h.add(x); v.add(y);}
      public void add(V v){add(v.x, v.y);}
      public VS getNewVS(){return new VS(h.lo, v.lo, h.hi-h.lo, v.hi-v.lo);}
      public void draw(Graphics g){g.drawRect(h.lo, v.lo, h.hi-h.lo, v.hi-v.lo);}
    }
    //-----------------------PL-----------------------
    public static class PL implements Serializable{ // Polyline
      public V[] points;  // we keep an array of points
      public PL(int count){
        points = new V[count]; // allocate the array 
        for(int i = 0; i < count; i++) { points[i] = new V(0, 0); } // populate it with V objects
      }
      public int size(){return points.length;}
      public void drawN(Graphics g, int n){  // used to draw an initial portion of the full array
        for(int i = 1; i < n; i++) {
          g.drawLine(points[i - 1].x, points[i - 1].y, points[i].x, points[i].y);
        }
        drawNDots(g,n);
      }
      public void draw(Graphics g){drawN(g, points.length);} // draws the whole array.
      public void drawNDots(Graphics g, int n){
        g.setColor(Color.BLUE);
        for(int i=0; i<n; i++){drawCircle(g, points[i].x, points[i].y, 4);}
      }
      public void transform(){
        for(int i = 0; i<points.length; i++){points[i].setT(points[i]);}
      }
    }
   
    // parabolic spline
    public static void spline(Graphics g, int ax, int ay, int bx, int by, int cx, int cy, int n){
      if(n==0){g.drawLine(ax, ay, cx, cy); return;}
      int abx = (ax + bx)/2, aby =(ay + by)/2;
      int bcx = (bx + cx)/2, bcy =(by + cy)/2;
      int abcx = (abx + bcx)/2, abcy =(aby + bcy)/2;
      spline(g,ax,ay,abx,aby,abcx,abcy,n-1);
      spline(g,abcx,abcy,bcx,bcy,cx,cy,n-1);
    }
  }
::C Reactions
::S Outline
==Reaction Outline & Vocabulary

Before we start building the next set of classes it would be good to review how the architecture works. Create these 4 classes in your reaction package.

==Gesture

Gestures keep track of WHAT was done on the screen and WHERE it was done. This sounds like what we are already doing in Ink, but it is just a tiny bit different from Ink. Ink is a Norm plus a VS box showing where it was on the screen. After we have done our recognition and know what Shape the Norm represented, we can throw out the Norm and just keep the Shape. Thus a Gesture, is a Shape and a VS box. 

The Ink is essentially a memory of the 25 of the points that made up the mouse event and the box. The ink still "remembers" which direction it was drawn in. For example consider a circle gesture, an "O". The Ink knows whether it was drawn counterclockwise or clockwise, whereas the Shape is just "O". Thus a Gesture is in some sense more abstract than Ink.

A Gesture object is also conceptually much smaller than Ink.  I do have to say "conceptually" smaller, because in fact a Shape object lugs around a list of several norms that are the prototypes that are used to recognize that Shape - so in fact a single Shape object could be much larger than a single Norm. None the less, by the time you have drawn 30, E-E, strokes at different places on the screen, the Ink associated with those would be 30 different Norms, but the 30 Gestures are just 30 copies of a single pointer to that potentially large Shape object named "E-E". Basically, after we have recognized the ink we can throw the ink out and just remember the Gesture.

--create a Gesture class
  public class Gesture{
    public Shape shape;
    public G.VS vs;
  }

==Layer
We will need a class Layer, which is used to do the z-ordering when we draw things to the screen. All graphics programs must draw things on the screen from background to foregound and Layer is the helper class that keeps  a list of all the visible items that are all the same distance from the background. So our output will consist of drawing all the layers in the proper layer order. Anything that wants to get onto the screen needs to be in one of those Layers.

A single layer is just a list of objects that can show themselves. Furthermore , since a layer is nothing but showable objects, we can declare that the layer itself implements I.Show and can write the show routing that is the loop that showes everything in the Layer.

We will eventually emblish this class to have a single static Layer that will consist of ALL the other layers, which will allow us to just show all the layers in order.

--create a Layer class
  public class Layer extends ArrayList<I.Show> implements I.Show{
    public String name;
    public Layer(String name){this.name = name;}
    public void show(Graphics g){for(I.Show item:this){item.show(g);}}
  }
  

==Reaction

We will need some more interfaces that define the actual functions that make up a reaction

--create I.React
  public interface Act{public void act(Gesture g);} // what you do if you react to some gesture
  public interface React extends Act{public int bid(Gesture g);} // how badly you want to so something

There will be many different types of Reactions in the system, but there are some things that they all have in common so we will need a Reaction class that will do that bookkeeping and be the base class which all reactions will extend. So our Reaction class will be abstract - it will NOT actually implement I.React - it's children must do that so we declare the base class to be abstract and declare that it implements I.React, which is the contract that all its children must obey. 

The bookkeeping that will be kept directly in the Reaction class consists mostly of the maintainence of lists of reactions, being sure that they are being properly added or removed from the marketplace.  

--Create the Reaction class

  public abstract class Reaction implements I.React{
    public Shape shape;
  }
  
What the reaction class does NOT do is actually implement the two function, bid and act, that characterize a reaction. Only subclasses of Reaction will actually have bid and act routines. Reactions will actually typically live in exactly two places - 1) a Reaction list that is owned by a Mass. So a single object like a noteHead will have a list of all the reactions for that one note head. Those reactions are kept in a list so that if we delete that noteHead all its reactions can go away. 2) each reaction also lives in the marketplace which is essentially a Map<Shape, Reaction.List>. Unlike the Mass lists, which are all the reactions associated with a single Mass, the marketplace will keep the reactions on list that are associated with a single shape like "S-S". That way, when the recognizer sees a "S-S" shape, it can go to that one list and only fire the reactions that were looking for "S-S". 

Since Reactions live in 2 places, if you ever delete one, you must go find it in the two different lists that it lives on and delete it from both places. This is the sort of bookkeeping that is done in the abstract reaction class. Furthermore, there will be times when we want to keep a mass in existance and leave a reaction in its list, but want to be able to !ndisable the reaction from working. This can be acomplished by removing it from the byShape list so that the marketplace never sees it. So we will used the vocabulary "enable" and "disable" to refer to whether or not the reaction is in that second place, the byShape Map.

==Mass

A Mass is the type of object that lives in a layer, as a result a Mass must implement I.Show so that it can show itslef. That is the output side of a Mass. A Mass also has an input side - it will maintain a list of reactions that are looking for gestures that happened close to where the Mass is located on the screen. So the class Mass itself is abstract - it is the ancestor of all the different types of object that look different and that can react in different ways to different gestures. Mass holds that stuff that is common to all those types of objects, in particular the maintainence of those lists. Think about it, when you delete a mass, since all masses live in a layer somewere, it must remove itself from the appropriate layer, and then it must delete every reaction on its list and untangle them from the "marketplace" where all the bidding on reactions takes place. So Mass is the class that does the bookkeeping for the layers and the reactions.

--create the Mass class
  public abstract class Mass extends Reaction.List implements I.Show{
    public Layer layer;
  }

::S Reaction
==Reaction Class
  public abstract class Reaction implements I.React{
    private static Map byShape = new Map(); // our marketplace of all enabled shapes
    public static List initialReactions = new List(); // used by Undo to restart everything.   
  
    public Shape shape;
    
    public Reaction(String shapeName){
      shape = Shape.DB.get(shapeName);
      if(shape == null){System.out.println("WTF? - Shape.DB don't know about: "+shapeName);}
    }
    
    //---------------------LIST----------------------
    public static class List extends ArrayList<Reaction>{ }
    //---------------------MAP-----------------------
      public static class Map extends HashMap<Shape, List>{ }
  }
  
As you can see we have two nested classes, wrappers for lists of reactions and for the Map that will take us from a given shape to all the reactions that are looking for that particular shape. We have a single byShape Map and we have made it private. The Reaction class will eventually have a static method, best, that will give you back the winning reaction, if there was one, that was looking for that particular shape which won the bid.

We will finish off that class by working from the bottom up.

First we add a function to the Map class. One of the reasons for the wrapper is so that we can add a routine that you almost always need for this type of Map. The problem is that if you look up a shape that is not currently in the map, it returns a null rather than returning an empty list so that you CAN add something to that list.

  public List getList(Shape s){ // always succeeds
    List res = get(s);
    if(res == null){res = new List(); put(s,res);}
    return res;
  }

With that function in place we can now place the enabling and disabling functions into the Reaction class

  // reactions live in 2 places: 1) List in Mass and 2) the byShape Map
  // enable and disable add and remove them only from the byShape Map..
  // .. because if you are not in byShape you can't bid and react, you are disabled!
  public void enable(){List list = byShape.getList(shape); if(!list.contains(this)){list.add(this);}}
  public void disable(){List list = byShape.getList(shape); list.remove(this);}

Next we add functions to the List wrapper. We want to wrap the addition and removal of reactions to Reaction lists. Whenever we add a reaction to a mass list, it goes into two places, both the list associated with the mass and the list that is tucked into the byShape Map and the same goes for removal of a single reaction. We also want to be able to systematically go through an entire reaction list, presumably belonging to a Mass, and remove them all when for example we delete the Mass. Put these functions into Reaction.List:

  public void addReaction(Reaction r){add(r); r.enable();}
  public void removeReaction(Reaction r){ remove(r); r.disable();}
  // this next routine is tricky - to avoid concurrent array mods you first remove all from shape map, then clear
  public void clearAll(){for(Reaction r : this){r.disable();} this.clear();}
 
And while we are writing Reaction.List functions we might as well also write the function that runs the list that came from the byShape map looking for the loBid:

  public Reaction loBid(Gesture g){ // can return null - list is Empty or no one wants to bid.
    Reaction res = null; int bestSoFar = UC.noBid; 
    for(Reaction r : this){
      int b = r.bid(g);
      if(b < bestSoFar){bestSoFar = b; res = r;}
    }
    return res;
  }

That function needed a limit, a noBid value that any reaction can use if it does NOT want to win a bid in the marketplace, so add this to UC

  public static final int noBid = 10_000;

And with that function in place Reaction can now have a single static function that returns the best reaction for ink that was recognized as being a particular shape.

  public static Reaction best(Gesture g){return byShape.getList(g.shape).loBid(g);} // can return null  

==Reaction.java
  package reaction;
  import graphics.*;
  import java.util.ArrayList;
  import java.util.HashMap;
    
  public abstract class Reaction implements I.React{
    public Shape shape;
    private static Map byShape = new Map();
    public static List initialReactions = new List(); // used by Undo to restart everything.   
    
    public Reaction(String shapeName){
      shape = Shape.DB.get(shapeName);
      if(shape == null){System.out.println("WTF? - Shape.DB don't know about: "+shapeName);}
    }
    public void enable(){List list = byShape.getList(shape); if(!list.contains(this)){list.add(this);}}
    public void disable(){List list = byShape.getList(shape); list.remove(this);}
      
    public static Reaction best(Gesture g){return byShape.getList(g.shape).loBid(g);} // can return null
    
    //---------------------LIST----------------------
    public static class List extends ArrayList<Reaction>{
      public void addReaction(Reaction r){add(r); r.enable();}
      public void removeReaction(Reaction r){ remove(r); r.disable();}
      // this next routine is tricky - to avoid concurrent array mods you first remove all from shape map, then clear
      public void clearAll(){for(Reaction r : this){r.disable();} this.clear();}
    
      public Reaction loBid(Gesture g){ // can return null - list is Empty or no one wants to bid.
        Reaction res = null; int bestSoFar = UC.noBid;
        for(Reaction r : this){
          int b = r.bid(g);
          if(b < bestSoFar){bestSoFar = b; res = r;}
        }
        return res;
      }
    } // end of LIST
    
    //----------------------MAP---------------------
    public static class Map extends HashMap<Shape, List>{
      public List getList(Shape s){ // always succeeds
        List res = get(s);
        if(res == null){res = new List(); put(s,res);}
        return res;
      }
    } // end of MAP
  }

  
::S Layer

==Layer.java (with bug - read note)
  package marlin.reactions;
  import marlin.I;
  import java.awt.*;
  import java.util.ArrayList;
  import java.util.HashMap;
    
  public class Layer extends ArrayList<I.Show> implements I.Show{
    public String name;
    
    public static Layer ALL = new Layer("ALL");
    public static HashMap<String, Layer> byName = new HashMap<>();
    
    public Layer(String name){
      this.name = name;
      if(!name.equals("ALL")){ALL.add(this);}
      byName.put(name, this);
    }
    public void show(Graphics g){for(I.Show item : this){item.show(g);}}
  }

Notice that while we said that layers are used to hold Mass objects, We do have one layer, ALL, that instead of holding Mass objects, it holds all the other Layers instead. This is perfectly OK, we DO want to be able to show things that do NOT have reactions associated with them. Just warning you that just because ALL Mass objects live in Layers it doesn't mean that everything living in a Layer must be a Mass even if MOST of them are.

NOTE: I have a bug in the above code. Sure I could have fixed it and pretended that I didn't make this mistake when I first wrote the code, but as an intermediate student you need to learn from MY mistakes :). 

My bug was this, I got a java initialization error caused by a null pointer during the static initialization phase. The problem is that my two static variables in this class, the Layer, ALL, and the Map, byName, are in the wrong order. WHAT? 

notice that the line createing ALL calls the constructor Layer and that constructor Layer writes into the byName map. That is the bug - the byName map did not YET exist when the constructor was called to create the ALL layer. By swapping the order of those two lines, the Map gets created BEFORE you call the constructor to create the ALL layer.

So yes, swap the order of those two lines before using this code.
  public static HashMap<String, Layer> byName = new HashMap<>();
  public static Layer ALL = new Layer("ALL");

Sure, I could have reordered those two lines and said nothing and it all would have worked fine and you would never know that you CAN INDEED get bugs in the initialization of your classes.

This can also happens when you start building mulit-class monster projects and discover that you can get bugs caused because the classes are loading in a different order than you thought they did.

These initialization bugs can be tricky. The primary reason being that they happen while the system is initializing its classes which generally happens before you can do things like invoke the debugger or use System.out.println to fire off error messages. 

There is a tendancy to think that initialization happens by magic automatically because for the most part it does BUT that static initialization is just running code and that code can have bugs in it. 

Those initial assignements of values to static variables CAN call code that loads other classes, which causes other assignments to happen. Initializing static variables is just more CODE, meaning that it CAN have ordering dependencies which you must respect. 
  
::S Mass
==Mass.java

  package reaction;
  import graphics.*;
  import java.awt.*;
    
  public abstract class Mass extends Reaction.List implements I.Show{
    public Layer layer;
    public Mass(String layerName){
      this.layer = Layer.byName.get(layerName);
      if(layer!=null){layer.add(this);} else {System.out.println("BAD LAYER NAME-" + layerName);}
    }
    public void deleteMass(){
      clearAll(); // clears all reactions from this list AND from the Reaction byShape Map
      layer.remove(this); // remove self from layers.
    }
    public void show(Graphics g){}
  }


Mass is pretty simple. Most of the work, the code to display a mass, will be done in subclasses that actually implement the show routine and that add all the Reactions that this mass will need. 

I DID implement show right here in abstract Mass. As you can see, it does NOTHING. This means that I can have Masses that have reactions but show nothing on the screen. I could have left this out which would FORCE you to put a null show routine in a Mass that shows nothing. This way you get nothing for free! :) Usually you will override show.

== A Bug
I now have to do something that I don't like to do. I am going to fix a bug in this code that will not show up until very late in this class. Normally, I prefer to leave all the bugs in the code, and wait until we trip over them in class, when I can go through the process of debugging and tracking them down so that you can learn something about tracking and fixing bugs.

Unfortunately, this bug was tricky and took me several days to track down when it first occured many years ago, and I found that if I just leave it in, it can happens at any time and even though I know it is there and am waiting for it to show up, sometimes it does NOT show up, or worse, it shows up at the wrong time and I think it is some OTHER bug and waste time looking in the wrong places.

SO I am going to fix this bug right now even though we did not trip over it in class. And it means that I will tell you to write code now without a good explanation for why we need it.

The bug that I saw, years ago was this: When I finally got to the section where I had multiple different types of masses and I wanted to delete one of them from the layers I would call the ArrayList.remove() routine to remove the mass and it would remove the wrong one. This was a bug in the ArrayList code which is part of the Java library. I din't write that code and I can't change it. 

WTF!

The problem is untimately this: when you ask an Array list to remove an object, It uses the objects definition of equality to decide whether or not to remove the object. I THOUGHT that the default definition for equality for ANY object was referential equality (that is where you ignore all the the object's data and look only at whether the two pointers match with A==B). 

We are all taught early on that it is BETTER to test if String a equals String b using the code: a.equals(b) which is VALUE equality and NOT to use REFERENTIAL equality which is a==b. 

The difference is this: If you have two different Strings variables, a and b, and one of them points to the 3 letters, "THE", located at one place in memory and the other points to the SAME 3 letters, "THE", BUT they are located at a different place in memory, well those two string are equal by VALUE but they are NOT refering to the same identical memory location, the are not REFFERENTIALLY equal. 

Referential equality is very limited/strict and ONLY looks at memory addresses, two supposedly different items that are both at the same address really are just a single item referenced from to places. A single item realy is equal to itsdelf. Referential equality is VERY fast comparing one number/address to anothrt, but that does mean that two things that are located at two different places are NOT referentially equal even if their data values are all identical, So if you want to test if two VALUES are equal by value. then you need some other function. 

This is why objects are ALLOWED to define an equals() function so that they can do the same sort of thing that String.equals does, namely to ignore the addresses, and instead go through the two Strings character by character and check that those two referentially different strings are equal by value.

My bug was this: I ASSUMED that the default definition for equals() was referential equality which is what I wanted. If I ask you to delete XX from the list, I want you to delete that exact item from the list, NOT some other thing that had similar values. When I saw ArrayList deleting the wrong element I knew I needed to FORCE the system to use referential equality when comparing two Masses in the Layers.

This would have been a one line definition of a function equals(Object obj){return this==obj;} except for dealing with hashcode.

One of the general rules for working with the Java Collections classes (and ArrayList is one of those) is that if you EVER override equals() you must ALSO override hashCode(). Basically the collections classes use BOTH of those functions internally and require that they be in synch. Two things that are equal by equals() MUST return the same hashCode();

The fix is trivial once you understand the problem. So here is the fix - add this to Mass:

  // fix a bug that shows up when removing masses as I.Shows from layers
  private static int M=1;
  private int hash = M++; // assign unique hash code to each Mass
  @Override  
  public int hashCode(){return hash;} // each new Mass gets a new M value as a hash code
  @Override
  public boolean equals(Object o){return this==o;} // use referential equality

::S Gesture

==Gesture.java
  public class Gesture{
    public Shape shape;
    public G.VS vs;
    
    private Gesture(Shape shape, G.VS vs){this.shape = shape; this.vs = vs;}
    
    public static Gesture getNew(Ink ink){ // can return null
      Shape s = Shape.recognize(ink);
      return (s==null) ? null : new Gesture(s,ink.vs);
    }
  }

For right now, Gesture is mostly just a simple class with a factory method. However one thing that we will eventully want is a static AREA to give us the mouse behavior that we will want for gestures. We will want the name to be Gesture.AREA so we will add it to the Gesture class. 

What we need for that static object is something that implements that dn,drag, and up functions that are expected for an I.Area and we will do that by a method that we have not yet done in this class; we create  an anonymous class of type I.Area using new, and then we flesh out the missing functions to match the interface's signatures. 

You may have been told in a previous Java class that you CAN'T use new with an interface, or an abstract class because interfaces and abstract classes are NOT complete. They are missing code. 

Those incomplete items are indeed missing code BUT if you immediately supply the missing code in a block following your use of new, you are creating an object of an anonymous class. That object uses the code that you supplied in the block.

--add to Gesture
  public static I.Area AREA = new I.Area(){
    public boolean hit(int x, int y){ return true; }
    public void dn(int x, int y){Ink.BUFFER.dn(x,y);}
    public void drag(int x, int y){Ink.BUFFER.drag(x,y);}
    public void up(int x, int y){
      Ink.BUFFER.add(x,y);
      Ink ink = new Ink();
      Gesture gest = Gesture.getNew(ink); // can fail if unrecognized
      Ink.BUFFER.clear();
      if(gest != null){
        Reaction r = Reaction.best(gest); // this can also fail - possibly no reaction wants it.
        if(r != null){r.act(gest);}
      }
    }
  };
 

You can see that the dn and drag functions are just pass throughs to the area behavior of the Ink.BUFFER. The only complexity was in the up function, which constructs the ink, clears the BUFFER, attempts conversion to a gesture (which can fail for unrecognized strokes). Even if we DO create a valid gesture, the attempt to find a reaction that wins the bid can also fail (possibly none of the reactions liked the location of the gesture so refused to bid.) However, if we get through all the guards, the winning reaction will finally get to act on the gesture.

A typical Reaction based application will be able to use that gesture AREA like this:

  public void mousePressed(MouseEvent me){Gesture.AREA.dn(me.getX(),me.getY()); repaint();}
  public void mouseDragged(MouseEvent me){Gesture.AREA.drag(me.getX(),me.getY()); repaint();}
  public void mouseReleased(MouseEvent me){Gesture.AREA.up(me.getX(),me.getY()); repaint();}

==Add some debug code 
Before we leave this topic, we are going to make a small change to the Gesture AREA code that will allow us to put a message on the screen telling us a little more about what happened when we tried to recognize a gesture. There are 2 different ways that gestures can fail to do anything and as we are developing it will be nice to which one might be causing a problem.

The system can fail either because the stroke that the user drew on the screen was not close enough to any prototyp so no Shape was recognized OR because even though a Shape was recognized NO reaction wanted to bid on it.

So we will keep a static String in Gesture that captures the name of a Shape if one was recognized, "null" if non-recognized, and then will add "no bid" to that String if no reaction bid on it. We can then just dump that string onto the screen in paintComponent of some WinApp to see what is going on during recognition.

--add to Gesture
  // instrumented tracking when gestures don't work
  public static String recognized = "null"; // set by Gesture.AREA

--modify the AREA up code after clearing the BUFFER
  Ink.BUFFER.clear();
  recognized = (gest == null)?"null": gest.shape.name;
  if(gest != null){
    Reaction r = Reaction.best(gest); // this can also fail - possibly no reaction wants it.
    if(r != null){r.act(gest);}else{recognized += " no bids";} 
  } 
 
Any application that wants to show this information can add a line to paintComponent like:

  g.drawString(Gesture.recognized, 900,30);

Just for the record, we wrote and tested this notion back when we were testing gestures before we wrote the Shape Recognizer. but back then we put the code in the wrong place. We put the recognized message in the application. This is a better design. It means when we write a new application, if we want to show the user what is going on, we just add the one line to paintComponent in the new app. 

We will use this in the Reaction test that we will build next.  

::S Simple Reaction Test  
== Simple Reaction Test

Let us build yet another application, this one will let us test build some simple reactions using the code we have so far, and will also, eventually, let us test things that are comming up soon like Undo.

--Create a WinApp named ReactionTest
  package sandbox;
    
  import graphics.*;
  import reaction.*;
  import java.awt.*;
  import java.awt.event.MouseEvent;
    
  public class ReactionTest extends WinApp{
    static{new Layer("BACK"); new Layer("FORE");} // create the layers that this class will need.
    
    public ReactionTest(){
      super("Simple Reaction Test", UC.mainWindowWidth, UC.mainWindowHeight);
      Reaction.initialReactions.addReaction(new Reaction("SW-SW"){
        public int bid(Gesture g){return 0;}
        public void act(Gesture g){new Box(g.vs);}
      });
    }
    public void paintComponent(Graphics g){
      G.fillBack(g);
      g.setColor(Color.BLUE);
      Layer.ALL.show(g);
      Ink.BUFFER.show(g); // note: show ink on top of drawn graphics
      g.drawString(Gesture.recognized, 900,30); // gesture debug info
    }
  
    public void mousePressed(MouseEvent me){Gesture.AREA.dn(me.getX(),me.getY()); repaint();}
    public void mouseDragged(MouseEvent me){Gesture.AREA.drag(me.getX(),me.getY()); repaint();}
    public void mouseReleased(MouseEvent me){Gesture.AREA.up(me.getX(),me.getY()); repaint();}
    
    public static void main(String[] args){PANEL=new ReactionTest(); WinApp.launch();}
    
    //-----------------Box--------------------
    public static class Box extends Mass{
      public G.VS vs;
      public Color c = G.rndColor();
      public Box(G.VS vs){
        super("BACK"); this.vs = vs;
      }
      public void show(Graphics g){vs.fill(g,c);}
    }
  }

You should be able to read the above code with a little guidance. In the constructor, SimpleReaction, you will notice that I added one single reaction to the static initialReactions list over in the Reaction class. 

That new Reaction looks for a "SW-SW" shape AND the braces that immediately followed the closing paren of the argument list means that I am once again creating an anonymous class. Remember, the class Reaction is abstract. It is missing the bid and the act function, so I CAN'T create a new Reaction object without supplying the two functions that it needs. 

Technically the anonymous class is creating a subclass of Reaction, a class with no name BUT with the two required function that I immediately defined. I set the bid to 0 which is a perfect winning bid. This reaction will always win. And the act routine just creates a Box object that is the same size as the original ink for the SW-SW gesture.

The Mouse functions, the pressed, dragged, and released functions are essentially what I mentioned in the previous chapter, the Gesture class has a single static AREA that collects the ink, recognizes the shape, looks that shape up in the byShape Map to get a list of reactions and lets them bid. If there is a winner, the winner gets to act.

The Box class at the end of the app is just a simple thing that extends Mass. As a result it lives in the Layers. I implement a show routine, as is required by all Mass objects, that simply draws the colored rectangle.

When you run this, you should be able to do SW-SW gestures on the screen and each one should draw a different sized and colored box.

==Deleting the Boxes

The ReactionTest class, at the moment has ONE single initial reaction. That reaction can create many boxes. Now we want to show how to add individual reactions that are targeted at specific masses that show up on the screen. In particular we will add a delete reaction for the boxes. Bacically change the Box constructor to this:

  public Box(G.VS vs){
    super("BACK"); this.vs = vs;
    
    addReaction(new Reaction("S-S"){
      public int bid(Gesture g){
        int x = g.vs.xM(), y = g.vs.yL(); // get the x,y from the Gesture
        if(Box.this.vs.hit(x,y)){return Math.abs(x-Box.this.vs.xM());} else {return UC.noBid;}
      }
      public void act(Gesture g){Box.this.deleteMass();}
    });  
  }
  
We have added one single function call (that sprawls across 6 lines!) to add a reaction to this Box. The reaction that we add is a new one and we use the same anonymous class trick that we used before. The reaction wants a S-S gesture. However in this reaction you will see something that you probably have not seen before - that anonymous class that we created is NOT a static nested class, it is an inner class. It was created in an object context inside the constructor for a specific Box and as a result the Reaction object (which has no name) has a "compound this" buried in it.

Look at the act function for this reaction. If I just use the word, "this", in the function, it is refering to the Reaction object, in exactly the way that you are accustomed to seeing the word this. However, I can instead use the "compound this" by writing "Box.this". When I use that form of !ithis, I am not looking at variables that are part of the Reaction object, instead I am following a pointer to the Box that was being created when this Reaction was being created. So "Box.this" is one specific box, "Box.this.vs" would be the vs associated with that one specific Box, "Box.this.c" would be the color of that box.

What this means is that the code inside the bid and act routines of a reaction created this way CAN and SHOULD make reference to the particular object that they are affecting. So, the act code is a simple example. It says, "Box.this.delete()" which means call the delete function on that particular box, which is of course what we wanted.

The bid routine is more complicated but now that you know what Box.this means you should be able to decode it. I first create some local variables, x, y, which are the top mid point of the S-S stroke that made up the gesture. That point is essentially the "hot spot" of the gesture, in this case the starting point. I want to reject any gesture where the hot spot did not HIT the specific box that the user is trying to delete which is what the else clause of the if is for. If it did NOT hit it returns noBid. All the boxes that weren't hit will be returning noBid and are thus not even in the contest. They will not win. BUT any box that was hit WILL bid and because boxes can be stacked one on top of another we need a distance function.

This is very typical of a bid routing. Usually there is some criteria where by you can completely rule out a gesture and return noBid, but if you can't rule it out, you want to return an integer that gets closer and closer to zero the better it is. The particular functional expression that I choose for this example was

  Math.abs(x - Box.this.vs.xM());
  
So what is that expression? Well the x is the x that was the mid x of that vertical S-S gesture and the Box.this.vs.midx() is the middle x coordinate of the box. I decided that the closer you draw the center of the gesture to the center of the box the better it was. I only used the x coordinate rather than both the x and the y to make a point. It shows how the Reaction architecture makes trade offs between different items winning the bids.

Draw a big box, and then a smaller box on top of the big box but off to one side. If you go do your S-S gesture near the center of the box that is on top, well that it the box that gets deleted. But if instead you start your gesture on the top box BUT you keep that gesture closer to the center of the bigger box than to the center of the smaller box you will see that you can delete a box from underneath that little one.

As another example of the same thing. Draw a small box. Now completly hide it with a big box. Now if you remember exactly where that little box is, you can delete it out from under the big box. You won't see it go away because of course, it is hidden, but you can see that you did the delete gesture on the big box and it did NOT go away. If you now delete the big box, sure enough the little one is no longer there.

I am not claiming that this particular bid function is optimal or even very good. I am just pointing out that the bid function is almost always an arithmetic function of the coordinate points of both the gesture and the screen object and that you almost always want a distance function so that there is a notion of more or less desirable. 

Consider the alternative. If the bid is just a constant nubmer, 17, then all the objects bid 17 and the first object on the list wins regardless of where the gesture was made on the screen.

So now that you have seen this. You ought go be able to add a second reaction to every Box. Make is so that a click on the box (a DOT gesture) changes the color to a new random color. You just need to add a second reaction into the Box constructor.

For the last test, change the name of one of the shape that you are looking for from one that you trained like S-S to one like BUG. Verify that you get the message that told you that the shapeDB did NOT know how to recognize that shape. So what actually happens in that case. Well, I create a reaction that is looking for a "BUG" shape and, it joined a Reaction.list waiting for that stroke and of course it will never happen.  

  
::S Undo
--Day 9
==Undo
Undo in a traditional application written on an old slow machine with small memory was often complicated. The problem being that you might need to keep a lot of information around (like all the text that you deleted) in order to undo anything. Also, it meant in some sense that you had twice as much code to write. You first wrote the code to DO some thing and then you needed a different set of code to UNDO that thing.

We are going to do something much easier. Conceptually we can keep a list of everything that you DO as you do it. IF you can rapidly run that list from the beginning and do everything that you did, exactly as you did it before, as long as there is no randomness in it, you can get back to any previous state. In particular, the way that you undo your last step is that you just remove the last element from the list, reinitialize your system to the way it was when you first started, and then you run the list and do everything that you did previously except for that that last step which you removed.

We are further aided in our gesture based application (which conveniently does NOT do anything using swing components like buttons and menus and dialogs) because every single action that we take was essentially the result of a reaction responding to a gesture. If we just remember the list of all the gestures that have been done, we can fairly easily alter that list and re-run all those gestures.

This style of Undo does have design consequences and we will just live with them because they are not too bad and because by living with these consequences we get an ESSENTIAL feature, UNDO, working fairly easily.

One of those consequences is the one that I just mentioned, we are choosing to trigger all actions with gestures and to NOT use standard swing components. This doesn't mean that we could NEVER use menus and buttons, just that we would have to implement some way of undoing those actions WHICH is exactly NO different from what we would have had to do if we had used Swing components in the first place! 

Another consequence is that we will be FORCED to keep our drawing routines CLEAN - NO SIDE EFFECTS! Basically we are introducing two paths through the code, 1) where the user is drawing gestures and the screen is reacting and repainting after each one. This code is usually what the programmer tests to see that their code works as expected and 2) a second path when you are redoing one action immediately after another with no time to repaint in between. If those two paths don't do EXACTLY the same thing you won't get the undo behavior that you expect. (How could those two paths be different you ask? If you calculate something during your paint routine and you save that value and reuse it for further painting - that is a side effect that does one thing if each gesture is followed by paint and a different thing if you do a bunch of contiguous gestures without painting in between each one.)

None of these consequences of Undo are BAD or even unexpected. Any application that has Undo in it is just more complicated than one that does NOT have Undo built into it. 

Now Let's look at the design for that Undo system. All of this goes into the Gesture class.

We will want to add a List class to Gesture so that we can keep a list of them. That will work as our undo list.

--add class to Gesture
  //----------------------LIST-----------------------
  public static class List extends ArrayList<Gesture>{}
  
We want a static UNDO list in the Gesture class which we will make private.

--add static var to Gesture
  private static List UNDO = new List();
  
We will need to modify the up function of the Gesture.AREA - Once we know that we got a reaction to a gesture then we know that we want to add it to the UNDO list. However, we will also need to have a block of code that does exactly the same thing WITHOUT adding it to the UNDO list for those times when we are actually REDOING the UNDO list. SO we will add two functions to Gesture, one for just doing the gesture without adding to UNDO and the other that WILL add to UNDO if appropriate.

--in Gesture add
  private void redoGesture(){ // just do it! - don't put on UNDO, it's already there!
    Reaction r = Reaction.best(this);
    if(r != null){ r.act(this);}
  }
  private void doGesture(){ // IF the gesture causes a reaction, then add to undo list and do it.
    Reaction r = Reaction.best(this);
    if(r != null){ UNDO.add(this); r.act(this);} else {recognized += " no bids";}
  }

Next we build the actual undo function:
 
--in Gesture add
  public static void undo(){
    if(UNDO.size() > 0){
      UNDO.remove(UNDO.size()-1); // remove last element
      Layer.nuke();  // eliminates all the masses
      Reaction.nuke();  // clears byShape then reloads initial reactions
      UNDO.redo();
    }
  }
  
I have guarded UNDO. It does nothing if the UNDO list is empty. If it was non-empty then I can safely remove the last one and finish undoing. As you can see, I have written 3 expectations, i.e. functions that I have not yet written in my other classes. I want a static function nuke() in the Layer class to clear out the layers. Since the layers are where the Masses live, nuking the layers should wipe out all the masses. It is a one liner. 

--in Layer add
  public static void nuke(){ // NUKE all layers in preparation for undo.
    for(I.Show lay : ALL){((Layer)lay).clear();}   // ALL remains intact, but the layers and thus the masses are cleared
  }

I also need a redo() function in my Gesture.List class that simply goes through an entire list and calls redoGesture on each gesture. This is also a one liner:

--in Gesture.List add
    private void redo(){ for(Gesture gest : this){gest.redoGesture();}}
    
And finally I need to hack up the Reaction class so that it removes the reactions from the byShape Map. This would have been a one liner, where I just deleate the byShape Map and create a new empty one - BUT - When I actaully start redoing gestures I don't want the map to be empty, I want it loaded up with the initialReactions that the application needs to interpret those first few user gestures. So I need to load those reactions into the map before I return from nuking the byShape map. 

Thinking just a bit ahead, I MIGHT want the application someday to have the option of disabling one of those initialReactions - I mean, it is possible that after you have loaded some masses into the system, those very first initialReactions will get in the way of further processing. On the other hand, I don't want to remove those initial reactions from the initialReactions List because they will be needed absolutely anytime the user does an UNDO. 

So we do need to be sure that we can re-enable all the reactions in the initialReaction list before launch the redo of the undo list. This persuades us to add an enable function into the Reaction.List class.

--in Reaction.List add
    public void enable(){for(Reaction r : this){r.enable();}} // enables entire list
    
And finally, with that function, I can now nuke the Reactions properly:

--in Reaction add
  public static void nuke(){ // used to reset for UNDO
    byShape = new Map(); // throw away all the reactions.
    initialReactions.enable(); // enable insures that the reaction is in the byShape Map
  }

Now that we have an undo function that we can call, we will fix the Gesture.Area up function to LOOK specifically for the "N-N" undo gesture (And yes, I am going to hard-wire that one single shape for that one single function. Any reaction that is looking for a N-N shape will never see it!)

--replace Gesture.AREA 
  public void up(int x, int y){
    Ink.BUFFER.add(x,y);
    Ink ink = new Ink();
    Gesture gest = Gesture.getNew(ink); // can fail if unrecognized
    Ink.BUFFER.clear();
    recognized = (gest == null)?"null": gest.shape.name; // debug info
    if(gest != null){
      if(gest.shape.name.equals("N-N")){ // hardwired UNDO
        undo();
      }else {
        gest.doGesture();
      }
    } 
  }


I believe that that is sufficient to get undo working. Tricky to think through, but an amazingly small amount of additional code. You can test this immediately with our Simple Reaction app and see that we have implemented Undo.

You will also see that I VIOLATED one of the requirements for Undo that I told you about. That was on purpose - I wanted to remind you that one of the requiremens for UNDO is that running the same list of strokes MUST give you the same outcome every time which means that you CAN'T have random results. 

Our SimpleReaction app is FULL of random colors. When you undo anything, adding a box, deleting a box, changing the color on a box - ALL the colors change because you are redoing a list that was full of randomization.

==What works - what doesn't

And now that Undo is working we have reached another mile-stone in our project. At this point the reaction architecture is mostly in place. There are several other features that we could/should put into the reaction package. Our Area system has an interface but it is a total kludge - we have one Area for Ink and another one for Gestures and no systematic way of generating lists of Areas and selecting between them. And it is the lack of that systematic way of dealing with areas that means that we can't yet create draggable handles. Handles are like scroll bars that allow you to drag them and change the size or location, or color of something - handles that do NOT leave INK all all over the screen while you drage it!

Another feature that we will eventually want in our gesture interface is the notion of a one-time offer. A one-time offer is a convenient UI device where the system notices that you have done something and it thinks that you might want to do something else - so it gives you a one-time offer. OLD BOGUS systems do this all the time, popping a dialog onto the screen that you must DISMISS if you don't want what it offers. What a waste of the User's precious time, makeing them click to get rid of the trash that showed up unasked for on the screen. Instead this WAY COOLER UI feature is that the offer pops up, and if the user does ANYTHING other than click on the offer, then the offer goes away. IF you want it, there it is, but if you don't, just ignore it, continue with your work and it will go away.

However, I do NOT want us to get bogged down writing NOTHING but tools, tools and more tools for the reaction framework. We got us a shovel and a hammer - time to stop building tools and start building us a music application. WHEN we get to the point that we need "handles" or "onetime offers" we can come back to the framework and wedge them into the architecture.

Next up: A list of the classes that compose the bulk of the reaction architecture.  
::S Java Code
==Layer.java
  public class Layer extends ArrayList<I.Show> implements I.Show{
    public String name;
    
    public static HashMap<String, Layer> byName = new HashMap<>();
    public static Layer ALL = new Layer("ALL");
    
    public Layer(String name){
      this.name = name;
      if(!name.equals("ALL")){ALL.add(this);}
      byName.put(name, this);
    }
    public void show(Graphics g){for(I.Show item : this){item.show(g);}}
    public static void nuke(){ // NUKE all layers in preperation for undo.
      for(I.Show lay : ALL){((Layer)lay).clear();}   // ALL remains intact, but the layers and thus the masses are cleared
    }
  }
  
== Mass.java
  public abstract class Mass extends Reaction.List implements I.Show{
    public Layer layer;
    public Mass(String layerName){
      this.layer = Layer.byName.get(layerName);
      if(layer!=null){layer.add(this);} else {System.out.println("BAD LAYER NAME-" + layerName);}
    }
    public void delete(){
      clearAll(); // clears all reactions from this list AND from the Reaction byShape Map
      layer.remove(this); // remove self from layers.
    }
    public void show(Graphics g){}
    
    // fix a bug that shows up when removing masses as I.Shows from layers
    private static int M=1;
    private int hash = M++; // assign unique hash code to each Mass
    @Override  
    public int hashCode(){return hash;}
    @Override
    public boolean equals(Object o){return this==o;}
  }


==Reaction.java
  public abstract class Reaction implements I.React{
    public Shape shape;
    
    private static Map byShape = new Map();
    public static List initialReactions = new List(); // used by Undo to restart everything.
    
    public Reaction(String shapeName){
      shape = Shape.DB.get(shapeName);
      if(shape == null){System.out.println("WTF? - Shape.DB don't know about: "+shapeName);}
    }
    private void enable(){ // adds to byShape Map
      List list = byShape.getList(this.shape);
      if(!list.contains(this)){list.add(this);} // prevent multiple copies on list
    }
    private void disable(){List list = byShape.getList(this.shape);list.remove(this); }
    public static void nuke(){ // used to reset for UNDO
      byShape = new Map();
      initialReactions.enable(); // enable insures that the reaction is in the byShape Map
    }
    public static Reaction best(Gesture g){ return byShape.getList(g.shape).loBid(g);} // can return null
    // ------ List -------
    public static class List extends ArrayList<Reaction>{
      // adding and removing is done to TWO lists, the one in a Mass and the one in the byShape Map
      public void addReaction(Reaction r){add(r); r.enable();}
      public void enable(){for(Reaction r : this){r.enable();}} // enables entire list
      public void removeReaction(Reaction r){ remove(r); r.disable();}
      // this next routine is tricky - to avoid concurrent array mods you first remove all from shape map, then clear
      public void clearAll(){for(Reaction r : this){r.disable();} this.clear();}
      public Reaction loBid(Gesture g){ // can return null
        Reaction res = null; int bestSoFar = UC.noBid;
        for(Reaction r : this){
          int b = r.bid(g);
          if(b < bestSoFar){bestSoFar = b; res = r;}
        }
        return res;
      }
    }
    // ------ Map ------------
    public static class Map extends HashMap<Shape, List>{
      public List getList(Shape s){ // always succeeds
        List res = get(s);
        if(res == null){res = new List(); put(s,res);}
        return res;
      }
    }
  }

== Gesture.java
  public class Gesture{
    // instrumented tracking when gestures don't work
    public static String recognized = "null"; // set by Gesture.AREA
    private static List UNDO = new List();
    
    public Shape shape;
    public G.VS vs;
    
    private Gesture(Shape shape, G.VS vs){this.shape = shape; this.vs = vs;}
    
    public static Gesture getNew(Ink ink){ // can return null
      Shape s = Shape.recognize(ink);
      return (s==null) ? null : new Gesture(s,ink.vs);
    }
    
    public static I.Area AREA = new I.Area(){
      public boolean hit(int x, int y){ return true; }
      public void dn(int x, int y){Ink.BUFFER.dn(x,y);}
      public void drag(int x, int y){Ink.BUFFER.drag(x,y);}
      public void up(int x, int y){
        Ink.BUFFER.add(x,y);
        Ink ink = new Ink();
        Gesture gest = Gesture.getNew(ink); // can fail if unrecognized
        Ink.BUFFER.clear();
        recognized = (gest == null)?"null": gest.shape.name; // debug info
        if(gest != null){
          if(gest.shape.name.equals("N-N")){ // hardwired UNDO
            undo();
          }else {
            gest.doGesture();
          }
        } 
      }
    };
    
    private void redoGesture(){ // just do it! - don't put on UNDO, it's already there!
      Reaction r = Reaction.best(this);
      if(r != null){ r.act(this);}
    }
    
    private void doGesture(){ // IF the gesture reacts, add to undo list and do it.
      Reaction r = Reaction.best(this);
      if(r != null){ UNDO.add(this); r.act(this);} else {recognized += " no bids";}
    }
  
    public static void undo(){
      if(UNDO.size() > 0){
        UNDO.remove(UNDO.size()-1); // remove last element
        Layer.nuke();  // eliminates all the masses
        Reaction.nuke();  // clears byShape then reloads initial reactions
        UNDO.redo();
      }
    }
    //----------------------LIST-----------------------
    public static class List extends ArrayList<Gesture>{
      private void redo(){ for(Gesture gest : this){gest.redoGesture();}}
    }  
  }

==ReactionTest.java
  public class ReactionTest extends WinApp{
    static{new Layer("BACK"); new Layer("FORE");} // create the layers that this class will need.
  
    public ReactionTest(){
      super("Simple Reaction Test", UC.mainWindowWidth, UC.mainWindowHeight);
      Reaction.initialReactions.addReaction(new Reaction("SW-SW"){
        public int bid(Gesture g){return 0;}
        public void act(Gesture g){new Box(g.vs);}
      });
    }
    public void paintComponent(Graphics g){
      G.fillBack(g);
      g.setColor(Color.BLUE);
      Layer.ALL.show(g);
      Ink.BUFFER.show(g); // note: show ink on top of drawn graphics
      g.drawString(Gesture.recognized, 900,30);
    }
    public void mousePressed(MouseEvent me){Gesture.AREA.dn(me.getX(),me.getY()); repaint();}
    public void mouseDragged(MouseEvent me){Gesture.AREA.drag(me.getX(),me.getY()); repaint();}
    public void mouseReleased(MouseEvent me){Gesture.AREA.up(me.getX(),me.getY()); repaint();}
  
    public static void main(String[] args){PANEL=new ReactionTest(); WinApp.launch();}
    
    //-----------------Box--------------------
    public static class Box extends Mass{
      public G.VS vs;
      public Color c = G.rndColor();
      public Box(G.VS vs){
        super("BACK"); this.vs = vs;

        addReaction(new Reaction("S-S"){
          public int bid(Gesture g){
            int x = g.vs.xM(), y = g.vs.yL(); // get the x,y from the Gesture
            if(Box.this.vs.hit(x,y)){return Math.abs(x-Box.this.vs.xM());} else {return UC.noBid;}
          }
          public void act(Gesture g){Box.this.delete();}
        });
      }
        
      public void show(Graphics g){vs.fill(g,c);}
    }
  }


::S OTO Afterthoughts
== OTO Afterthoughts
--day 10
OK - Sorry, I lied. OneTimeOffers. I can't resist. I just love designing tools and this one is just too easy to pass up. I'll compromise. We will just do the design thinking now, but we won't implement until we need it. Also, just for the record, One Time Offers are not some standard User Interface trick. As far as I know I am the inventor of this notion. I believe that the idea is patentable, or rather it was before I published it publicly here and put it in the public domain. I have about a dozen patents (all owned and paid for by the companies that I used to work for) so I do have some idea about what is and is not patentable. I didn't patent this particular notion because patents are expensive and are essentially worthless outside of the realm of corporate legal patent warfare. Since I no longer work for companies I no longer bother with patenting design notions, but I DO notice when something is patentable because that is part of the JOB of being a software developer for a corporation, helping them develop their Intellectual Property - software, patents, trademarks, rock videos etc.

Anyway, back to OneTimeOffers: Think about it. An OTO goes away immediately if you don't act on it. So, does it ever make sense to have two of them up on the screen at the same time? I suppose you could, like to let the person choose either A or B or C or ignore them all. But in some sense that is but a single offer. Our conclusion is that you just need one of these OTO objects.

Now since it has visible stuff up on the screen that can react to clicks it must be a Mass and live in the Layers. The real question is whether there is any need to be continually creating and destroying this OTO object and continually adding and removing it from the layers and the reaction lists.

The mere fact that something lives in the layers means that we call its show routine. That doesn't mean that if MUST actually draw something on the screen. It can maintain internal state, a boolean, of whether it is enabled or not and only draw itself if it is enabled. The same is true for the click reaction on the OTO. It can look at the sate and if it is NOT enabled it can just bid noBid for the DOT that it is looking for.

So one single OTO object living in the top layer could show and hide itself as needed. 

Clearly the app, when it needed to present an OTO to the user will need to tell the OTO what text should be displayed.

How will the OTO get notified that it has been declined (or accepted for that matter) and it should hide itself? Clearly, after we have collected a winning reaction, even if the winning reaction was the OTO's DOT function, we can disable the OTO.

A single line in the Gesture.Area up code, just before (or after we collect the winning reaction) can remove the OTO. That should work, eh?

WRONG - It almost works but as I said before and will no doubt say again, we have two paths through the code now, one when the user is entering strokes - that would go through the Gesture.Area code - and the other path is through the UNDO list. During UNDO playback you don't go through the Gesture.Area code. (Am I really so foresighted to see all these potential bugs before they happen? Sure, I try to do that all the time, but in reality, I've built this framework before and made every possible mistake. I now know the places where I had nasty bugs in the past and had to go fix my design.)

We need to disable the OTO on BOTH paths through the code so we must put it in two places, the doGesture, and the redoGesture code.

At this point we BELIEVE that we know enough to write the OTO code. Of course there are other decisions to make about the OTO and that is why we don't write the code now. Does it put one single drawString text message up on the screen? Does it let the application install some arbitrarily complex drawing routine, with multiple hot spots that the user can click on? Do we do both - a quick and dirty single message sort of OTO and a more complicated one for the fancy applications? Do we blow off the fancy one for version 2 and only build the simple one first, or do we build the fancy one and then use it to implement a quick and dirty version and then just NOT TELL anyone that we can extend the functionality to something more complex in the future? Do we just throw the whole problem of designing a more complex OTO to the marketing folks as a bone and let them chew on it and argue amongst themselves as to what is the right thing to do?

Without going too far down this rabbit-hole in the design. I would point out that the multiple clicks and multiple messages is NOT really all that hard. We already know that we can create a bounding box for text that we draw on the screen. That is clearly the desired click region for each chunk of text. We can easily implement a list of located text elements (i.e. a string AND an X,Y location for it - the arguments to the drawString function). We can easily go through that list and draw all that text onto the screen. We can easily detect if ANY of them go clicked on, and if each text element has a behavior (probably some kind of I.Act object) associated with it. Basically we can build the fancy multi-choice OTO, a list of clickable text element, without a whole lot more work than building a single text OTO, (a list that just happens to be one element long).

Now, quite honestly, if we tell Marketing anything about multi-choice OTOs, and let them argue and discuss it, there is NO WAY that they are going to come back with a design that is this simple. It will be some baroque mess with extra fields and features (what if the app wants to post an icon instead of text - no, wait, wants to post a video, like an animated gif or something) because Marketing folks don't write code and don't know the difference between something that is an adequate few lines and something that is hundreds of man years of development effort. Far better to just build it, test it, and show it than to let some one who doesn't write code tell you how it "ought" to work.

And just to complete this section, THIS is what a design lead on a project does. They wave their hands at a notion, they sketch in broad terms the sort of thing that it should do, maybe even describe exactly where in the code base you need to go to hook something in, and then let some other programmer actually build the code and test it out.

So if you feel that you want to test your chops as a programmer, go build class Oto and wire it into the framework.

As I said, I will return to this later when I actually need it, BUT, I mentioned this design now because it does bring up an important point that you might find useful as we start to think about how to use the reaction architecture that we have just built to start creating a music notation application. The point being that the mere fact that a mass lives in the layers and thus has a show routine does NOT mean that it is alway visible and always reactive.

==Deleting Prototypes in Shape Trainer
You know, I lied about something else earlier. When I was discussing the design for the Shape Trainer I talked about how it would be cool if you could delete bad prototypes.

Suppose you slip up and just draw something bad, like a single dot on the screen, the system, as it is now, decides that the glitch was not like anything else so it creates a new prototype that you don't actually want. With no way to delete prototypes, you have no option but to close down the Shape Trainer without saving so that the bad prototype does not get into the Shape database.

It would indeed be cool, but too hard to implement, or so I thought.

And that's the way it was for several years as I taught this course. Then one day as I was spouting this same nonesense about how it was just too much code to add deletion of prototypes into the trainer I suddenly realized that I could do it with just a handful of lines. This is just TOO useful to leave out.

And quite frankly this happens all the time in design. You just don't see an easy way to do something until suddenly you do.

So here it is: The coordinates of the showbox that marches across the top of the screen showing the different prototypes at different locations are algorithmically generated, a very regualar array of coordinates. This is good.

We can assume that the user will NOT be drawing their examples up in that area where we are showing the prototypes, so we will just look at the y parameter of the up call and see if it was up in the show area. If it was, we will assume that they were trying to delete a prototype. We will completely ignore any of the ink that they drew and just use the x value to calculate which prototype number they were trying to delete. 

--in Shape.Prototype.List add showboxHeight
  private static int m = 10, w = 60, showboxHeight = m+w;  
  private static G.VS showbox = new G.VS(m,m,w,w);

--in Shape.Trainer add a helper for up()
  private boolean removePrototype(int x, int y){
    int H=Prototype.List.showboxHeight; 
    if(y<H){  // if stoke ended in showbox area, don't train, just delete
      int iBox = x/H; // compute a box number
      Prototype.List plist = TRAINER.pList;
      if(plist != null && ndx< plist.size()){plist.remove(iBox);}
      Ink.BUFFER.clear();
      return true;  // tell up() that we were in the showbox area
    }
    return false;
  }

--in Trainer up() call the helper
  public void up(int x, int y){
    if(removePrototype(x,y)){return;} // don't train if proto was removed
    Ink.BUFFER.up(x,y);
    Ink ink = new Ink();
    Shape.DB.train(curName, ink.norm); // safe because legal name test is done in Database
    setState(); // possibly convert previously UNKNOWN to KNOWN
  }  

And now suddenly, you can delete mistaken prototypes.

::C Music
::S Overview
==Overview

We will be implementing a subset of what one would typically do in a software system for what is known as Common Practice Music Notation. It will be a subset becasue music notation is sufficiently complex that we can not possibly do it all in a one semester course. 

One of the things that we will NOT be doing is saving files and printing our notation to paper, which are probably two of the most important things that one would do in a REAL software project. The reason for that omission is simple, we will focus on using the gesture system to see how gesture recognition can affect the user interface for the entry and editing of music. Typing in a file name and saving a file has NO interesting user interface consequences so we won't spend time doing that obvious work. Similarly we won't bother with creating multi-page compositions, a requirement for a real application but unnecessary in a demo app like this one.

On the other hand what we will do is try to build a system that allows you to quickly produce a page of music that will look like real music and which will give the impression that you have created an entire music notation application and are almost finished.

In a sense this will be a bottom up approach. We will build a component that will draw something on the screen. Then we augment it so that we can provide a new feature and so on. MAXIMUM visibility as opposed to optimal design structure. There is a reason for this approach. We are NOT building a application. Instead we are doing research on User Interface design. We are exploring whether gesture recognition is a GOOD alternative to more traditional, Pick-n-Place, GUI paradigms.

So here in the overview section I will mostly be giving you NAMES of components that would show up in a typical music notation app (which of course will often become class names for us) and also give very rough sketch of what sorts of information the class will hold. Most of my students in the past do NOT know anything about music notation when they get started. Here is a partial vocabulary list of some of the elements that we will be building - we may get to all of these, we may not!

==Alpahbetical Vocubulary
Accents, Accidental, Augmentation Dot, Barline, Beam, Clef, Creshendos, Decreshendos, Dynamics, Fermata, Fine(prounouned:Fee-nay, Italian for 'end') Bar, Flag, Head, Key Signature, Ledger Line, Octave Shift, Repeats, Rest, Seconds, Slur, Staccoto Dots, Staff, Stem, System(Sys), Tablature (Tab), Tempo Marks, Tie, Time Signature, Trills, Voice

==Music Notation example
<img src="Cphoto/musicItems.jpg" />

==Definitions and comments

--Staff, System, Barlines
The group of 5 lines on which the notes are written are called !nstaffs. There are typically 5 stafflines in a staff thought there are varients usually when writing tablature for specific instruments. So for example Guitars have 6 strings, so guitar tabulature has 6 lines, Banjo Tab has 4, Percussion Staffs are sometimes done with 1.

Typically one staff represents the note for one instrument or !nvoice, though some instruments like piano and organ allow you to play so many notes all at the same time that they treat them like 2 or 3 voices and use 2 or three staffs to represent the music. Basically piano music has a staff for the right hand and a second staff for the left hand. Organ will have a third staff for the pedals that are operated by the feet.

The staffs of music are there to reprened the !npitch of the notes, the higher the note is written on the staff, the higher the pitch of the note. If two notes are vertically stacked, it means that they are sounded at the same time, otherwise, one note follows another on the page in reading order from left to right and that represents that order that the notes are sounded.

The staffs (one for each voice) are typically grouped vertically into a !nsystem. Unfortunately this musical term collides with the standard Java class that you see all the time in System.out.println(), so we will not use that word, instead we will shorten it to Sys. A single piece of music will typically span several pages, each page will consist of as many Systems as will comfortably fit on a page and each System contains as many staffs as it needs to match the instrumentation of the piece, so a String quartet's Sys will have 4 staffs, a flute sonata will have 1 staff for the flute and 2 for the piano accompaniement.

The Systems and the Staffs are essentially the coordinate systems that contain the music.

As the musical notes move forward in time they are typically grouped into Rhythmic blocks called !nmeasures. The vertical lines that separate the measures are called !nmeasure_lines or !nbarlines. So the measure itself consistes of the notes that land between two successive barlines. Those barline come in several different visual formats or flavors. The most common is just a stright line going though the staffs (and depending on the instrumentation the line may cross ONLY the staff lines, or it may cross the SPACE between two different staffs). If you look at the end of a piece of music you will see a !nFine_Barline (That's Italian for END and pronounced: Fee-nay, not the English word "fine". Many of the words in music come from Italian.) It consists of a thin line next to a fat line. If you scan through the music you will also see some !nRepeat_Barlines which are also consist of both a thin line and a fat line but you will see that they also have dots associated with them and little angled 'wings' at the top and bottom. These repeat barlines act like parentheses in a piece of music marking the beginning and the end of a section of music that is supposed to be played twice before moving on in the music.

At the start of each system on the page, there are typically 3 things draw onto each staff to remind the musician of the status of the music notation. Those three things are:

-- 1. Clef

The !nClef - which primarily show how highly pitched the notes are in that staff. Clef signs usually occur in 3 varients, a !nTreble or !nG clef for highly pitched instruments, like piano right hand, flute, and violin. The low pitched clef is called a !nBass clef or !nF clef used for piano left hand, or bassoon, or Bass violin, or Tuba. There is a third clef (rarely used anymore) called the !nC clef that is roughly between the Treble and the Bass clef. While you MUST have a clef sign at the start of each staff, you MAY have one anywhere in the middle of the music to change the type of staff that it is. For example if the staff was mostly high pitched noted but the music has moved way down into the low register, you may change the staff part way along to be a bass staff by dropping in a bass clef somewhere in the middle of the staff. The Clef at the front of the staff is to remind you which clef is currently in effect for that staff.
 
-- 2. Key Signature

The pile of 2 !Sharp signs right after the Clef is the !nKey_Signature. It tells you that the notes that occure on those marked staff lines will all be pitched a little bit higher than they normally would have been had they not been altered.

Those Sharp signs are a particular instance of a more general thing called an !nAccidentals and they occur in 5 different visual varieties named: !nFlats, !nSharps, !nNaturals, !nDouble_Flats, and !nDouble_Sharps. 

Much like clefs, you can have accidentals, where you !nraise or !nlower a note but just a little bit at any time, so you will see other accidentals throughout the piece occuring just in front of a note that they affect. Unlike clefs that change the nature of the staff until you mark some further change, an accidental is a temporary effect only affecting the notes in a single measure before the staff line lapses back to its default value which is what the Key Signature indicated.

-- 3. Time Signature

The !ntime_signature indicates how many and what types of beats make up a single measure. In our sample piece that time signature was 4/4, this meant that there were 4 quarter notes per measure. A tempo of 3/4 means that there are 3 quarter notes per measure. You will see in the sample piece that at the end of the first system, the time signature changed to 3/4 and that change was reflected in the time signature at the start of the second system.

The fact is, in our sample piece of music we changed both the key signature and the time signature at the end of the first system, and both of those changes are reflected in the new signatures in the second system. These changes of either of the signatures are allowed at any measure bar BUT, you are NOT allowed to change them at the start of a new system. IF the actual changes take place at the very first measure in a new system, then you must actually indicate that you INTEND to change them as we did here at the end of the previous system. So it is fine to change them in the middle of a system, and then the next system starts with a reminder of what they had been changed to in the middle of the previous system.

Most time signatures consist of one number written over another number but there is also a special symbol that looks like a C that means !nCommon time which is an abbrievation for the very common time signature of 4/4.

--Heads, Stems, Rests, Flags, Beams, Augmentation Dots

The actual notes to be played are represented basically by ellipses. Those ellipses are typically either filled in or not, and they usually come in 3 forms, 1) a !nquarter note !nhead which is solid black ellipse and the head has a !nstem which is a vertical bar either immediately to the right of the head going up, or immediately to the left going down, 2) a !nhalf note head is just the outline of an ellipse (so the note looks white) and it also has a Stem, 3) a !nwhole note head is also just the outline of an ellipse BUT it has no stem.

Those designations of the notes as, whole, half, quarter are intended to suggest fractions and represent the subdivisions of time in music. If we are in common time, 4/4, four quarter note to a full measure, a whole note fills a whole measure taking all 4 counts or beats. A half note is two counts, or half of the measure, a quarter note is one count or one quarter of the measure. 

We continue that ability to subdivide time and play even faster notes, eighth notes, sixteenth notes, thirty second notes, however we indicate that in music NOT by changes to the note heads as we did with the whole, half and quarter heads, instead we indicate further subdivisions of time by adding !nflags to the stem. A stem with no flags is a quarter, a stem with 1 flag is an eighth, a stem with 2 falgs is a sixteenth, a stem with 3 flags is a thirty second. We have a thirty second note with 3 flags in the sample piece in the second half of the 4th measure down in the bass clef of the piano part.

The shape immediately after that thirty-second note is a thirty-second !nrest. It looks a bit like the number 7 except that it has 3 horizontal lines running into the slash. If you look throughout the piece you will see a thing that look like a 7 with only one horizontal component - that would be an eight rest and you will also see ones with 2 horizontal components, which would be a sixteenth rest. 

Rests, just like notes, occupy time. Unlike notes, rests have no pitch. They are the absense of music rather than the presence of music. They are the "breaks" in the flow of sound. That rests that match the whole, half, and quarte notes each have special symbols that do NOT look like the number '7'.

In our sample piece of music the piano part starts with a whole note in the treble part (the right hand) and the left hand gets a whole rest to match it. That whole rest is the filled black rectangle that is hanging below one of the staff lines (and is vertically alligned with the whole note). In the next measure, the treble part consists of a half note followed by a half rest. You can see that the half rest is still a filled rectangle but now it is drawn on top of a staff line instead of hanging underneath one. (The story that music teachers tell children when they are learning to read music - "The whole rest is so STRONG it can HANG from a staff line, but that WEAK little half rest is so tired it has to REST on top of the line." I will no doubt still be telling this to people when I am confined to a nursing home and dementia has consumed everything else in my mind :)

The third measure into the piece in the right hand piano part has a "dotted half note" followed by a "quarter rest". Doted notes are note heads followed immediately by an !nAugmentation_Dot. The purpose of the dot is to extend the time by half of its natural time, so since a half note typically takes 2 counts, half of that is 1 count, so the dotted half is 3 counts total. Since the quarter rest is one count, this makes the measure sum up to 4 counts total just as we expected from the 4/4 time. You can have more than one dot on a note (see for example the 6th measure, it has a double dotted quarter note) and since dots affect time and since rests also represent time you can in fact dot rests in the same way that you can dot notes (there is a dotted half rest in the bass part measure 5).

The flags that change the duration of a note are drawn in a curved shape if they are on a single stem, however they can be added to several stems all at once in which case they are drawn completely straight. We reserve the word "flag" for isolated flags, and use the words !nbeam or !nbeamed_group to refer to the variety that are shared by multiple stems. 

In our example the first beamed group that shows up is in the bass hand in the 4th measure. There are 4 notes beamed together. Because there is one single beam (same as one flag) each of those 4 notes is an eighth note. There is no sound difference what so ever implied by using beams instead of flags. The reason for the beams is simpley they are faster to draw, they take less space, AND they help the eye spot regular patterns. For example, it is very rare to beam across the halfway point of a measure. (for example see measure 11 which has two beamed sixteenth notes followed by 4 beamed sizteenth notes. They were NOT all beamed together because that would have spanned the mid point. This makes it easier in reading music to see that mid point.) 

Generally the beams in a single beamed group span across all the stems in the group but that is not required. If you look at measure 5 you will see a beamed group of 2 notes, where one beam, (the "master beam", the one that is furthest from the note heads) touches all stems (as it MUST) but the one on the "inside" which is closer to the heads touches only one of the stems, the first stem. This means that the first stem has 2 flags on it but the second stem has only one flag on it. The is no official name for one of those short beams that does not reach all the way from one stem to another but in my music notation software it was always refered to as a !nbeamlet, a little beam.

--Acents, Trills, Dynamics, Creshendos, Decreshendos

There are many other marks on a piece of music that have less to do with the notes, their pitches and their timing. Those other aspects are things like !nTempo_markings to indicate how fast or slow some passage should be played, !nDynamic_markings to indicate how loud or how quietly a passage should be played. If the volume is supposed to start out quiet and gradually increase to loud (called !nCreshendo) it is marked with a long extended open angle bracket that starts at a point and has the two branches getting wider apart. The alternative, a !nDecreshendo, is marked with a closing angle bracket, starting wide apart and narrowing down to a single point. 

The Dynamic marking a generally single letters like "p", short for "piano" meaning "quiet" and "f" for "forte" meaning "loud" and they come in groups like "ppp" for "really really quiet" or "fff" for "really really loud". Accents and trills may be marked with symbols like "V" or "&gt;" or letters like "tr" which is short for "trill"

-- Slurs, Staccoto, and Ties
A !nslur is a group of notes that are supposed to be smoothly connected together, the end of one note running right into the beginning of the next note. They are used to indicate 'phrasing'. In our example there is a slur over 3 notes in the right hand of the piano in measure 7. Slurs are drawn with a curved line that starts at a point, gets wider in the middle, then shrinks back to a point.

Mostly all music is supposed to connect one note to the next so for the most part there is no need to mark slurs, they are typically used only in some music for emphasis. However the opposite, where the notes should be somewhat disconnected, is called !nStaccoto and is typically marked with a single dot either slightly above or below the note head (depending on which way the stems run). Measure 4 in the bass line has 3 staccoto eighth notes in a beamed group.

 !nTies are VERY different in meaning from Slurs, but they are NOT different graphically. They are drawn just like slurs, with the same slighly curved stroke, starting and ending at points but swelling in the middle. 
 
 A tie goes exactly between two consecutive note that are on the same staff line. The meaning of the tie is that you ADD the duration of the two notes together and play them as if they were a single note with that summed duration. One of the uses of ties, which you can see in measure 12, is where you want to tie a note from one measure into the next. Since the notes in a single measure are not supposed to sum to a duration greater than what the time signature tells you belongs in a measure, if you want to have a longer duration note you need to use ties to add them. In our example there are at least 5 ties.

==Layout rules

In addition to the many symbols and their special meanings there are also many layout rules that must be followed when writing music. I will not even attempt to list them all here there are too many and there is little need to list them. We will develop them as necessary, however it is useful to mention a few of them here because some of the design of our classes will be based on the layout rules.

For example: Augmentation dots are something that can be added to note heads (and to rests). While we COULD create a class DOT that refers to the head or the rest that it modifies, we won't. it is much easier to simply have an integer field in a head object that is the nDots, the number of dots that modify a given head and make it the job of the head to actually draw the dots that modify that head. And even that design is too complicated - The fact is it is very common to have several note heads all joined up onto a single stem and by convention, all the notes that share a stem all must have the same duration, and since dots are part of that duration calculation they must all have the same number of dots. Furthermore, the way that you layout those dots, they must land in spaces NOT on lines so you need to look at the entire cluster of heads that share a stem to figure out where to actually draw the dots. As a result, we put a single integer field, nDots, into the Stem class to track whether or on all the notes on a stem need to be dotted and if so, how many dots.

As another example. Notes (and rests) that sound at exactly the same time are supposed to be vertically aligned. As a direct consequence of that, notes that are NOT sounding at the same time should NOT be written on the page in any way that makes it look like they MIGHT be vertically aligned. The musician needs to see that this note way down here in the lowest staff is NOT overlapping in any way with the location of that note way up there in the top staff of a single system. In essence, simultaneous times essentially leads to identical x values and non-simultaneous times need to be a x values that are sufficiently removed from one another that they would not be confused as being the same. So we will ultimately build a Time class, which essentially holds an X value. And notes that start at the same time should share that Time object. When we start drawing gestures on the page, the user will have a gesture that adds a head to the staff at the place that they drew the gesture. That Head insertion step however need to look at the x value where they drew the gesture and make a decision - was this x close to an existing Time object? If it was, we should make this new head share that time and snap to that existing x value otherwise we should create a new Time value and make the head refer to that new time value.

So that will be our next step, to create some of the classes and the fields in those classes that we believe will hold the elements that we need to represent our music notation.

::S MusicEd
==MusicEd
I have decided that as we develop our music we will do so in sprints. In the SCRUM world where the name "sprint" comes from, a sprint is generally a target that you think you can hit in about 2 weeks. Time is NOT our concern here, we a merely interested in selecting a target or a milestone that we can build and test as we develop our music code base. 

So our first sprint will be to construct those classes that are needed for the "coordinate systems" for the music. These will be the classes Page, Sys, Staff, Staff.Fmt, and Bar. The primary goal is to get to the point that we have the background objects that we need to be able to enter music. We will at this time defer some other classes like, KeySig, TimeSig, and Clef that are also in some sense part of the underlying format that defines the coordinate systems for rendering music.

--in music create classses Page, Sys, Staff

Since this music editor is a demo to show that we can build a reaction based interface we will not actually worry about things like saving files or writing multi-page music. None the less, we will still build our classes with the notion of a Page object so that we COULD later implement muitiple pages and all the other classes. The Systems and Staffs will refer to pages and properly work with multiple pages. Those classes don't need to know that all the pages that the refer to are all a single page that our app created.

==Initial Gestures

Even though we know that some of the classes that we will need will be Sys and Staff, instead of starting at those class definitions, let's think for a moment about the Gestures which we will want to work from.

When I see that blank page in front of me, I want to be able to define a top margin which will be the location for the top line of the first staff of the first system on the page. So we will need a gesture that essentially defines a y coordinate and that suggests that we want something like a horizontal line. There are several gestures which are purely horizontal that we could consider for this; E-E, W-W, E-W, W-E. I am going to select W-W for this initial gesture. I will give my reasons later, but for now it is useful to note that it is generally very easy to switch which gesture you use for some feature. So proper choice of gestures is based more on the balance you want in a full featured application rather than on any coding consequences at this early point.

That very first stroke will actually define lots of things. It defines the top margin of the page, and in order to draw/create staff you will need to create a Staff.Fmt object first (and we will just use the default 5 line music staff). Each staff needs to be in a Sys and each Sys need to be on a Page so we need to create those as well. None the less, from the user's view, you just draw a line on a blank page and you get a single Sys show up that contains a single Staff.

When I draw my next gesture somewhere under that first staff, it should clearly create a second staff. However the important question is whether that second staff should be part of the same system as the first staff or not? The user will need to distinguish between 2 behaviors.  Adding a new staff to the first system (and thus effectively changing/redefining the system format) vs. adding a new system (a copy of the first system) to the page.

Using different gestures for those different action is usually a good choice, so I am inclined to use a single simple stroke, W-W to mean add new staff to the single existing system, and the slighly more complicated retrace gesture W-E to mean that we are DONE with our definition of the first system and are ready to add a new system to the page.

The basic idea is that the user will do several W-W strokes to define the shape of the first system IF they want any more of those systems the will do a W-E stroke.

That first W-W stroke defines the top margin of the page, and in a similar fashion th first W-E stroke defines the sysGap, the size of the extra space that we will want to leave between successive systems on the page. 

What may not be immediately obvious is that while we have described only 2 gestures, we will actually be using 3 reactions to get the effects that we want. The first W-W gesture will be an initial reaction defined by the application because when the app starts up, there are NO Mass objects in the layers where reactions normally live. That first initial reaction will create a Page object, and define the top margin, and create a Sys, and create a Staff, and load the Staff into the Sys, and then finally, it will disable itself. It will disable itself because we are DONE defining the top margin and we have created the one single Page we will ever create.

That Page that we created will have its own reactions. In particular it will create a new W-W reaction which can add a new staff to our existing first system. It is the job of the Page to figure out if you are trying to grow the existing first system OR whether you are trying to add a new Sys to the page. So the page has 2 reactions.

With these notions of what kinds of gestures we want to start with, let's build the classes.

::S the App 
==MusicEd App
We will build a WinApp similar to what we did to test the Reactions, but this time we will do the extra work to let us toggle back and forth between the music editing features of the app and with the shape trainer.

--create MusicEd.java in music
  package music;import graphics.*;import reaction.*;import java.awt.*;import java.awt.event.MouseEvent;
  
  public class MusicEd extends WinApp{
    public Layer BACK = new Layer("BACK"), FORE = new Layer("FORE");
    public static boolean training = false;
    public static I.Area curArea = Gesture.AREA; //  Gestures or Training at any time
  
    public MusicEd(){super("Music Editor", UC.mainWindowWidth, UC.mainWindowHeight);}
  
    public void paintComponent(Graphics g){
      G.fillBack(g);
      if(training){Shape.TRAINER.show(g); return;}
      g.setColor(Color.BLUE);
      Ink.BUFFER.show(g);
      Layer.ALL.show(g);
      g.drawString(Gesture.recognized, 900,30);
    }
  
    public void mousePressed(MouseEvent me){curArea.dn(me.getX(), me.getY()); repaint();}
    public void mouseDragged(MouseEvent me){curArea.drag(me.getX(), me.getY()); repaint();}
    public void mouseReleased(MouseEvent me){curArea.up(me.getX(), me.getY()); repaint();}
  
    public static void main(String[] args){PANEL = new MusicEd(); WinApp.launch();}
  }

You will see that I added a boolean flag named "training" to track whether I am running/showing the music editor or runing the shape trainer.

I use that flag in the paintComponent routine to either show the Shape.TRAINER or to instead show all the Layers of the Music Editor.

I have created a single I.Area member, curArea, that I will either set to be the Gesture.AREA or the Shape.TRAINER. By using that curArea in the mouse routines, my mouse is either doing music gesture or is training shapes.

I have NOT yet put in any code to actually toggle the training flag between the two state. I will need to think for a moment on what behavior I want the user to use in order to tell the system to toggle between the two states.

There is something else that I know I need to add. Our music editor does NOT react to key event at all, but the shape trainer does require keyEvents - so the user can tell us the name of the stroke to train. So we will add key event handlers to do what the shape trainer needs.

--add keyTyped
  public void keyTyped(KeyEvent ke) {
    if(training){Shape.TRAINER.keyTyped(ke);repaint();}
  }

And now that I think about it, I believe that I will effect my toggle between training and the editor by looking for a mouse up event in the upper right hand corner of the window. 

The thing that I had to think about was that the normal way to do anything in the music editor is to use a gesture - but I can't use gestures in the shape trainer becasue it is not a gesture based app. 

I remembered that when I put in the deletion of bad prototypes into the shape trainer I did that by noticing that the mouse was up in the top part of the screen which would be a bad place to be drawing shapes. As a result a mouse click, down and up, in the upper right corner will be ignored by the shape trainer, and unless we put a gesture in the music editor that is a dot in the upper right couner it will be ignored by the music editor as well. An upper-right click means NOTHING in either app, so add this code to create a training toggle for our music app.

  public void trainBtn(MouseEvent me){
    if(me.getX()>(UC.mainWindowWidth-40) && me.getY()<40){
      training = !training; curArea = training ? Shape.TRAINER : Gesture.AREA;
    }
  }

And then patch the mouseReleased routine to call it and actually do the toggle.

  public void mouseReleased(MouseEvent me){
    curArea.up(me.getX(), me.getY()); trainBtn(me); repaint();
  }

Let us also add a member to the app that knows where the page is. We will only ever be working with a single page so we can keep it in a static variable in the application. 
  
  public static Page PAGE; // set by an initial reaction

Nothing on the MusicEd side works because we have written no music code, but the trainer should work so we can test if we can properly toggle. Launch MusicEd, draw a W-W gesture and since we have not defined that yet the editor should print the message null (meaning unrecognized) in the top right.

Next, click in the upper right corner and it should switch to training. Use it to train W-W and W-E. Remember to hit the return button to save the database. Toggle back to the editor and at this point if you do a W-W gesture it should show that it ricognized it but No one bid on that gesture.


::S Hierarchical Coordinates
==Hierarchical Coordinates
We are going to add another small helper class to G. It is often the case in graphics applications that the location of one element B is just an offset from the location of some other element A. A represents a parent location, like a particular x value, and B is a child of A and is drawn at some offset, dx, from dad's x value.

For example lines of text land at increasing y values, each one being drawn below the previous line. That is a set of hierarchical y coordinates. The words on the line, come one after another and the x values of the words form a different hierarchical set.

There are of course two obvious ways to do this. You could have some text format code that goes through the text and solves the layout problem and determines the absolute xy coordinate appropriate for each word (or run of text), then you draw the text at those coordinates you just computed.

The other way is a little more dynamic (so potentially slower and takes more space) where instead of having every element know its absolute X and Y values, any Word could knows which LINE it is on (which decodes as a y value) and it knows which word preceeded it (which decodes to an x value).

The reason that the second way is more dynamic is that the user can change the y coordinate of a single line, perhaps dragging it around on the screen and all the words on that line and on all the following lines move with it (because the paint routine is computing new coordinates on the fly).

Of course, you do not typically need to drag lines of text around on screens but you could. I am merely pointing out that you can either write a block of code that grovels over a possibly complicated data structure and does ALL the computation to turn all coordinates into final values, OR you can keep your coordinates as relationships between objects and essentially compute the final coordinates at rendering time.

I decided to use hierarchical coordinates to compute the y-values of our Page, Sys, and Staff objects because it would ALLOW me to at some later time easily write the code that would let me drag an entire system of music further down the page or to rearrange the music staffs. We will NOT actually do any of that in this class but, hey, I get to show you how hierarchical coordinates work.

And after all that talk, here is the simple code that you should add to G 

--add static class HC to G 
  //--------------------Hierarchical Coordinate------------------
  //  every coordinate has a dad (possibly ZERO), and represents an offset from dad
  public static class HC{
    public static HC ZERO = new HC(null,0);
  
    public HC dad;
    public int dv;  // delta value from dad
  
    public HC(HC dad, int dv){this.dad = dad; this.dv = dv;}
  
    public int v(){return dad == ZERO ? 0 : dad.v()+dv;} // the value of the coordinate
  }

The code is simple enough that I won't test it. We will see if it works when we write the Page, Sys, and Staff code.

::S Staff
==Staff

To remind you, the music notions are that a Staff is the set of five line, a Sys is a collection of several staffs, and a page is a collection of several systems that all have the same layout copied from the first system on the page. We will have classes that represent each of those things and we will start at the bottom, with Staff.

--in music add class Staff
  package music;import graphics.G;import reaction.*;import java.util.ArrayList;
  
  public class Staff extends Mass{
    public Sys sys;        // the system that this staff lives in
    public int iStaff;     // the index of WHERE it lives in the system
    public G.HC staffTop;  // where the top of the staff will be on the screen.
    public Staff.Fmt fmt;  // the format used for drawing this staff
  
    public Staff(Sys sys, int iStaff, G.HC staffTop){
      super("BACK"); this.sys = sys; this.iStaff = iStaff; this.staffTop = staffTop;
    }
  
    public int yTop(){return staffTop.v();}
    public int yOfLine(int line){return yTop() + line*fmt.H;}
    public int yBot(){return yOfLine(2*(fmt.nLines-1));}
  
    //-----------------STAFF FMT--------------------
    public static class Fmt{
      public static Fmt DEFAULT = new Fmt(5,8);
      public int nLines, H;
      public Fmt(int nLines, int H){this.nLines = nLines; this.H = H;}
    }
  
    //--------------------STAFF.LIST-------------------
    public static class List extends ArrayList<Staff>{
      public G.HC sysTop;
      public List(G.HC sysTop){this.sysTop = sysTop;}
      public int sysTop(){return sysTop.v();}
    }
  }

We have written a helper class, Staff.Fmt, which holds the number of lines on the staff. The default number is 5 but there are some exceptions. Percussion/Drum tracks have no pitch and are often drawn on a single line, and Guitar Tablature uses 6 lines, one for each string on the guitar. Mandolins have 4 strings and so their tablature notation uses only 4 lines. 

The value H that is in there, represents the Height or the spacing but it is NOT the size of the gap between two lines, it is one HALF of the space between two staff lines. The reason is that we draw noteheads either on lines OR inbetween the lines, so we think of the lines as numbered with 0 as the top line of a staff, 1 is the number of the psuedo-line that goes down the middle between the top two lines, 2 in the number of the second line down and so on.

I wrote some coordinate functions for the staff, yTop(), yBot() and the helper yOfLine().

The Staff class also includes a List class that wraps up several staffs. This will be used by the Sys class since that is the job of a Sys, and that is also the reason that I included an HC sysTop in the List class. Basically when a Staff joins a List, it will use that list's top value as its dad. Each staff will thus be at a fixed offset from the top of the Sys that it belongs to.

--add a constructor
  public Staff(Sys sys, int iStaff, G.HC staffTop){
    super("BACK"); fmt = Fmt.DEFAULT;
    this.sys = sys; this.iStaff = iStaff; this.staffTop = staffTop;
  }

Before we finish talking about the Staff class, I should probably emphasize the int iStaff. This is a common data sctructure pattern. It often happens that you have one object A that has a list of B objects. Every B must be somewhere on that list. If that list in A is the ONLY list of those B objects, you might want to be able to navigate from a single B object to where it is on the list by remembering its index on that list. 

And that is the situation with a Sys which holds a list of Staffs. It is also the relationship between a Sys and a Page which holds a list of Sys. There will be times when a staff may need to know where its immediate neighbors are and thus it is convenient assign an index to each staff. That is what iStaff is: the index of this Staff in the list of Staffs maintained by its Sys.

The Staff class is not quite finished. We will need a show routine to draw the 5 lines, but it needs to know the x margins and we haven't defined those yet so we will defer the show routine.

::S Sys
==Sys

Here is the outline of the Sys class:

--in music create class Sys
  package music;import reaction.*;import java.util.ArrayList;
  
  public class Sys extends Mass{
    public Page page;
    public int iSys;
    public Staff.List staffs; // my y value is hidden in my list of staffs.
  
    public Sys(Page page, G.HC sysTop){ // STUB
      super("BACK");
    }
    
    public int yTop(){return staffs.sysTop();} // y value maintained in staff list.
    public int yBot(){return staffs.get(staffs.size()-1).yBot();}
    public int height(){return yBot()-yTop();}
  
    //---------------------LIST----------------------------
    public static class List extends ArrayList<Sys>{}
  }
  
We defer writing the constructor, we put in a stub, until we see what the page looks like.

But we can do some of the coordinate calculations. yTop is easy because that is what the HC y encodes.

yBot is not too difficult either, is it just yBot of the very last staff on the list of all staffs.

::S Page 
==Page

A Page is primarily a list of Sys objects. Typically any page in music has only a single type of Sys all down the page. A complicated musical composition, like a symphony, may well have different instruments in play for different movements of the piece, but typically there is a page break in a printed score when you change instrumentation so pages do not have lots of different system types on a single page. So a piano solo will have every system consist of the two staffs, right hand and left hand. A Flute sonata will have 3 staffs, one for the fluet and two for the keyboard. A String Quartet will have four staffs in every system, etc.

Because all the Systems on a page are of the same type it is customary to have them all spaced a uniform width apart. So we will add a int sysGap to our members to remember that spacing.

-- add Page to music
  package music;import graphics.*;import reaction.*;import java.util.ArrayList;
  
  public class Page extends Mass{
    public Margins margins = new Margins(); 
    public int sysGap; // size of spacing between Sys on page, set by adding 2nd Sys
    G.HC pageTop;
    public ArrayList<Sys> sysList = new ArrayList<>();
    
    public Page(int y){
      super("BACK");
      margins.top = y; 
      pageTop = new G.HC(G.HC.ZERO, y);    // pageTop will be dad for each Sys
      G.HC sysTop = new G.HC(pageTop,0);   // locate the top of first system
      sysList.add(new Sys(this, sysTop));  // create first system on page.
   
      // ..reactions will go here..
    }
  
    //-----------------MARGINS--------------------------
    public static class Margins{
      private static int MM = 50;
      public int top = MM, left = MM, bot = UC.mainWindowHeight - MM ,right = UC.mainWindowWidth - MM;
    }
  }

As you can see I created a helper class to hold the margins for the page. That Margin constructor created a top margin, but we don't actually used that margin for the music. The first system will go where the user placed it with the first gesture. If we were adding text to the top of the page we would use the top margins defined by the page. The staffs that eventually draw themselves on the page will be using the x values set in the Page Margins.

We create our first system on the page directly in the Page constructor, but subsequent systems will be created differently. They will essentially be copies of the first system that was put on the page. So let us now put a function into the Page class which will be the target for a Page Reaction that will add the second or later systems to a page.

--in Page write addNewSys
  public void addNewSys(int y){ // called by a page reaction, so safe to assume 1 Sys already
    int nSys = sysList.size(), sysHeight = sysList.get(0).height();
    if(nSys == 1){  // size==1 means we are adding 2nd Sys - 2nd defines sysGap
      sysGap = y - sysHeight - pageTop.v();
    }
    // calculate a new HC for the top of the new sys
    G.HC sysTop = new G.HC(pageTop, nSys*(sysHeight+sysGap));
    sysList.add(new Sys(this, sysTop));
  }

Similarly, we will need the target action for the other reaction, where we just add a new Staff to the existing first System. This will be a Sys function

--in Sys add addNewStaff()
  public void addNewStaff(int y){
    int off = y - staffs.sysTop.v();
    G.HC staffTop = new G.HC(staffs.sysTop, off);
    staffs.add(new Staff(this, staffs.size(), staffTop));
  }

Now we can finish the Sys constructor

==Finish Sys Constructor
--add to Sys
  public Sys(Page page, G.HC sysTop){
    super("BACK");
    this.page = page;
    iSys = page.sysList.size();
    staffs = new Staff.List(sysTop);
    if(iSys == 0){ // first system is created with first staff in system
      staffs.add(new Staff(this, 0, new G.HC(sysTop,0)));
    } else { // other systems are clones of first system
      Sys oldSys = page.sysList.get(0);
      for(Staff oldStaff: oldSys.staffs){
        Staff ns = oldStaff.copy(this);
        this.staffs.add(ns);
      }
    }
  }

This constructor made a call to a function in Staff that we haven't defined yet that will make a copy of a previous staff. The copying that is being done is that the new staff will belong in a new system so it needs to join the new system list, but it will have the same format as the old staff and it will have the same offset from its new sysTop as the old one did from the old sysTop.

--add to Staff
  public Staff copy(Sys newSys){ // create copy of this for new system sys
    G.HC hc = new G.HC(newSys.staffs.sysTop, staffTop.dv);
    return new Staff(newSys, iStaff, hc);
  }

== Fix the show routines

Now that we know where the margins are in the page we can create the show routine for Staffs

--in Staff add 
  public void show(Graphics g){
    Page.Margins m = sys.page.margins;
    int x1 = m.left, x2 = m.right, y = yTop(), h = fmt.H*2;
    for(int i=0; i<fmt.nLines; i++){g.drawLine(x1, y+i*h, x2, y+i*h);}
  }

Since Systems are mostly just a list of Staffs and since the Staffs all live out in the layers and know how to show themselves there is very little to do in the Sys show routine. The main thing that we need is to draw a vertical line down the left margin connecting the top line of the top staff to the bottom line of the bottom staff, showing that they are all connected into a single system.

--in Sys add
  public void show(Graphics g){
    int x = page.margins.left;
    g.drawLine(x, yTop(), x, yBot());
  }

Similar to my comment about the Sys show routine, the Page, being a list of Systems that can all show themselves has very little to do. I actually assumed that it had nothing to do so at first I didn't write a show routine. The bug that I saw was this: 

I forgot to set the color before I drew the lines in the above two routines, so they were being colored by the random BLUE color that I was using for drawing the gesture ink. I could have called set Color in each of those routines but it occured to me that since the Page was the first thing constructed, it will be in front of everything else in the Background layer and I could just have its paint routine set the color to black.

--in Page add 
  public void show(Graphics g){g.setColor(Color.BLACK);} // sets color for drawing Sys & Staffs 

==Page Reactions

To finish this up we need to add the 3 reactions. First the initial reaction that goes into the WinApp 

--in MusicEd modify the constructor
  public MusicEd(){
    super("Music Editor", UC.mainWindowWidth, UC.mainWindowHeight);
    Reaction.initialReactions.addReaction(new Reaction("W-W"){ // define top margin
      public int bid(Gesture g){return 0;}
      public void act(Gesture g){
        int y = g.vs.yM();
        PAGE = new Page(y);
        this.disable();
      }
    });
  }

That initial reaction isn't competing with anything else so the bid routine is easy. It always wins.

The act routine is also pretty simple it just constructs a new page and saves it to the static variable PAGE, and then this initial reaction is disabled so that we will NOT be creating any more pages.

We now add two reaction in the Page class

--add to Page constructor
  addReaction(new Reaction("W-W"){ // add newStaff to FirstSys only works if exactly 1 sys
    public int bid(Gesture g){
      // only allowed to add Staffs while there is only one Sys
      if(sysList.size() != 1){return UC.noBid;}
      Sys sys = sysList.get(0);
      int y = g.vs.yM();
      if(y < sys.yBot() + UC.minStaffGap){return UC.noBid;}
      return 1000;
    }
    public void act(Gesture g){
      sysList.get(0).addNewStaff(g.vs.yM());
    }
  });
  
  addReaction(new Reaction("W-E"){ // add new Sys to Page
    public int bid(Gesture g){
      Sys lastSys = sysList.get(sysList.size()-1);
      int y = g.vs.yM();
      if(y < lastSys.yBot() + UC.minSysGap){return UC.noBid;}
      return 1000;
    }
    public void act(Gesture g){
      addNewSys(g.vs.yM());
    }
  });

Please DO test this reaction code. Draw some W-W strokes in the wrong place and watch that bid function prevent you from overlapping your staffs. DO draw a second staff as close as that magic number in UC lets you. Was that a good magic number? In the early days building apps with only a couple of reactions that bids are mostly unimportant. Once you have hundreds of reactions running around, the bids ARE the thing that defines all the discrimination boundries that make the system behave this way rather than that way. You need to play with the system, doing things, to see if you have made doing things plesant or painful.

Next up we will work on Barlines (vertical lines that cut through systems)

SIDEBAR - Footnote on English pluralization. 

The English pluralization of the word "staff" is irregular. The proper English word is "staves". I almost never use irregular english pluralizations when I name variables in code. Code is more important than English. the word "staff" means "a single staff object" and the word "staffs" means "a single object that is probably either an array or an array list containing multiple staff objects". As you can see, neither word has ANTHING to do with the English meaning of "staff" and thus English pluralization is unimportant in this context. 

I ONLY call this to your attention for this reason - when I was using Ruby on Rails many years ago back when it was the hip thing to do, they used name conventions similar to the above where when you named a variable or class "foo" to hold a single object it would automatically create a variable named "foos" to hold an array of those objects. Well, SOMEONE involved in the development of Rails (probably someone from Brazil - where Rails was widly used) foolishly decided that the code for generating these names should use proper English pluralization. So if you created an object type with the name "person" well then an array of those should be named "people" NOT "persons". This is EVIL! 

It was wrong! I do understand why it happened. People who learns English as a second language generally takes pride (as they should) in knowing the proper exceptions and irregular grammar. It shows how careful they were in their schooling. However as a native English speaker, while I can speak English quite fluently and use all thos exceptions in speaking, I take NO PRIDE in it. English is garbage! It was invented by Barbarians who knew NOTHING about code!

In the context of code, regularity beats proper English EVERY TIME. The problem with the Rails "proper" English solution was that Rails had some function down in the guts somewhere that in order to generate those irregular names had to have a list of those exceptional spellings - none of which was documented! So did that list buried in the code somewhere actually contain EVERY single exceptional pluralization that ever occurs in the English language. Could I, even as a native speaker, KNOW before testing it which names would work in the code and which ones would not? -NO, I COULD NOT! - It was just a bad idea. 

Ever since looking at that mess I TRY to be more careful about NEVER using proper English in my code. In my code the plural of "person" is "persons" the plural of "man" is "mans" the plural of "sheep" is "sheeps" and yes as much as it pains me to look at it the plural of "sys" is "syss" or if I can't stand that, "sysList". In code, one completely regular pluralization rule - "just add an s" - is FAR superior to using proper English. You want simple code, simple grammar, simple English, NOT proper English 
END OF SIDEBAR

  
::S Barlines
==Barlines
--Day 11
Barlines are a fairly simple class at least they start out simple. The reaction is to draw from the topline of a staff to the bottomline of that same staff. If you see that, you add in a barline object that will draw lines at that same x value through EVERY staff that participates in the same system.

Notice that the reaction location is based on a single Staff, but in some sense the barline belongs NOT to that staff but rather to the entire system that that Staff belongs to. And the fact is, by the time we are done, the way that we will actually draw that barline for the system is dependent on some information that is burried in the Staff.Fmt, but we will get to that later.

Barlines show up in several different formats and we will just use an int to know what type of barline this is. The formats are these

0. single - this is the normal shape - one single thin line.
2. double - this is two thin lines, used for indicating KeySig or TimeSig change
2. fine - this is a fat one with a thin one on the left - marks end of piece (fine - pronounced FeeNay - Italian meaning Finish or End)
2. repeat left - just like a fine, fat, thin on left but also dots on left
2. repeat right - fat line with thin on the right and dots on right
2. repeat double - fat line with thin and dots on both sides
3.

So our actual drawing code will need to test this barType variable and have different drawing patterns. However, our first Bar code can just ignore it and draw a single line.

--in music create Bar class
  package music; import reaction.Mass;import java.awt.*;
  
  public class Bar extends Mass{
    private static final int FAT = 0x2, RIGHT = 0x4, LEFT = 0x8; // bits in barType
    /* 0=single; 1=double; 2=fine; if either of bits RIGHT or LEFT are set it is a repeat
      i.e. repeats dominate any of the lower bits.
      Intended reactions - S-S on empty space creates Bar, S-S on existing bar cycles between types.
      DOT to the right or left of Bar, toggles Dots (repeats) on that particular side.
    */
    public Sys sys;
    public int x, barType = 0;
  
    public Bar(Sys sys, int x){super("BACK");
      this.sys = sys; this.x = x; barType = 0;
    }
    
    public void show(Graphics g){
      for(Staff staff : sys.staffs){
        g.drawLine(x, staff.yTop(), x, staff.yBot());
      }
    }
  }

That show routine should draw a bar across every staff, so let's write the reaction to create a Bar and test it. The Bar reaction belongs in Staff

--add to Staff constructor
  addReaction(new Reaction("S-S"){ // create Bar line
    public int bid(Gesture g){
      Page PAGE = sys.page;
      int x = g.vs.xM(), y1 = g.vs.yL(), y2 = g.vs.yH();
      if(x < PAGE.margins.left || x > PAGE.margins.right){
        return UC.noBid;
      }
      int d = Math.abs(y1 - Staff.this.yTop()) + Math.abs(y2 - Staff.this.yBot());
      return (d < 30) ? d : UC.noBid; // If result isn't close enough then don't bother
    }
    public void act(Gesture g){
      new Bar(Staff.this.sys, g.vs.xM());
    }
  });
      
The reaction just looks for a S-S that starts at the topline of a single staff and runs to the bottom line of the single staff and lands within the margins.

Test it. 
 
==Multi-Threading Warning
There is a problem lurking in the background of this project that you should be aware of. I am telling you about it now because as I was testing and fixing some code I got a null pointer exception. As you know these are easy to get if you make a mistake and forget to initialize something. That was my mistake and I easily fixed it. BUT it did trigger a memory that the design that I am using here in my code can occassionally generate null pointer exception and I am not going to attempt to systematically fix it all through the code. (I would just assign that to an intern) 

The problem is this: When you are running Swing you are running multi-threaded code. ANYTIME you build something that is multi-threaded you run the risk of race conditions. Something in thread 1 normally happens before something in thread 2 and there is no problem, but occasionally, maybe once a year, thread 1 got delayed and thread 2 got to something BEFORE thread 1 got there and CATASTROPHE - CRASH. These bugs are generally VERY hard to find because they work perfectly for so long that you think everything is OK but very rarely CRASH! It is NOT that fixing these bugs is so hard but detecting them and repeating them when they almost NEVER happen is what is so hard.

So here is the bug lurking in the background of this entire Swing project. Swing has two threads. painting happens on one thread that you don't own and your code runs on the other thread. When you look at your code, you build a constructor for an object, you fill in the fields and hand it off to some other object are all the fields set up? Normally, yes. But suppose instead that you create some object, like a Mass, it has a show routine and it has fields, You call the constructor for your NoteHead object. Because it is a Mass, it calls the super routine to construct the Mass. Masses live in layers, the mass is added to the layer, you return from that call to super and finish filling out the fields of your NoteHead object. HOWEVER, something happened in the OS. It decided to call your paint routine on the thread that it owns. Paint wants to paint all the layers. It gets to the layer with your NoteHead in it and calls its show routine ALL BEFORE MASS ever finish getting though its constructor and before your NoteHead constructor got to fill in a single field in the notehead. OOPS!

The fix - there are several. Just ignore it - it almost never happens. The OS is NOT repainting your screen randomly and even if it does, the time between that call to Mass.super and the NoteHead cosnstructor is just a few lines of code. It is TINY. The second alternative is to NOT put the Mass into the layers in the Mass.super - instead, require every single class which is an extension of Mass to add itself explicitly to the Layers AFTER it has filled in all the fields - more code that you have to remember to add to every single constructor - which is just more code that you could easily forget to add causing a different bug until you see it and go fix it. Third alternative - put guards into the show code. Any thing that is being shown, should be guarded in case a field has not yet been filled in. 

And my choice is: - option 1. Ignore it. Let the interns fix it. I am a designer. I am trying to hack out code as fast as I can to see what will and will not work. My code is NEVER stable. I write it, I rip it out, I change it all the time. Writing EXTRA code to guard against something that almost never happens just slows my development. I am writing DEMO code, not production code. While building a demo, I live on the edge, race conditions may happen. Pointers might be null.   

I call this to your attention becasue I am indeed writing code here with known flaws that I am NOT fixing. I KNOW that, and every time I see a null pointer error I am aware that a possible reason is my risky design. 

I point this out to you with the fear that you will now worry about this problem every time YOU see a null pointer exception. That would be wrong. Null pointer problems are almost alway just a stupid omission on my part. (I am, after all, the one writing this demo code!) I usually just forget to set something up. But it is good for me to reminded you that there really are monsters that lurk in the jungle of multi-threaded apps, waiting patiently for the chance to bite you, if they can just move fast enough. Do not fear the Tiger. You will probably never see one. They are exceedingly rare, but they do exist. Do not close your mind to the possibility.

==Back to the code

Test it out. Was that number 30 that I used is testing the total error I would tolerate in how close you were to the top and bottom staff lines too big or too small? I don't want just any vertical line that may have crossed several staffs to be considered a canditate for a Barline. 60 is pretty lax. We are using 8 for a value of H so the gap between lines in 16, so if you are within one line of the top and one line of the bottom it might be off by as much as 30. You should test and see if you like the constraints that you have imposed on the reaction. 

I saw a problem immediately during testing when I tried to put a barline exactly at the right margin. I can't draw to the right of the right margin - the bid rejects it. And if I draw to the left, then it doesn't line up exactly. Humm...

Nothing is free. If I want that "snap to the right margin" behavior I need to build it in. One way would be to both relax the bid code to let me draw slightly to the right of the right margin, and then make the Bar constructor fix x values that are close to the right.

--build a UC constraint
  public static final int barToMarginSnap = 20;

--relax the bid
  int left = PAGE.margins.left, right = PAGE.margins.right;
  if(x<left || x > (right + UC.barToMarginSnap) ){return UC.noBid;}

--Snap in the Bar constructor
  int right = sys.page.margins.right; // snap to right margin
  if(Math.abs(right - x) < UC.barToMarginSnap){this.x = right;}
  
Test it out and see if you like the snapping behavior.

==Double Bars

Of course one of the things that we have not installed yet is that real measures do have an aversion to one another. You need enough space between them to place some notes and things between any two of them. Right now we can put them right up against one another, so we will correct that now.

We want to add a Reaction to the Bar itself. The Bar reaction looks for a S-S stroke that is very close to an existing bar. When that happens, we want it to outbid the simple create Bar gesture that the staff put up and instead treat it as a gesture to upgrade the existing Bar to a different type. It will cycle the types. So let us first create the cycleType function that will be the action. In fact, while we are at it, let's build the two fuctions that will allow us to toggle the Left and Right repeat bars as well. So these next 3 functions are the ways that we will be able to modify the barType.

--add to Bar    
  public void cycleType(){barType++; if(barType > 2){barType = 0;}}
  public void toggleLeft(){barType = barType^LEFT;}
  public void toggleRight(){barType = barType^RIGHT;}
  
The reaction to upgrade an existing bar will want to reject bars that are drawn outside of the system so we mostly want them drawn between the system top and the system bottom so we will use the sys yTop() and yBot() functions.

--add to Bar constructor
  addReaction(new Reaction("S-S"){ // cycle this Bar
    public int bid(Gesture g){
      int x = g.vs.xM();
      if(Math.abs(x - Bar.this.x) > UC.barToMarginSnap){return UC.noBid;}
      int y1 = g.vs.yL(), y2 = g.vs.yH();
      if(y1 < Bar.this.sys.yTop()-20 || y2 > Bar.this.sys.yBot()+20){return UC.noBid;} // y1 && y1 both in sys range
      return Math.abs(x - Bar.this.x);
    }
    public void act(Gesture g){
      Bar.this.cycleType(); // this function does not exist yet
    }
  });

Notice the value that I return for the bid here is the distance between the S-S stroke and the actual x value of the existing bar, and we REJECTED any such x that was NOT within UC.barToMarginSnap. So the maximum value that we will return in our bid here for a S-S that was close to an existing bar will be UC.barToMarginSnap.

Now I want this reaction to upgrade an existing Bar to be able to OUTBID that other reaction to a S-S stroke that creates a new bar. 
  
In order for this to work correctly we need to adjust the bid code for that previous Staff Reaction which creates bars. Right now, a perfect staff reaction, where the two y values were spot on would give a perfect bid of zero so I am going to bias it up a bit. If I bias the amount that the createBar reaction bids so that it is always bigger than UC.barToMarginSnap then my barUpgrade reaction code will alway be able to underbid a createBar reaction. So we modify the bid code in the createBar reaction in Staff  

--in Staff constructor S-S reaction bid
  int bias = UC.barToMarginSnap; // max cycleBar bid which must outbid createBar
  return (d < 30)? (d + bias):UC.noBid; 
  
We have not yet updated our show function to actually show the different bar types, but we could still test that the code to cycleType is working properly. Just add some code to the existing show routine to color the bar red if the type is 1 and black otherwise and confirm that it is cycling between 3 different valuse one of which is the value 1.
    
--modify show code in Bar
  g.setColor((barType==1) ? Color.RED : Color.BLACK); 

==Graphics helpers  

The visual apperance of the different bar types involve fat lines and thin lines and little lines that run at angles for the repeat bars and also some dots for the repeat bars, so we will write helpers that draw those particular shapes.

--add to Bar    
  public static void wings(Graphics g, int x, int y1, int y2, int dx, int dy){
    g.drawLine(x, y1, x+dx, y1-dy);
    g.drawLine(x, y2, x+dx, y2+dy);
  }
  public static void fatBar(Graphics g, int x, int y1, int y2, int dx){g.fillRect(x, y1, dx, y2-y1);}
  public static void thinBar(Graphics g, int x, int y1, int y2){g.drawLine(x, y1, x, y2);}
  public void drawDots(Graphics g, int x, int top){ 
    // from top of single staff
    // notice - this code ASSUMES nLine is 5. We will need to fix if we ever allow
    // not-standard staffs.
    int H = sys.page.maxH;
    if((barType & LEFT) != 0){
      g.fillOval(x-3*H, top+11*H/4, H/2, H/2);
      g.fillOval(x-3*H, top+19*H/4, H/2, H/2);
    }
    if((barType & RIGHT) != 0){
      g.fillOval(x+3*H/2, top+11*H/4, H/2, H/2);
      g.fillOval(x+3*H/2, top+19*H/4, H/2, H/2);
    }
  }
  
The above code makes reference to a field in Page that we did not define but we should have. If your system happens to have different sized staffs on it they can have different sized H values and we want to know the biggest one that the system holds so that the fat bars match the the line spacing of the biggest staff. The proper place to hold this value will be the page since all the systems on the page have the same basic format. So we need to do two things. Put a maxH member into page, and also a function to update that value every time we add a new staff to the first system.

--in Page add:
  public int maxH = 0; // largest H value in all the Staff.Fmt for the system.
  
  public void updateMaxH(){
    Sys sys = sysList.get(0);
    int newH = sys.staffs.get(sys.staffs.size()-1).fmt.H; // H from recent staff addition
    if(maxH<newH){maxH=newH;}
  }

Then we need to call that update function in every place that we add a staff to the system. There are 2 places where we do that, First in the Sys constructor when we add the very first staff to the first system. Secondly, in the addNewStaff routine.

--in Page constructor, after placeing new Sys in sysList, add
  updateMaxH();

--in Sys, addNewStaff(), add:
  PAGE.updateMaxH();

When we draw the different types of Bars, we will draw them so that the fatBar, if there is one, hangs to the left of the x value for the Bar. This is done so that a Fine bar at the end of the peice, whose x value will be the right margin will exactly fit on the staff (that is the USUAL location for a Fine Bar, at the end of the piece). 

There is something else that we need to do in the Staff.Fmt class.

We have implied so far that barlines alway cut through every staff in the system, and indeed they always do, BUT sometimes they also go through the space between two adjacent staffs also. For example, piano parts always have two staffs, one for the right hand and one for the left, and the barlines always run from the top line of the Right Hand staff to the bottom line for the Left Hand staff. I believe that it is customary in orchestral music to have the barlines run from the top of the string section to the bottom of the string section, but to have a break between the strings and the woodwinds. 

I don't actually care about the particular customs and neither should you, what we do care about is including the feature to allow bars to be draw between two adjacent staffs. We will allow the user to indicate how they want the bars to draw or to NOT draw in the intervening space by adding a reaction. If the user draws a S-S that goes exactly from the bottom line of one staff to the top line of the next staff in the first system, we will set a boolean value, barContinues, in the Staff.Fmt object for the first staff. Thus if you see barContinues for staff iStaff=7 you know that a the bar continue from staff 7 to staff 8.

--add member to Staff.Fmt and a function that toggles it
  public boolean barContinues = false;
  public void toggleBarContinues(){barContinues = !barContinues;}

==Oops!

As soon as I added that code to Staff.Fmt, I realized that I had a bug. Now sure, I could have gone back an rewritten my notes, done it right in the first place so the bug doesn't happen, but then I would have robbed you of the experience of noticing and fixing bad design decisions along the way.

The problem is this: I saw the DEFAULT staff format, with H = 8 and 5 lines and realized that the way I have built this code is that I set the format to DEFAULT in the staff constructor. Every single staff that we ever create uses the one single 5 line staff, because that is all I was thinking about. Well that was NOT correct. If I ever wanted to change a single staff to having 6 lines, sure I could remove the DEFAULT fmt object and plug in a new one with 6 lines but that would only change that one single staff. It would NOT change all the other staffs in all the other systems that were presumably copies of this staff. I would need to track them all down and change them all which is not right.

I only noticed this now when I got to thinking of changing barContinues in the staff format. If I want the bar to continue from the right hand to the left hand of a piano staff, I want it to continue from the right hand to the left hand in every single system. So if the piano right hand happens to be the 3rd staff down in the system list, I want the 3rd staff down in every single system to share a single Staff.Fmt object but as I run down a single system I want every successive staff to have a different fmt so that when I change a single staff's fmt, those changes are shared by other systems but NOT shared across a single system.

This is a genuine structural change but fortunately it is not difficult. We need to fix the Staff construcotr so that we can pass in a Staff.Fmt object instead of just automatically reusing a DEFAULT object. Then we either pass in a genuine new Staff.Fmt object when we are adding a new Staff to the first system in addNewStaff, or we fetch out the fmt object from an existing Staff object when we are copying staffs to make up a new system.

With that understanding in place, let us make those changes.

--In Staff modify the constructor to take in a new parameter
  public Staff(Sys sys, int iStaff, G.HC staffTop, Staff.Fmt fmt){
    super("BACK"); this.fmt = fmt;
    ... 

The IDE helps us locate all places where we used to call a Staff constructor without a fmt parameter

--in Staff modify the copy routine to copy fmt
  public Staff copy(Sys newSys){ // create copy of this for new system sys
    G.HC hc = new G.HC(newSys.staffs.sysTop, staffTop.dv);
    return new Staff(newSys, iStaff, hc, fmt);
  }    
  
That code now shares an existing fmt with a new staff in a new system.  

--in Sys constructor 
  if(iSys == 0){ // first system is created with first staff in system
    // staffs.add(new Staff(this, 0, new G.HC(sysTop,0))); // constructor needs fmt 
    staffs.add(new Staff(this, 0, new G.HC(sysTop,0), new Staff.Fmt(5,8))); 

--in Sys addNewStaff() modify a line
  // staffs.add(new Staff(this, 0, staffTop)); // constructor needs fmt    
  staffs.add(new Staff(this, 0, staffTop, new Staff.Fmt(5,8)));

Do test that you haven't broken anything with those changes. You won't be able to see anything different yet because we have not actually implemented anything that shows the effect of barContinues, but we now believe that it at least has a chance of working.  

The Bar show code becomes somewhat complicated by this barContinues behavior. In particular, when you are doing repeat bars, which have little wing tips on them, those wing tips do NOT show up on every staff. They only show up on the ends of the long connected components, on the other hand, the dots on a repeat bar DO show up on every staff. So we must build into the show code the logic that notices when we are at the top of a new connected component (which always comes just after a break) and to also notice when we have hit the end of a connected component (which always occures when bar does NOT continue). Only when we are at the end of a connected component will we have the two y values that we need to draw that connected component.

--add to Bar
  public void show(Graphics g){
    int sysTop = sys.yTop(), y1=0, y2=0; // y1,y2 mark top and bot of connected component
    boolean justSawBreak = true; // signals when we are at the top of a new connected component
    for(int i = 0; i<sys.staffs.size(); i++){
      Staff staff = sys.staffs.get(i);
      int staffTop = staff.yTop(); // top of this staff
      if(justSawBreak){y1 = staffTop;} // connected component starts from LAST break
      y2 = staff.yBot();  // remember bottom of this staff
    
      justSawBreak = !staff.fmt.barContinues; // now compute THIS break
      if(justSawBreak){ // we now have a connected component from y1 to y2
        drawLines(g, x, y1, y2);  // lines show only at end of connected components
      }
      if(barType > 3){drawDots(g, x, staffTop); } // dots on every staff w/ repeats
    }
  }

    
and here is the helper routine to draw the vertical lines:

--add to Bar
  public void drawLines(Graphics g, int x, int y1, int y2){
    int H = sys.page.maxH;
    if(barType == 0){ thinBar(g, x, y1, y2);}
    if(barType == 1){ thinBar(g, x, y1, y2); thinBar(g, x-H, y1, y2);}
    if(barType == 2){ fatBar(g, x-H, y1, y2, H); thinBar(g, x-2*H, y1, y2);}
    if(barType >= 4){ fatBar(g, x-H, y1, y2, H); // all repeats have fat bar
      if((barType&LEFT) != 0){thinBar(g, x-2*H, y1, y2); wings(g, x-2*H, y1, y2, -H, H);}
      if((barType&RIGHT) != 0){thinBar(g, x+H, y1, y2); wings(g, x+H, y1, y2, H, H);}
    }
  }

That should finish the graphics code that we needed to draw all the varient types of Bars. With that in place, we are ready to create the reaction.
      
--add to Staff constructor
  addReaction(new Reaction("S-S"){ // toggle BarContinues
    public int bid(Gesture g){
      if(Staff.this.sys.iSys != 0){return UC.noBid;} // we only change bar continues in first system
      int y1 = g.vs.yL(), y2 = g.vs.yH();
      if(iStaff == sys.staffs.size()-1){return UC.noBid;} // last staff in sys can't continue
      if(Math.abs(y1 - yBot()) > 20){return UC.noBid;}
      Staff nextStaff = sys.staffs.get(iStaff + 1);
      if(Math.abs(y2 - nextStaff.yTop()) > 20){return UC.noBid;}
      return 10;
    }
    public void act(Gesture g){
      fmt.toggleBarContinues();
    }
  });

    
--Day 12  

We will also want a reation to allow us to dot an existing Bar on either the right or left and call the appropriate toggleLeft and toggleRight routines that we created.

--add to Bar constructor
  addReaction(new Reaction("DOT"){ // Dot this Bar
    public int bid(Gesture g){
      int x = g.vs.xM();
      int y = g.vs.yM();
      if(y < Bar.this.sys.yTop() || y > Bar.this.sys.yBot()){ return UC.noBid; }
      int dist = Math.abs(x - Bar.this.x);
      if(dist > 3*sys.page.maxH){ return UC.noBid; }
      return dist;
    }
    public void act(Gesture g){
      if(g.vs.xM() < Bar.this.x){ Bar.this.toggleLeft(); }else { Bar.this.toggleRight(); }
    }
  });
      
==Bar Version 1 - Post-Mortem

We will quit for now with Bars able to draw our different barTypes. There are other things that we will eventually need to do with Bars but we don't need them immediately. For one thing, the entire reason that we needed a double bar is that a double bar is something that indicates to the musician that you are changing the KeySig of the piece or possibly the TimeSig, so eventually double bars need to hold information like that. For another thing, it is useful to be able to talk about measure 7 in a piece and since measures start and end at barlines it is nice to have a list of all the barlines so that you can count them and write measure numbers above them. 

This is of course a modern invention - In DA OLDE DAYS, you didn't write measure numbers over measure bars, but you did occasionally write a letter in a circle above a bar. Then the conductor could say to the band, "I want us all to start 5 measures after letter C on page 9". Now that we type set with computers and since computers can obssively count and number every measure that information is often included for free along with the circled letters that you MUST support because hey, that's the tradition, and yeah, someday we should include the notion of hanging a circled letter over a measure bar as well.

In some ways, Bars are a good example of the type of change that happens as you evolve a system. It started out being simple code that ONLY drew lines across each staff. There was no notion of barContinues in the Staff.Fmt there were no connected components to draw. In order to get the more complicated look that shows up in real music we needed to 1) find a place in our data structures that could HOLD the information that allowed for the more complicated drawing, 2) modify our drawing code to respect and use that extra information during the drawing, 3) create a GUI component, i.e. a Gesture that would let the user insert their choices into the more complicated data structure.

As you can see, we had to hop all over the code in order to insert that behavior. The logical place to hold the barContinues information was the Staff.Fmt class. The GUI component, the reaction, had to be attached to a Mass so we used a Staff to notice that the user wanted to change the way that barlines cut through the systems. And of course, finally the drawing code was there in the Bar class, where you would expect it.

::S Java code
==MusicEd.java
  package music; 
  import graphics.*;import reaction.*;import reaction.Shape; 
  import java.awt.*;import java.awt.event.KeyEvent;import java.awt.event.MouseEvent;
  
  public class MusicEd extends WinApp{
    public Layer BACK = new Layer("BACK"), FORE = new Layer("FORE");
    public static boolean training = false;
    public static I.Area curArea = Gesture.AREA; //  Gestures or Training at any time
  
    public static Page PAGE; // single page app
      
    public MusicEd(){
      super("Music Editor", UC.mainWindowWidth, UC.mainWindowHeight);
      Reaction.initialReactions.addReaction(new Reaction("W-W"){ // define top margin
        public int bid(Gesture g){return 0;}
        public void act(Gesture g){
          int y = g.vs.yM();
          PAGE = new Page(y);
          this.disable();
        }
      });
    }
  
    public void paintComponent(Graphics g){
      G.fillBack(g);
      if(training){Shape.TRAINER.show(g); return;}
      Ink.BUFFER.show(g);
      Layer.ALL.show(g);
      g.drawString(Gesture.recognized, 900,30);
    }
  
    public void mousePressed(MouseEvent me){curArea.dn(me.getX(), me.getY()); repaint();}
    public void mouseDragged(MouseEvent me){curArea.drag(me.getX(), me.getY()); repaint();}
    public void mouseReleased(MouseEvent me){
      curArea.up(me.getX(), me.getY()); trainBtn(me); repaint();
    }
    public void trainBtn(MouseEvent me){
      if(me.getX()>(UC.mainWindowWidth-40) && me.getY()<40){
        training = !training; curArea = training ? Shape.TRAINER : Gesture.AREA;
      }
    }
    
    public void keyTyped(KeyEvent ke) {
      if(training){Shape.TRAINER.keyTyped(ke);repaint();}
    }
  
    public static void main(String[] args){PANEL = new MusicEd(); WinApp.launch();}
  }

==Page.java 
  package music; import graphics.*;import reaction.*;
  import java.awt.*;import java.util.ArrayList;
    
  public class Page extends Mass{
    public Margins margins = new Margins();
    public int sysGap; // size of spacing between Sys on page
    public G.HC pageTop;
    public ArrayList<Sys> sysList = new ArrayList<>();
    public int maxH = 0; // maximum H value in all Staffs in the system
    
    public Page(int y){
      super("BACK");
      // set up yFirstSys and create the first Sys which will create the first staff
      margins.top = y; pageTop = new G.HC(G.HC.ZERO, y);
      G.HC sysTop = new G.HC(pageTop,0);
      sysList.add(new Sys(this, sysTop));
      updateMaxH();
      
      addReaction(new Reaction("W-W"){ // add newStaff to FirstSys only works if exactly 1 sys
        public int bid(Gesture g){
          // only first system gets to bid and only if it is the only system
          if(sysList.size() != 1){return UC.noBid;}
          Sys sys = sysList.get(0);
          int y = g.vs.yM();
          if(y < sys.yBot() + UC.minStaffGap){return UC.noBid;}
          return 1000;
        }
        public void act(Gesture g){
          sysList.get(0).addNewStaff(g.vs.yM());
        }
      });
  
      addReaction(new Reaction("W-E"){ // add new Sys to Page
        public int bid(Gesture g){
          // only last sys gets to bid
          //if(iSys != (page.sysList.size() - 1)){return UC.noBid;}
          Sys lastSys = sysList.get(sysList.size()-1);
          int y = g.vs.yM();
          if(y < lastSys.yBot() + UC.minSysGap){return UC.noBid;}
          return 1000;
        }
        public void act(Gesture g){
          addNewSys(g.vs.yM());
        }
      });
    }
      
    public void addNewSys(int y){ // called by page, so safe to assume 1 Sys already
      int sysHeight = sysList.get(0).height(), nSys = sysList.size();
      if(nSys == 1){ // second sys defines sysGap
        sysGap = y - sysHeight - pageTop.v();
      }
      // calculate a new HC for the top of the new sys
      G.HC sysTop = new G.HC(pageTop, nSys*(sysHeight+sysGap));
      sysList.add(new Sys(this, sysTop));
    }
    
    public void show(Graphics g){g.setColor(Color.BLACK);} // sets color for staff drawing
    
    public void updateMaxH(){
      Sys sys = sysList.get(0);
      int newH = sys.staffs.get(sys.staffs.size()-1).fmt.H; // H from recent staff addition
      if(maxH<newH){maxH=newH;}
    }
  
    //-----------------MARGINS--------------------------
    public static class Margins{
      private static int MM = 50;
      public int top = MM, left = MM, right = UC.mainWindowWidth - MM , bot = UC.mainWindowHeight - MM;
    }
  }

==Sys.java 
  package music; import graphics.*;import reaction.*;
  import java.awt.*;import java.util.ArrayList;
  
  public class Sys extends Mass{
    public Page page;
    public int iSys;
    public Staff.List staffs; // my y value is hidden in my list of staffs.
    
    public Sys(Page page, G.HC sysTop){
      super("BACK");
      this.page = page;
      iSys = page.sysList.size();
      staffs = new Staff.List(sysTop);
      if(iSys == 0){ // first system is created with first staff in system
        staffs.add(new Staff(this, 0, new G.HC(sysTop,0), new Staff.Fmt(5,8)));
      } else { // other systems are clones of first system
        Sys oldSys = page.sysList.get(0);
        for(Staff oldStaff: oldSys.staffs){
          Staff ns = oldStaff.copy(this);
          this.staffs.add(ns);
        }
      }
    }
    
    public void show(Graphics g){
      int x = page.margins.left;
      g.drawLine(x, yTop(), x, yBot());
    }
    
    public int yTop(){return staffs.sysTop.v();} // y value maintained in staff list.
    public int yBot(){return staffs.get(staffs.size()-1).yBot();}// bot of last staff
    public int height(){return yBot()-yTop();}
    
    public void addNewStaff(int y){
      int off = y - staffs.sysTop.v();
      G.HC staffTop = new G.HC(staffs.sysTop, off);
      staffs.add(new Staff(this, staffs.size(), staffTop, new Staff.Fmt(5,8)));
      page.updateMaxH();
    }
    //---------------------LIST----------------------------
    public static class List extends ArrayList<Sys>{}
  }

==Staff.java 
  package music; import graphics.*;import reaction.*;
  import java.awt.*;import java.util.ArrayList;
  
  public class Staff extends Mass{
    public Sys sys;        // the system that this staff lives in
    public int iStaff;     // the index of WHERE it lives in the system
    public G.HC staffTop;  // where the top of the staff will be on the screen.
    public Staff.Fmt fmt;  // the format used for drawing this staff
  
    public Staff(Sys sys, int iStaff, G.HC staffTop, Staff.Fmt fmt){
      super("BACK"); this.fmt = fmt;
      this.sys = sys; this.iStaff = iStaff; this.staffTop = staffTop;
  
      addReaction(new Reaction("S-S"){ // create Bar line
        public int bid(Gesture g){
          Page PAGE = sys.page;
          int x = g.vs.xM(), y1 = g.vs.yL(), y2 = g.vs.yH();
          int left = PAGE.margins.left, right = PAGE.margins.right;
          if(x<left || x > (right + UC.barToMarginSnap) ){return UC.noBid;}
          int d = Math.abs(y1 - Staff.this.yTop()) + Math.abs(y2 - Staff.this.yBot());
          int bias = UC.barToMarginSnap; // max cycleBar bid which must outbid createBar
          return (d < 30)? (d + bias):UC.noBid; 
        }
        public void act(Gesture g){
          new Bar(Staff.this.sys, g.vs.xM());
        }
      });
  
      addReaction(new Reaction("S-S"){ // toggle BarContinues
        public int bid(Gesture g){
          if(Staff.this.sys.iSys != 0){return UC.noBid;} // we only change bar continues in first system
          int y1 = g.vs.yL(), y2 = g.vs.yH();
          if(iStaff == sys.staffs.size()-1 ){return UC.noBid;} // last staff in sys can't continue
          Staff nextStaff = sys.staffs.get(iStaff + 1);
          System.out.println("Staff"+iStaff+ " "+y1+":"+yBot()+ " - " + y2 +":"+ nextStaff.yTop());
          if(Math.abs(y1 - yBot()) > 20){return UC.noBid;}
          if(Math.abs(y2 - nextStaff.yTop()) > 20){return UC.noBid;}
          return 10;
        }
        public void act(Gesture g){
          fmt.toggleBarContinues();
        }
      });
    }
    
    public Staff copy(Sys newSys){ // create copy of this for new system sys
      G.HC hc = new G.HC(newSys.staffs.sysTop, staffTop.dv);
      return new Staff(newSys, iStaff, hc, fmt);
    }
    
    public void show(Graphics g){
      Page.Margins m = sys.page.margins;
      int x1 = m.left, x2 = m.right, y = yTop(), h = fmt.H*2;
      for(int i=0; i<fmt.nLines; i++){g.drawLine(x1, y+i*h, x2, y+i*h);}
    }
    
    public int yTop(){return staffTop.v();} // top line of staff, what y represents
    public int yOfLine(int line){return yTop() + line*fmt.H;}
    public int yBot(){return yOfLine(2*(fmt.nLines-1));}
    
    //-----------------STAFF FMT--------------------
    public static class Fmt{
      public static Fmt DEFAULT = new Fmt(5,8);
      public int nLines, H;
      public boolean barContinues = false;
      
      public Fmt(int nLines, int H){this.nLines = nLines; this.H = H;}
      public void toggleBarContinues(){barContinues = !barContinues;}
    }
    
    //--------------------STAFF.LIST-------------------
    public static class List extends ArrayList<Staff>{
      public G.HC sysTop;
      public List(G.HC sysTop){this.sysTop = sysTop;}
    }
  }

==Bar.java 
  package music; import reaction.*;import java.awt.*;
   
  public class Bar extends Mass{
    private static final int FAT = 0x2, RIGHT = 0x4, LEFT = 0x8; // bits in barType
      
    /* 0=single; 1=double; 2=fine; if either of bits RIGHT or LEFT are set it is a repeat
      i.e. repeats dominate any of the lower bits.
      Intended reactions - S-S on empty space creates Bar, S-S on existing bar cycles between types.
      DOT to the right or left of Bar, toggles Dots (repeats) on that particular side.
    */
  
    public Sys sys;
    public int x, barType = 0;
  
    public Bar(Sys sys, int x){super("BACK");
      this.sys = sys; this.x = x; barType = 0;
      int right = sys.page.margins.right; // snap to right margin
      if(Math.abs(right - x) < UC.barToMarginSnap){this.x = right;}
  
      addReaction(new Reaction("S-S"){ // cycle this Bar
        public int bid(Gesture g){
          int x = g.vs.xM();
          if(Math.abs(x - Bar.this.x) > UC.barToMarginSnap){return UC.noBid;}
          int y1 = g.vs.yL(), y2 = g.vs.yH();
          if(y1 < Bar.this.sys.yTop()-20 || y2 > Bar.this.sys.yBot()+20){return UC.noBid;} // y1 && y1 both in sys range
          return Math.abs(x - Bar.this.x);
        }
        public void act(Gesture g){
          Bar.this.cycleType(); // this function does not exist yet
        }
      });
  
      addReaction(new Reaction("DOT"){ // Dot this Bar
        public int bid(Gesture g){
          int x = g.vs.xM();
          int y = g.vs.yM();
          if(y < Bar.this.sys.yTop() || y > Bar.this.sys.yBot()){ return UC.noBid; }
          int dist = Math.abs(x - Bar.this.x);
          if(dist > 3*sys.page.maxH){ return UC.noBid; }
          return dist;
        }
        public void act(Gesture g){
          if(g.vs.xM() < Bar.this.x){ Bar.this.toggleLeft(); }else { Bar.this.toggleRight(); }
        }
      });
    }
  
    public void cycleType(){barType++; if(barType > 2){barType = 0;}}
    public void toggleLeft(){barType = barType^LEFT;}
    public void toggleRight(){barType = barType^RIGHT;}
  
    public void show(Graphics g){
      int sysTop = sys.yTop(), y1=0, y2=0; // y1,y2 mark top and bot of connected component
      boolean justSawBreak = true; // signals when we are at the top of a new connected component
      for(int i = 0; i<sys.staffs.size(); i++){
        Staff staff = sys.staffs.get(i);
        int staffTop = staff.yTop(); // top of this staff
        if(justSawBreak){y1 = staffTop;} // connected component starts from LAST break
        y2 = staff.yBot();  // remember bottom of this staff
      
        justSawBreak = !staff.fmt.barContinues; // now compute THIS break
        if(justSawBreak){ // we now have a connected component from y1 to y2
          drawLines(g, x, y1, y2);  // lines show only at end of connected components
        }
        if(barType > 3){drawDots(g, x, staffTop); } // dots on every staff w/ repeats
      }
    }
  
    public void drawLines(Graphics g, int x, int y1, int y2){
      int H = sys.page.maxH;
      if(barType == 0){ thinBar(g, x, y1, y2);}
      if(barType == 1){ thinBar(g, x, y1, y2); thinBar(g, x-H, y1, y2);}
      if(barType == 2){ fatBar(g, x-H, y1, y2, H); thinBar(g, x-2*H, y1, y2);}
      if(barType >= 4){ fatBar(g, x-H, y1, y2, H); // all repeats have fat bar
        if((barType&LEFT) != 0){thinBar(g, x-2*H, y1, y2); wings(g, x-2*H, y1, y2, -H, H);}
        if((barType&RIGHT) != 0){thinBar(g, x+H, y1, y2); wings(g, x+H, y1, y2, H, H);}
      }
    }
  
    public static void wings(Graphics g, int x, int y1, int y2, int dx, int dy){
      g.drawLine(x, y1, x+dx, y1-dy);
      g.drawLine(x, y2, x+dx, y2+dy);
    }
    public static void fatBar(Graphics g, int x, int y1, int y2, int dx){g.fillRect(x, y1, dx, y2-y1);}
    public static void thinBar(Graphics g, int x, int y1, int y2){g.drawLine(x, y1, x, y2);}
    public void drawDots(Graphics g, int x, int top){
      // from top of single staff
      // notice - this code ASSUMES nLine is 5. We will need to fix if we ever allow
      // not-standard staffs.
      int H = sys.page.maxH;
      if((barType & LEFT) != 0){
        g.fillOval(x-3*H, top+11*H/4, H/2, H/2);
        g.fillOval(x-3*H, top+19*H/4, H/2, H/2);
      }
      if((barType & RIGHT) != 0){
        g.fillOval(x+3*H/2, top+11*H/4, H/2, H/2);
        g.fillOval(x+3*H/2, top+19*H/4, H/2, H/2);
      }
    }
  }

::C Music Notes
::S Glyphs
==Glyphs

Before we start in on the classes that will hold all our music notes I want you to install the sinfonia true type font on your system. This is the font that we created at Sunhawk, my music notation company. It will make the music rendering much easier for things like Clef signs and flags and sharps and flats etc. There are of course many elements that are just lines and rectangles just like the staff lines and bar lines and whole rests and half rests that we do NOT keep in the font.

Of course fonts were never designed to hold things like music symbols that were intended to be scattered over the page and written at different sizes so in addition to the true type font, you will also want this helper class called Glyph, which deals with the issues of sizing and locating hot-spots.

--get sinfonia.ttf

The font is located on the same website where you found this book, it is just in a sub-directory so go to:

::I text
  http://depts.washington.edu/cprogs/BCS/
::I java  

Unlike my book which is all beautiful javascript enabled/rendered HTML, the above link just dumps you into the default directory viewer for a subfolder of my website and presumably down near the bottom you will see the file: sinfonia.ttf - just download it and install it. (I think you just double click on a font to install it these days)

--add Glyph.java to your music package.
  public class Glyph{
    // Offsets & Scales for Sinfonia True Type Font
    public static String fontName = UC.FontName;
    
    public static Glyph BRACE = new Glyph((char)61473, 16, 0, 4);
    
    public static Glyph CLEF_G = new Glyph((char)61479, 16, -3, 1);
    public static Glyph CLEF_F = new Glyph((char)61480, 16, -3, 4);
    public static Glyph CLEF_C = new Glyph((char)61481, 16, -3, 4);
    public static Glyph CLEF_TAB = new Glyph((char)61581, 10, -1, 1);
    public static Glyph CLEF_G8 = new Glyph((char)61639, 16, -3, 1);
    
    public static Glyph HEAD_HALF = new Glyph((char)61485, 16, 0, 0);
    
    public static Glyph FLAG1D = new Glyph((char)61487, 16, 0, 8);
    public static Glyph FLAG1U = new Glyph((char)61488, 16, 0, 1);
    public static Glyph FLAG2D = new Glyph((char)61489, 16, 0, 8);
    public static Glyph FLAG2U = new Glyph((char)61490, 16, 0, 1);
    public static Glyph FLAG3D = new Glyph((char)61491, 16, 0, 8);
    public static Glyph FLAG3U = new Glyph((char)61492, 16, 0, -1);
    public static Glyph FLAG4D = new Glyph((char)61493, 16, 0, 8);
    public static Glyph FLAG4U = new Glyph((char)61494, 16, 0, -3);
    
    public static Glyph REST_W = new Glyph((char)61499, 16, 0, 6);
    public static Glyph REST_H = new Glyph((char)61499, 16, 0, 7);
    public static Glyph REST_Q = new Glyph((char)61501, 16, 0, 5);
    public static Glyph REST_1F = new Glyph((char)61502, 16, 0, 6);
    public static Glyph REST_2F = new Glyph((char)61503, 16, 0, 6);
    public static Glyph REST_3F = new Glyph((char)61504, 16, 0, 4);
    public static Glyph REST_4F = new Glyph((char)61505, 16, 0, 4);
    
    public static int theSize = -1;
    public static Font theFont;
    
    public char code;
    public double scale, dx, dy;
    
    private Glyph(char code, double scale, double dx, double dy){
      this.code = code;
      this.scale = scale; this.dx = dx; this.dy = dy;
    }
    
    public void showAt(Graphics g, int H, int x, int y){
      int size = (int)scale*H;
      if(size != theSize){
        theFont = new Font(fontName, 0, size);
        theSize = size;
      }
      Font f = g.getFont(); // fetch old font so that we can restore it
      g.setColor(Color.BLACK);
      g.setFont(theFont);
      g.drawString(""+code, x + (int)Math.floor(dx*H), y + (int)Math.floor(dy*H));
      g.setColor(Color.RED);
      g.drawRect(x, y, H, H);
      g.setFont(f); // restore old font
    }
  }

Now we will hack up AaMusic to draw a single G clef on the page just to see that the font works.

--add paintComponent after Layer.ALL.show
    Glyph.CLEF_G.showAt(g, 8, 100, 100);
    
It should draw a G Clef at the scale size of 8, which you no doubt recognize as the default H value for our Staff. I don't recall what the hot spot for a G Clef is, exactly, but I presume that it is supposed to be the centerline of the 5 line staff.

We could test that out quickly by changing the y value to be based on the PAGE.top value. (Remember, PAGE is null until we draw our first shape so guard the drawing access to PAGE!)

--add to paintComponent
  if(PAGE != null){
    Glyph.CLEF_G.showAt(g, 8, 100, PAGE.margins.top + 4*8);
  }
  
Yes, it looks like the y value is the center line. That is the purpose of the Glyph class, to move us away from the standard BASELINE oriented font layout that is built into fonts and lets us draw our single shapes, like note heads, and sharp signs based on the stafflines where they belong. It also assigns names like, CLEF_G to characters in the font rather than making us remember UNICODE values for these very non-standard shapes.

Let us test another shape. I see HEAD_HALF defined there. Let us draw that on the center line as well a little bit further in x than the G Clef. add the line:

--add after the Clef showAt
  Glyph.HEAD_HALF.showAt(g, 8, 200, PAGE.margins.top + 4*8);
  
Run that. WTF? why did it draw it so high in the sky? We look at the numbers in the Glyph class and see HALF_HEAD was defined at

  public static Glyph HEAD_HALF = new Glyph((char)61485, 16, 0, 0);

No other glyph was drawn with a y of zero. This Glyph class is unfinished junk! Apparently no one ever tested it to see if it drew half note heads at the proper place. They look like they are all about an octave higher than they should be so I am going to try shifting it down by 7H, so I will change that line in Glyph to:

--fix line in Glyph
  public static Glyph HEAD_HALF = new Glyph((char)61485, 16, 0, 7);
  
That seems to fix that problem. And next I notice that there is no quarter note head or whole note head defined in Glyph, but come on, they MUST be there in that font. Where do you suppose they could be? In Windows, if I search for "font" I see that in their settings section they have a font preview app. Fire it up, type in sinfonia as the name of the font that you want to look at. Enlarge it so that it is big enough to see, and look, there is a quarter note head, just to the right of the half note head.

Oh wait, what? You're on a Mac and their font viewer only shows you the first few characters, A,B,C in this font that doesn't have ABC? How exactly is that MY problem?

Going back to the Glyph file and I see that HEAD_HALF is (char)61485 so I would guess that the quarter head is just one more than that so I add this line to Glyph:

--add to Glyph
  public static Glyph HEAD_Q = new Glyph((char)61486, 16, 0, 7);
  
And then I test if I am right by fixing the line in paintComponent to:

--draw Qhead in paintComponent
  Glyph.HEAD_Q.showAt(g, 8, 200, PAGE.margins.top + 4*8);
  
Looks like I found the quarter note head.

What I am trying to point out for you here is that Glyph is a mapping layer to help you display symbols that were defined in the sinfonia.ttf font. Any private font like this that was built for an application has the symbols in no particular order, in no particular size, located at no particular BASELINE. No one tells you what is in a font or where it is located. That trashy font viewer built into Windows and the worse one on the Mac, typically shows me only the first few characters in the font. It doesn't show the whole thing. If you want to know where some characters are and what they look like and where they are located YOU must write some code to draw characters to the screen. You look at where they land and how big they are and then you write the actual mapping that you need in your application.

This Glyph class IS that mapping layer and it is YOUR code, not mine. It is not finished. It isn't even right! It is not documented! It does NOT tell you what is in the sinfonia font. When you want something out of the sinfonia font, YOU get to grovel around and find it, then put what you need into Glyph. 

Glyph is not some special magical untouchable code. It is YOUR code from the moment that you copied it and included it in YOUR project. And it is UNTESTED code until YOU personally test it. This is no different from ANY code that you scrape off the internet, it might work it probably does not. 

Fortunately there is no need to do any bulk testing. You never need a character until you need it. We have just tested 3 of them, the GClef, the Half note head and the Quarter note head.

As I said before, this sinfonia font was the one that I developed for my music company, Sunhawk, many years ago.

IF you want to use someone else's musical font instead of sinfonia, you would have this exact same task ahead of you. You would need to map out the font, find where things are, figure out what size they are, figure out what scale factors and offsets you need in order to get them to behave how you want them. There is NO standard for these sorts of private application symbol fonts, which have certainly been built for Chemistry apps, Math apps, Music apps, Architecture apps etc.

I will give you a moment to grovel around and find the whole note head.

Next up: classes and gestures to produce notes.
  
::S Heads
==Notes
The next thing that we want to do in our music class is to get notes onto those staffs. We will probably need several classes for this next sprint, Head, Stem, Beam, Rest and probably Time, oh and Clef, we GOT to do clef or it doesn't look like music. 


==Head
We will start with note heads, which is the class Head. I won't even bother to try to outline where this class will be going. It will get where we want it to go by "progressive refinement". I want this example to be more in the style that I use most often, KISS, Keep It Simple Stupid! I try to write the least amount of code that I can that will let me display something and test something. In particular I want to test my note entry gesture, so the class that I build at this point ignores things like the shape of the note, or the fact that notes belong to shared time value. We will get all of that by refinement later. So here is a simple head class:

--create Head class
  public class Head extends Mass{
    public Staff staff;
    public int x, line; // line is a yCoord in disguise. Line 0 is top line, line 1 is first space, line 2 is next line down.
    
    public Head(Staff staff, int x, int y){
      super("NOTE"); this.staff = staff; this.x = x;
      int H = staff.fmt.H;
      int top = staff.yTop() - H; // y could be in the space above the top line which becomes -1
      line = (y-top + H/2)/H - 1; // snap y to nearest line
      System.out.println("Line: "+line); // debug code, watch it then comment it out.
    }
  
    public void show(Graphics g){
      int H = staff.fmt.H;
      Glyph.HEAD_Q.showAt(g,H,x, staff.yTop()+line*H);
    }
  }

I made the decision that the Head constructor should be responsible for the "snapping" to a particular line. This means that the gesture action can just pass the center y value of the gesture into the Head constructor which will figure out the line that coresponds to that y. The Y coordinates are of course in pixels but the lines are in units of H so a division by H converts from pixels scale to H scale. You will see that I added in an H/2. This is because integer division truncates, it does not round, so a number like 0.9 gets truncated to zero instead of being rounded up to 1. If you add in 0.5 before you truncate, you get rounding behavior.

In order to actually create a note we need a gesture in the staff class

--add to Staff constructor
  addReaction(new Reaction("SW-SW"){ // add Note to Staff
    public int bid(Gesture g){
      Page PAGE = sys.page;
      int x = g.vs.xM(), y = g.vs.yM();
      if(x < PAGE.left || x > PAGE.right){return UC.noBid;}
      int H = Staff.this.fmt.H, top = Staff.this.yTop()-H,  bot = Staff.this.yBot()+H;
      if(y < top || y > bot){return UC.noBid;}
      return 10;
    }
    public void act(Gesture g){
      new Head(Staff.this, g.vs.xM(), g.vs.yM());
    }
  });
  

Check it out. CRASH! No NOTE layer was defined. I decided to fix the way we were introducing layers. Previously I was creating static variables and giving them names, BUT I am never using those static variables, I am always just looking up the strings. So I replace the static variables in AaMusic with a single static block defining 3 layers.

--replace Layer static variables by static block
  static{new Layer("BACK");  new Layer("NOTE"); new Layer("FORE");}
  
Now I seem to be able to add notes.


::S Time
==Time
A more significant drawback to the Head code as it currently exists is that you can draw note heads with ANY x value. In standard music notation x alignment is VERY important. It is time. If two notes are written one exactly over the other, i.e. sharing an x value, they are sounded at the same time. It is a "chord". On the other hand, if the two notes are NOT in a chord, they should NOT overlap at all, you need some visual space between the notes to see that one comes after the other.

Basically the behavior that we want is this, the musician should be able to place a note anywhere, any x value, BUT once there is a note at an x-value, then any note (in the same system) that was drawn close to that same x-value MUST snap to share that same x. If the second note head is drawn sufficiently far away, then it can create a new x value which can be shared just like the first one.

So we will need something that corresponds to a pool of shared x values and we will need a name for that x value object. The name that I have selected is "Time" because that is what is actually being shared by the notes. Notes with a common x, are all sounded at the same time. So let us build that class. 

--create Time class
  public class Time{
    public int x;
  
    private Time(Sys sys, int x){this.x = x; sys.times.add(this);} // factory - apps call getTime(x)
  
    public static class List extends ArrayList<Time>{
      public Sys sys; // lists of times are shared across a single sys
      public List(Sys sys){this.sys = sys;}
      public static Time getTime(int x){... returns time close to x OR creates new and returns that...}
    }
  }
  
We must now upgrade the Sys class so that every sys contains a time list 
--add to Sys
  public Time.List times;
-- and initialize it in the constructor
  times = new Time.List(this);
-- write an accessor routine
  public Time getTime(int x){return times.getTime(x);}
  
With system upgraded like that, we will now upgrade our Head class to no longer use x. Instead it uses time.

--add Time to Head class & constructor
  public static class Head extends Mass{
    public Staff staff;
    public int line; 
    public Time time;  // uses time instead of x
    
    public Head(Staff staff, int x, int y){
      super("NOTE"); this.staff = staff; this.time = staff.sys.getTime(x);
      ...
      
And don't forget to fix the show routine to now use time.x instead of x.

This should work as soon as we actually write the code that we skipped over in the time class to get the closest time. How close forces a snap? I used a threshold of 30 which I put into UC.snapTime.

--add to Time.List
  public Time getTime(int x){
    if(size() == 0){return new Time(sys, x);}
    Time t = getClosestTime(x);
    return (Math.abs(x - t.x) < UC.snapTime) ? t : new Time(sys, x);
  }
  public Time getClosestTime(int x){
    Time res = get(0); int bestSoFar = Math.abs(x - res.x);
    for(Time t: this){
      int dist = Math.abs(x - t.x);
      if(dist < bestSoFar){res = t; bestSoFar = dist;}
    }
    return res;
  }

  
That should work. Run the app. If you haven't yet removed that first head that was being drawn to test the glyph class don't make the mistake of thinking that it has a time value. You can draw notes close to it that partially overlap, but the ones that you do draw should have time values and you should see that time snapping in action.

The next thing that I wanted to add to the Head class was the notion of headShape or type of head so that I can enter half notes and whole notes. I also want to put dots on notes, BUT after thinking about it, I am rather inclined to keep all that information in the Stem class that we have not written yet. The reason is that all the heads on a single stem are part of a chord and share things like the number of flags and dots. So rather than keep dots associated with heads, I will keep dots associated with stems and thus all the heads on a single stem automatically share the number of dots. 

In fact, the flags and the dots on a stem, essentially define the "duration" of the note and the other thing that has a duration is a rest. Rests can hold dots, and the fact is that every rest faster than a quarter rest has "flags" on it as well. So next up will will build a class to hold the common information needed by both stems and rests.

::S Duration
==Duration
Duration is a class that will be shared by both Stems and Rests. We would like both of those classes to extend Duration, BUT both Stems and Rests MUST be Mass objects, because both of them need to have show routines.

At first glance this seems to be a place where you would like to have multiple inheritance, and Java only permits single inheritance. However the first glance is WRONG. You simply have Mass be the ancestor of Duration and then Stem and Rest both descend from Duration.

We don't however want to have a show routine for a raw duration. What would you show? Until you know whether you are showing a rest or a stem you don't know what to draw. And this is what abstract classes are for, those times when you want to defer a routine to a child/subclass.

--create Duration class
  public abstract class Duration extends Mass{
    public int nFlag = 0, nDot = 0;
    public Duration(){super("NOTE");}
    // this next line NOT needed. It is already abstract from Mass. It is just a reminder of what is missing
    public abstract void show(Graphics g); 
  }  

Since this class holds the flags and the dots, we will put the behaviors that we need for changing those values in this class and then both Stems and Rests will share those notions. In the back of my head, I am thinking that I want to use and E-E stroke that crosses a Stem or a Rest, to be the stroke that increases the flag count on that stem. Similarly I will use a W-W stroke to decrease the flag count. Dot, on the other hand are so simple and we never have more than 3, we will simply cycle the dots between 0 and 3. If you dot 3 it goes back to zero.

--add to Duration  
  public void incFlag(){if(nFlag <4){nFlag++;}}
  public void decFlag(){if(nFlag >-2){nFlag--;}}
  public void cycleDot(){nDot++; if(nDot >3){nDot = 0;}} 

You will notice that I am going to allow flags to go negative. This has nothing to do with music notation. In music notation you either have flags or you don't. They can't go negative. BUT it is easy from a code standpoint to just let the flag count be zero for a quarter note (because there really are zero flags on a quarter note), then let nFlag be -1 for a half note, and -2 for a whole note. The fact that the code has to shift from drawing actual flags to changing the shape of the note heads is hardly a problem. The code can also easily surpress the actual drawing of a Stem for a whole note, BUT that stem will still there, it can still be dotted AND it can still be upFlagged back into a half note, then a quarter etc. 
  
::S Rests
==Rests
Now that we have a Duration class we are ready to build rests which are a simple extension to that.

--create Rest class
  public class Rest extends Duration{
    public Staff staff;
    public Time time;
    public int line = 4; // this is the default location of any rest
    
    public Rest(Staff staff, Time time){
      this.staff = staff; this.time = time;
      // eventually we will add reactions here to flag and dot our rests.
    }
  }

The show routine is mostly just a collection of calls to show the appropriate Glyph. I do need to calculate the y value for the middle line of the staff where the rest is located. I did write a Staff routine, yLine(int line), that will tell me the y value associated with a line. 

However, while thinking about that I realized that the code I put into the the Head constructor which goes the other direction, taking an y value and rounding it off to a line number SHOULD have been written as a helper in the Staff class as well. Ater all, line numbers is really what Staffs are all about. At some point we will want that code to work for ledger lines which could be above the top line, which means that we need to write the code so that it will work for small negative numbers as well. This requires just a bit of messiness because integer division does not truncate downward, instead it truncates toward zero.

--Minor Fix - add to Staff
  public int yLine(int n){return yTop() + n*H();}
  public int lineOfY(int y){
    int H = fmt.H;
    int Bias = 100;  // because integer truncation rounds toward 0 ..
    int top = yTop() - H*Bias;  // .. we move the origin to a line number like -100 in pixels
    return (y-top +H/2)/H - Bias; // .. calculate a big number then remove that Bias
  }
-- change Head Constructor to call lineOfY
   line = staff.lineOfY(y); // snap y to nearest line
-- add a routine to Rest to return its y value   
  public int y(){return staff.yOfLine(line);}
   
Now that we have access to a y value for a Rest we can build the show routine that selects the proper glyph to show.   

--add to Rest   
  private static Glyph[] glyphs = 
    {Glyph.REST_W,Glyph.REST_H,Glyph.REST_Q,Glyph.REST_1F,Glyph.REST_2F,Glyph.REST_3F,Glyph.REST_4F,};
  public void show(Graphics g){
  int H = staff.fmt.H, y = y();
  Glyph glyph = glyphs[nFlag+2];
  glyph.showAt(g, H, time.x, y);
  }

==Reactions to add Rests

Next we need a Staff reaction that will allow us to build a Rest. I will add two of them. Since the eighth note looks a bit like a "7" we will use an E-S gesture to draw an eighth rest and we will use a W-S to draw the quarter rest. How about the other rests? You will get to them by unflagging one of these rests that you can directly enter.

--add reactions to Staff
  addReaction(new Reaction("W-S"){ // add Q Rest
    public int bid(Gesture g){
      int x = g.vs.xL(), y = g.vs.yM();
      if(x < sys.page.margins.left || x > sys.page.margins.right){return UC.noBid;}
      int H = fmt.H, top = yTop()-H,  bot = yBot()+H;
      if(y < top || y > bot){return UC.noBid;}
      return 10;
    }
    public void act(Gesture g){
      Time t = Staff.this.sys.getTime(g.vs.xL());
      new Rest(Staff.this, t);
    }
  });

the eighth rest reaction looks EXACTLY like that except with the "E-S" stroke and the action must not only create a quarter rest but also set the nFlag of it up to 1.

--modify act of the E-S reaction
  (new Rest(Staff.this, t)).nFlag = 1;
    
At this point, you should be able to enter quarter and eighth rest (assuming of course that you have trained these shapes in your shape database).

==Flagging Rests
Now let us add some reactions to the Rest constructor that will allow us to increment and decrement the flags on the rests.

--add reactions to Rest Constructor
  addReaction(new Reaction("E-E"){ // ADD FLAG to rest
    public int bid(Gesture g){
      int y = g.vs.yM(), x1 = g.vs.xL(), x2 = g.vs.xH(), x = Rest.this.time.x;
      if(x1 > x || x2 < x){return UC.noBid;}
      return Math.abs(y - Rest.this.staff.yOfLine(4));
    }
    public void act(Gesture g){Rest.this.incFlag();}
  });

The W-W reaction looks exactly like that one, but the act routine calls decFlag instead of incFlag

You should now be able to upgrade and downgrade your flags.

==Dotting Rests
And finally we should also add to the constructor a reaction to allow you to Dot a rest. We will NOT require the user to put the dots AFTER the rest (we will allow it, of course). The user should be allowed to just dot on the rest.

--add to Rest constructor
  addReaction(new Reaction("DOT"){
    public int bid(Gesture g){
      int xr = Rest.this.time.x, yr = Rest.this.y();
      int x = g.vs.xM(), y = g.vs.yM();
      if(x<xr || x > xr + 40 || y<yr-40 || y>yr+40){return UC.noBid;}
      return Math.abs(x-xr)+Math.abs(y-yr);
    }
    public void act(Gesture g){Rest.this.cycleDot();}
  });

-- add some values to UC
  public static final int AugDotOffset = 27;
  public static final int AugDotSpacing = 7;  

--upgrade Rest show() to display dots
  int off = UC.AugDotOffset, sp = UC.AugDotSpacing;
  for(int i = 0; i<nDot; i++){
    g.fillOval(time.x + off + i*sp, y - 3*H/2, H*2/3, H*2/3);
  }

When I tested the dots I saw that the dots were being drawn in RED. Why is that? Oh yeah, the Glyphs are all drawn with black ink and a little red square box on them. What is that red box for? Looks like debug code that was showing where the hot spot, the xy coord for drawing was in relationship to the glyph. That should have been removed. Who wrote that Glyph code? Perhaps you can clean that up.  
      
That is pretty much what we need from rests. We can create them, flag them up and down, and dot them. If and when we decide that we are not happy with them in the default position we can look into ways to fix that, either by requiring that the user be careful about where they write the E part of their E-S stroke, and using that y as the line value for the rest, or creating "nudge" gestures that will push the rest up or down a line. A third possibility is to have the rest react to notes that are on the same staff at the same time value and nudge themselves away from those notes. This is of course what you would do if you are doing a full computer layout of the music, and we will not be doing any of that that in this course.

Next task is to get stems up and working.

::S Stems
--Day 13
==Stems

From a graphical standpoint stems on heads are very simple, just a vertical line, all you need is 3 numbers, x,y1,y2. However there are a surprising number of rules that you need to follow in order to calculate those 3 numbers. Also, the stem itself influences that layout of the notes that are on that stem, so the layout implications extend beyond the stem itself. There is very little to do but to start describing all those music layout rules and let the code happen as it must.

--First a Minor fix:
==Head Width
Before I start telling you the rules there is a measurement that we need to make. Stems attach either to the left hand side or to the right hand side of a note head. Since those note heads are scaled to a size of H, i.e. they are 2*H vertically, however we need to know how wide those glyphs are. I believe that they are approximately 3*H wide, but to be sure, we should try to put a box around a note head AS IT IS DRAWN BY OUR Glyph class and see if we actually know where the edges are. 

Put this little bit of code at the end of paintComponent int MusicEd to draw a note head and then a bounding box around it. I introduced a variable, H, so that I could draw a BIG note head, larger than I would ever draw on an actual page so that I could find a multiplier that was close enough for me to draw Stems that connect to our heads. I found that 3*H was too big, 24/10 = 2.4 is actually a closer fit for our font. 

--add to the end of paintComponent
  int H = 32;
  Glyph.HEAD_Q.showAt(g, H, 200, PAGE.margins.top + 4*H);
  g.setColor(Color.RED);
  g.drawRect(200, PAGE.margins.top + 3*H, 24*H/10, 2*H);

So we will need this multiplicative factor when ever we want to get something to line up exactly with our note heads. i.e. if we draw a note at x,y - y is the center of the head so the top of the head is at y-H, the left hand side is at x and the right hand side is at x + 24*H/10.

Where should those multiplicative factors go? Sure, we could/should put them in the UC class with all our other constants BUT in some sense, it is our Head class that decided to use the sinfonia font and the Head class is where ANY chunk of code ought to go to ask about the location of the right hand edge. The magic scale value H was defined in our Staff class, and Heads were FORCED to use that value to scale their height so that they fit in the staff lines. Once a head has scaled itself to the proper height, it is the job of the head class to let anyone know where the right hand side is.

We will just live with the fact that the Glyph class draws the characters from the left hand side. This is the traditional way that ALL text characters are drawn, you give an x value that is the starting point and draw from left to right. It is a very natural way to think of characters. It is also the way that all rectangles are drawn, you start with a left hand coordinate and add a width to the right. For the duration of this course we will only be using staffs that all share an H value, so all our staffs are the same size and all our notes are the same size so if we align notes on an x value they will all show up properly vertically aligned. IF we want to vertically align DIFFERENT sized note heads so that their centers align we would need to do some more calculation. We will not worry about that.

What I am trying to do in this discussion is to FIX in your head (and mine!) the grahpical choices that we are making. When I talk about the x and y location of a note, the x value is the LEFT hand side and the y is the location of the CENTER. We will build a helper that will help us calculate the RIGHT hand side.

-- add to Head class
   public int W(){return 24*staff.fmt.H/10;} // Width of a note head, RIGHT = LEFT + W();

==Stem Layout Rules
So let us start enumerating rules that have something to do with stem layout.

--1) There are Up stems and Down stems, and there is a default direction.
Graphically, an Up stem starts on the right side of a note (the "note" end) and goes upwards to the "beam" end of the note. Down stems start on the left side of a note and go downward to the beam end.

IF you are drawing a SINGLE voice on a SINGLE staff, the DEFAULT stem direction is to point toward the center line of the staff - high pitched notes would have down stems and low pitched notes would have up stems, notes ON the center line could go either direction though generally one single direction is selected.

However IF you have TWO voices on a SINGLE staff, for example both the Soprano and the Alto voice in the top staff of a Hymn arrangement, the direction of the stem MAY be used to indicate which voice the note belongs to.

Now NONE of this matters in our music notation system - we are allowing our user, our composer, to draw the stems and they can follow what ever pattern they want.

I am calling this to your attention because I have made a USER INTERFACE choice for you. I decided that instead of having the application automatically draw all the stem lines for you (thus matching standard single voice behavior) I will REQUIRE the user to enter all the stems. That way it is clear to the user that they have complete control over the stem direction - there ARE NO stem directions until they choose them. This choice is NOT the choice that is typically made in most music notation software programs. They are not comfortable with having the music in some partial incomplete state. They know that notes have heads and stems and so they FORCE the existance of a stem, and if it is in the wrong direction, well the user can fix it. WE on the other hand, are DRAWING music. It does not bother us in the least that createing a note, which required both a head and a stem required the user to DRAW a head and then DRAW a stem, but that was a user interface CHOICE. We could have easily done the same thing that standard music notation software does, put a stem with the default direction immediately on the head at the moment that it was drawn, and require the user to change that if it was NOT what they wanted. 

--2) the default length of a stem is one octave

In our system one octave is 7*H. So if a note is on line 0, the down stem should end on line 7. Now this is the default for a stem with ONE single head on it. IF the stem has several heads, what you really want to do is find the note that is Farthest from the "note" end of the stem, i.e. the note that is Closest to the "beam" end of the stem and add 7*H to that notes line. (You add 7 for down Stems you subtract 7 for up Stems).

Basically you want 7*H of blank stem on which to add flags and beams.

--3) the default length only works for stems with 0 to 2 flags

Normally flags (and beams) are 1*H thick, and you leave a 1*H gap between each pair of flags or beams. So that 7*H empty space on the stem gave you enough room to attach 2 flags (which occupy the last 3*H of the beam end). However, if you want 3 flags on the end, you must add 2*H to the length (so that you have room for the 1 extra flag and the 1 extra gap that you need. Each extra flag that you want to add over 2 requires that you ADD 2 more H to the lenght of the stem. So a stem with 2 flags is 7*H from the end of the last head, a stem with 3 flags is 9*H, a stem with 4 flags is 11*H, and so on.

--4) in any case, IF your stem CAN cross the mid line of the staff that it is on THEN it MUST cross or reach the mid line.

Wait, What? If you have a very high pitched note, i.e. one written several ledger lines above the very top line AND that note has a down stem (which is the normal direction to draw the stem) then that line is heading down toward the center line and COULD have crossed the mid line if it was only long enough. Well, then you must stretch that line so that it DOES reach the mid line.

Basically, in single voice music where all stems point toward the mid line, all stems MUST reach the mid line. If you are doing two voice per staff and if you are following the convention that stem directions indicate the voice, the high soprano notes will have upward pointing stems and the low alto notes will have downward pointing stems and those stems are all pointing away from the mid line. In that case you don't do any extra stretching. You just size the lines to their default octave length plus whatever extra they need to accomodate the flags that they have on them.

Those are the basic rules for how the stem itself is drawn. Next, there are rules for how to draw the note heads that land on the stem.

==Rules for Heads on Stems
The note heads on an up stem are generally drawn on the left hand side of that up stem (or equivalently - the stem is drawn to the right of the notes) HOWEVER there is an important exception. IF two notes are on adjacent lines (and here I am talking about our "line coordinates" so adjacent lines means that visually one note is on a staff line and the other note is on a space between that staff line its neighbor) then the notes would actually overlap so one of them is "displaced" to the "wrong" side of the stem. The musical term for notes that are on adjacent lines is "notes that are one second apart" (the word "second" does not refer to TIME it refers to a PITCH difference) - so this layout rule is how to deal with "seconds".

--5) if two notes are one second apart, one of them must be drawn on the wrong side of the stem.

I made it sound as if you are perfectly free to choose which note goes on the wrong side. You are almost free to do so, there is an additional rule though...

--6) that first note on a stem, i.e. the one farthest from the beam, MUST be on the right side of the stem.

So the real rules is draw the "first note" on the right side of the stem, and then moving up the stem try to draw EVERY note on the right side of the stem and ONLY use the wrong side of the stem if you were FORCED to do so because you were only a second away from the previous note.

Since that rule is all about knowing who your neighbors are on the stem, you can probably guess that we will want to keep the notes in sorted order on the list of heads in the Stem class. This means that we will need to make sure that the list gets resorted every time we add or remove heads from a stems head list.

Anyway, that's enough rules for now. There are others, differences brought on by beams and dots and we will deal with those later.

Wow, too much documentation and not enough code, eh. Let's write some code. Stems, just like Rests, should descend from the Duration class

--Outline of Stem class
  public class Stem extends Duration{
    public Staff staff;
    public Head.List heads = new Head.List();
    public boolean isUp = true;
    
    public Stem(Staff staff, boolean up){
      super();
      this.staff = staff;
      isUp = up;
      // reactions will go here
    }
  }

We need lists of heads
--add to Head
  //----------------HEAD LIST---------------------
  public static class List extends ArrayList<Head>{}
  
And of course we need a show routine in Stem to draw our stems. In outline, it looks somewhat like this:
--add to Stem class
  public void show(Graphics g){
    if(nFlag >= -1){
      int x = x(), h = staff.fmt.H, yH = yFirstHead(), yB = yBeamEnd();
      g.drawLine(x,yH,x,yB);
    }
  }
  
We have defered our actual calculations to 3 helper functions, x(), yFirstHead(), and yBeamEnd(). And I will show you those in just a minute BUT I will warn you that I ran into a bug when I wrote show() code like this, and it was not immediately obvious what the problem was. 

==A Strange Bug
I warned you about this bug in an earlier section and said that it almost NEVER happened so we could ignore it, and then, just to prove me wrong, it happened almost immediately! So here is the story, once again and our fix.

I was got an index out of bounds exception. It happened when I evaluated yFirstHead. My problem was that there were no heads on my stem, so the obvious and simple code that attempted to grab that first head was failing. WTF? Why am I ever creating stems with no heads? The only reason at ALL to have a stem is to hold heads. I went groveling over my code (which I have not shown you yet) looking for where I made the mistake of creating a stem with NO heads on it.

I could find no such problem and then I remembered the multi-threading bug, I am running swing on two threads. 

AH HA! 

When I call a Stem constructor, it creates a stem and it does all the bookkeeping of adding it to the layers and all that Mass stuff in the call to super() BEFORE it ever gets to the code that joins that first head to the stem. The paint procedure that is calling show, is however running on a second thread. My window may get asked to repaint itself at ANY time, when the user jiggled the window or something else happended on the screen. Repaint can happen at ANY time, including a tiny slice of time that was AFTER I had inserted a Stem into the Layers but BEFORE I had added heads to that class.

So I modified my guard in my show routine to look like this:
--add guard in Stem.show()
  if(nFlag >= -1 && heads.size()>0) {...}
  
It just LOOKS so wrong. Why am I drawing a stem that is only partially completed and has no heads yet? Won't that mess up the graphics if I draw things that aren't finished? No it won't. 

Yes, the code that ran through the show process may have "shown" the wrong things over in the paint thread, BUT it was probably NOT drawing directly to the screen. It was probably drawing to an in memory bitmap buffer so that it could present the finished image all at once. At the same time, our other thread that is constructing all our objects, will finally finish the actual correct construction of a new stem, or anything else that we are building, and our "construction thread" call "repaint()". That was our signal to the "Painting thread" that whatever it was drawing is now garbage and it must start over. That is what "repaint" means. Repaint is NOT a function that paints the screen, repaint is a function that sets a message for a paint thread which will asynchronously see that message and start its painting process over.

I am passing on this reminder to you of one of the little gotchas that can always happen in multi-threaded applications.

Notice that the guard which we required is NOT difficult. I am just preventing myself from running code in a show routine that could throw an array index out of bounds exception in one of my show routines. 

For this bug I am NOT following my customary course style here when writing this up. My customary style is to write code exactly the way that I write it, and IF there is a bug, I will walk you right into it. I let you see the bug, and then I will explain the bug and tell you how to fix it. The reason I am dievating is that THIS bug is one of those evil intermittant ones - One that runs fine for days, weeks, months, and just occasionally happens when the timing is just right. 

Feel free to leave that second half of the guard out and see if you don't have the same occasional intermittant problems that I had. This sort of bug, one that shows up sometimes maybe only rarely are generally VERY hard to track down because it is very hard to MAKE the bug happen when you want it.

And now that I have warned you about this for a second time, I will not in the future describe in any great detail WHY there is occasionally a strange looking guard in some of my show routines. 

==First and Last Heads
Now let's get back to those helper routines. I have made the assumption that we will sort the heads on a stem in ascending order by line number. This means that for a down stem, the first head is at zero but for an up stem zero will be the lastHead (the one closest to the beam end). We will need to be sure that we sort the heads in that order.

--add to Stem class - Helpers for x, y1, y2
  public Head firstHead(){return heads.get(isUp ? heads.size() - 1 : 0);}
  public Head lastHead(){return  heads.get(isUp ? 0 : heads.size() - 1);}
  public int yFirstHead(){Head h = firstHead(); return h.staff.yOfLine(h.line);}
  
  public int yBeamEnd(){
    Head h = lastHead();
    int line = h.line;
    line += (isUp? -7:7); // default is one octave from last head on the beam
    int flagInc = nFlag > 2 ? 2*(nFlag-2) :0; // if more than 2 flags we adjust stem end..
    line += (isUp? -flagInc : flagInc); // .. but direction of adjustment depends on up or down stem
    if((isUp && line > 4) || (!isUp && line < 4)){line = 4;} // meet center line if we must
    return h.staff.yOfLine(line);
  }
  public int x(){Head h = firstHead(); return h.time.x + (isUp?h.W():0);}
  
==Heads using Stems
Looking just a bit down the road, when we start drawing several heads that all share the same time, and are stacked up waiting for you to draw the S-S stroke that will be the stem for several of those heads, that reaction will be won by a single head. However the result, adding a stem, will apply to many heads all at once. It will be convenient to have a list of heads that we can go through to see which ones were actually affected by that down stroke. This suggests that we will want times to have a member that will hold that list of heads.

--add to Time
  public Head.List heads = new Head.List();
  
When we create heads, they will join a time group and will need to add themsleves to this list. Furthermore, it means that when we finally get around to deleting heads, we will need to remember to remove them from this time list. I don't want to think through head deletion which will also involve removing and disabling reactions and getting off of their stems as well BUT in order to remember the time connection, when we add the code to the constructor, I will also add a delete() function, that will be commented to be a STUB - telling me that it is incomplete BUT it will remind me to remove heads from the time list.

Next we will need to upgrade the Head class so that Heads have a member stem. I have also put in some other members that we will eventually use. One of them is the wrongSide boolean that we will need for displacing heads on the stem. Given that a head will eventually be displaced, we will NOT be able to just use time.x to tell where the head goes, instead we will need a helper function x() that will used time.x AND the wrongSide information to calculate the actual x value for a head. 

I also put in a Glyph variable, forcedGlyph, which will almost always be null, representing the fact for nearly all music the glyph on the end of the stem is NOT forced to be a single special glyph, instead, the normal Glyph will be either a quarter, or a half, or a whole note head and can be determined entirely by the flag count. However if someone sets the forced glyph, then that is the glyph that we will use.

(just for the record, this forced glyph is necessary for an obscure violin specific notation known as a "bowed tremolo". We will not be implementing that in this course, but we can leave a space for that later addition in our design now. It will also allow an obscure notation known as "shaped notes")

--Head Class upgraded
  public static class Head extends Mass{
  public Glyph forcedGlyph = null; // null means use the normal Glyph calculated from the flag count
  public Staff staff;
  public int line; 
  public Stem stem = null; // heads are created with no stem so the user can choose direction..
  public Time time; // .. so heads, in order to have x, have a time.
  public boolean wrongSide = false; // normally a head is NOT on the wrong side
  
  public Head(Staff staff, int x, int y){
    super("NOTE");
    this.staff = staff;
    this.line = staff.lineOfY(y);
    time = staff.sys.getTime(x); // get the time for this head.
    time.heads.add(this);
  }
  
  public void show(Graphics g){
    int H = staff.fmt.H;
    (forcedGlyph != null ? forcedGlyph : normalGlyph()).showAt(g, H, x(), y());
  }
    
  public int y(){return staff.yOfLine(line);}
  public int x(){return time.x;} // STUB
  public Glyph normalGlyph(){return Glyph.HEAD_Q;}  //STUB 
  public void delete(){ time.heads.remove(this);}  //STUB
  
  public int W(){return 24*staff.fmt.H/10;} // Width of a note head, RIGHT = LEFT + W();


==Reactions to put heads on stems
We will use a single S-S stroke for all of our grouping and ungrouping of heads on stems. If you do a S-S stroke just to the right or just to the left of a note head, you want to either group or unGroup that head with a stem.

This will be our first reaction where the action needs to affect several objects, in this case several heads, insted of ONLY the head that won the bid. The fact is all the heads that you sweep past will bid for that stroke and will in fact probably bid the same amount, so it is a little random as to which one actually wins the bid, but that won't matter. The winning head will provide us with a time and the gesture will provide a y1,y2 range. We will go through all those heads at that time and in that range and either ungroup them or group them.

Let us first write the helper functions that do the grouping and ungrouping and then write the reaction that will call those functions. Since these functions need access to all the heads in a single system that occur at a specific time stemHeads() and unStemHeads will be a functions performed by a Time

--add to the Time class
  public void unStemHeads(int y1, int y2){
    for(Head h: heads){
      int y = h.y();
      if(y>y1 && y<y2){h.unStem();}
    }
  }
      
This made use of a function that we have not yet written in the Head class to remove a head from its stem

--add to Head class
    public void unStem(){
      if(stem != null){  // if stem is null, this head is already unStemmed, otherwise...
        stem.heads.remove(this); // ..get out of old stem
        if(stem.heads.size() == 0){stem.deleteStem();} // .. and delete old stem if it becomes empty
        stem = null;
        wrongSide = false;
      }
    }
      
And unStemming a head migh make the stem go empty in which case we need to delete the stem. The is a delete function that all Masses implement to remove them from the layers. That is probably all that we need to do, but on the off chance that there is some other clean up that we might want, I am going to write a "wrapper" for the Mass delete in the Stem class. 

I don't honestly know at this point if I need this wrapper. In the back of my head I am thinking that I might want to delete an entire stem and all the heads that are on it, in which case I will need to go through the head list and clean it out and delete all of them. This next routine is where I would insert that logic IF I ever decide that I want to delete a stem that was NOT already empty. Fpr right now, though, the heads list is empty and I can just delete the stem.     

--add to Stem class
  public void deleteStem(){deleteMass();} // only call if list of heads is empty

Next we need to go the other direction, building the function that puts all the crossed heads onto a single stem.

--add to Time class
  public void stemHeads(Staff staff, boolean up, int y1, int y2){
    Stem s = new Stem(staff, up); // first create the new stem
    for(Head h: heads){
      int y = h.y();
      if(y>y1 && y<y2){h.joinStem(s);}
    }
    if(s.heads.size() == 0){
      System.out.println("WTF? - empty head list after stemming");
    }else{
      s.setWrongSides();
    }
  }
  
The 'joinStem' routine creates the stem and then goes through all the heads on the time list checking if they are at the right values to be joining the new stem. We chain down to a Head function that we haven't written yet that moves the head from whatever stem it was on over to the new stem. After the for loop we need to sort this new list of heads and then go though that list in order to place all the heads either on the right side or the wrong side. Please stub that setWrongSides function in the Stem clas now. We need to call that function here, but the function can just return without either sorting or setting wrongSide until we are ready to deal with the layout of seconds.

--Stub setWrongSides() in Stem  
  public void setWrongSides(){} //STUB

--add to Head class
  public void joinStem(Stem s){
    if(stem != null){unStem();} // make sure that this head is NOT on some other stem..
    s.heads.add(this); // ..before it joins the Stem's heads list
    stem = s; // reference your stem - this head now has a stem.
  }   

With these joinStem and unStem helpers in place, we can finally write a reaction. As I said earlier, many heads (all the ones that you crossed) will want to bid on this stroke. Only one will win. Which one, we don't know. We will treat that one as special. We will use the winner's time, (which is no big deal, because presumably the only heads bidding on this gesture all share the same time), BUT we will also use the winner's state, currently stemmed or currently unstemmed, to decide whether this was a stemHeads or an unStem heads action.

--add reaction to Head
  addReaction(new Reaction("S-S"){ // Stem or unStem heads
    public int bid(Gesture g){
      int x = g.vs.xM(), y1 = g.vs.yL(), y2 = g.vs.yH();
      int W = Head.this.W(), hy = Head.this.y();
      if(y1 > y || y2 < y){return UC.noBid;} // heads not in y range reject this gesture
      int hl = Head.this.time.x, hr = hl + W; // left and right side of Head.
      if(x < hl-W || x > hr+W){return UC.noBid;} // must be reasonably close to the head.
      if(x < (hl+W/2)){return hl-x;}
      if(x > (hr-W/2)){return x-hr;}
      return UC.noBid;
    }
    public void act(Gesture g){
      int x = g.vs.xM(), y1 = g.vs.yL(), y2 = g.vs.yH(); // gesture locations
      Staff staff = Head.this.staff; // Head parameters
      Time t = Head.this.time;
      int W = Head.this.W();
      boolean up = x > (t.x+ W/2); // 
      if(Head.this.stem == null){ // winner of bid gets to choose between stem or unStem action
        t.stemHeads(staff, up, y1,y2); // staff and up needed to create the stem
      }else{
        t.unStemHeads(y1,y2);
      }
    }
  });  
  
You should be able at this point to stem and unstem single heads. We can't yet test stemming multiple heads because the code that we wrote assumed that the note heads were in proper sorted order (something that we also need in order to properly layout seconds) so let us do that now. 

==Sort the heads
We have not done sorting before in this course, but being intermediate java programmers, I know that you already know the basics of sorting, you just need a quick reminder - same as I do every single time that I need to sort something. I sort things so rarely that I must google for "java sort ArrayList" and get the reminder. You usually get a stackOverflow hit and skip all the noise and look for the example.

The basics are that you take the elements that you want to sort, Foo, and make that class implement Comprable<Foo>, which means that the class Foo now has a compareTo(Foo foo) function. That function allows one Foo object took at a second Foo object and return an int that tells the ordering relationship between those two Foo objects. The existance of that function is what allows Collections.sort(arrayList<Foo>) into the proper order.

--add to the Head class
  public static class Head extends Mass implements Comparable<Head>{
  ...
  public int compareTo(Head h){ // this is the code required for Comparable that makes the sort work.
    return (staff.iStaff != h.staff.iStaff) ? staff.iStaff - h.staff.iStaff : line - h.line;
  }  

I decided that I would allow cross staff stemming in the compare routine - this means that I compare notes by line if they are in the same staff When they are NOT in the same staff I compare them by staff.iStaff. The mere fact that I do that in the compare routine does NOT mean that I have made the decision to allow the user to actaully use a single stem for notes in different staffs. I am not sure that my show code would do the proper thing, but my sort routine can at least do the right thing. 

By the way, you almost always implement these compareTo functions by subtracting one number from another. Subtraction gives you the essential Three-Way_Split that all compare functions are looking for, negative, zero, positive corresponding to less than, equal, greater than. I NEVER remember which one you subtract from the other, and I make NO effort to learn. This is NOT because I am untrainable. I COULD learn but IMHO that would be WRONG! IF I learned the proper way to subtract the numbers, I might make the foolish mistake of NOT TESTING whether my sorting was going the right direction, because I THINK that my code was designed correctly. Far better to remain ignorant, to KNOW that I am ignorant, and therfor MUST, at the earliest opportunity, test the sorting and flip the order of negation if I did it wrong. So I don't even look at the order that they do things on the stackOverfow example, I subtract and if the list was ascending rather than descending then I flip the order of the subtraction. 
  
Anyway, after your Heads know how to compare themselves, the other half of sorting is to call Collections.sort(heads) which will be first line of our setWrongSides() routine
  
  Collections.sort(heads);

Do test several things when you get to this point. See whether the threshold distance that I selected, namely one head's width, W, was close enough for the interaction. Do create some heads on different staff lines and see if you can get some cross staff stemming happening. Do check that you can add two notes to a stem, and then unstem only one of them (which should leave the other still stemmed). I believe that the ORDER in which two heads were entered determines which one wins the bid if the two bids are equal. If I remember the code correctly you have to BEAT a previous winner in order to steal the bid from them. SO you should be able to TEST which head actually wins the bid by having two notes, one stemmed and one not and doing a S-S stroke past both of them.

==Layout of Seconds

Once we have tested the stemming and unstemming we are ready to flesh out setWrongSides() whose job was to first sort all the heads on the stem and then go through them in order and make sure that every head know which side it is on. We will write that function first and then make sure that our heads actually do start respecting that wrongSide boolean when they draw themselves.

--add to Stem class
  public void setWrongSides(){ // called by Time.stemHeads
    Collections.sort(heads);
    int i, last, next;
    if(isUp){i = heads.size()-1; last = 0; next = -1;} else{i = 0; last = heads.size()-1; next = 1;}
    //ph = Previous Head, nh = Next Head
    Head ph = heads.get(i); ph.wrongSide = false; // first head is always right 
    while(i != last){
      i += next;
      Head nh = heads.get(i);
      nh.wrongSide = (Math.abs(nh.line - ph.line)<=1 && !ph.wrongSide);
      ph = nh;
    }
  }
  
In the above routine I need to traverse those head lists in two different directions, largest to smallest for up stems and from smallest to largest for down stems. So I created 3 variables, !ii - which is the current index, !ilast - which is the last legal index, and !inext - which is the step size that I add to !ii each time through the loop. I then keep track of the previous Head, !iph, which I use in the loop to compare to the next Head, !inh, which came from !ii, when I want to see if !inh and !iph are only one line apart.

In order to test my sorting and my wrong side code, I modified Glyph.showAt so that it no longer set the color to black, which allows me to color heads in different colors. Then I added a color selector when I draw my heads.

--temporarily add to Head show()
  g.setColor(wrongSide?Color.GREEN:Color.BLUE);
  if(stem != null && stem.heads.size() != 0 && this == stem.firstHead()){g.setColor(Color.RED);}
  
And once you have tested sorting fix glyph and head.

Are we ready to draw seconds yet? Not quite, we had a few stubs in the Head class that we need to now write
  public int x(){return time.x;} //STUB
  public Glyph normalGlyph(){return Glyph.HEAD_Q;} //STUB
  
--add to Head class  
  public int x(){
    int res = time.x;
    if(wrongSide){res += (stem!= null && stem.isUp) ? W() : -W();}
    return res;
  }
  
  public Glyph normalGlyph(){
    if(stem == null){return Glyph.HEAD_Q;}
    if(stem.nFlag == -1){return Glyph.HEAD_HALF;}
    if(stem.nFlag == -2){return Glyph.HEAD_W;}
    return Glyph.HEAD_Q;
  }
  
What was that? Your Glyph class didn't define HEAD_W? So whose problem is that? I'll give you a hint, the whole head is just in front of the half head.

At this point you should be able to stem and unstem notes and you should have the proper layout of seconds working as well. 

==Addendum
One of the students discovered a bug (thanks!) in the second layout code caused by cross staff stemming.

If you create a system with two staffs, and you put a note on a line in one staff, and a note on the neighboring space ON THE OTHER STAFF, the second layout code as written (in the setWrongSides() routine in Stem) THINKS that the two notes are right next to each other and decides that they are seconds. We needed a better boolean function to extablish wrong side:
--replace line in Stem setWrongSides()
  nh.wrongSide = ((ph.staff == nh.staff) && Math.abs(nh.line - ph.line) <= 1 && !ph.wrongSide);

and that fixes the second layout bug in cross staff stemming.
    
::S Dots 
--Day 14 
==Dots on Heads
In some ways this section of the book on "head dots" is a stub. We certainly DO want to put dots on heads BUT we don't want to take the time right now to do the right thing. The right thing unfortunately can't be done correctly until we have delt with beams and flags. Flags on upStem notes happen to hang right in the way of where you would normally place dots. Also, placing dots on heads is harder than placing dots on rests. The reason is that rests are always drawn on lines, whereas heads are drawn on either lines or spaces.

The actual rules for placing dots on heads are that you put the dots in the center of the nearest space to the head. So heads that are actually on spaces have the dots immediately after them, whereas heads on lines have the dots either slightly above or slightly below the line that the head is on. When you have notes that are only a second apart, on an adjacent line and space, you need to choose the proper space for the dot that goes with the head on the line so that it doesn't collide with the dot on the head that was on the space. Once again you will have to look at neighbors to decide the correct space to add the dots.

As I said, I don't want to write the code now, just telling you the rules so that you can let them soak in.

However, we can and will STUB the dot code fairly easily. We do have code that draws dots in the Rest show routine that we can copy and paste into the Head show routine. Indeed, it does not follow the rules and the dots do not show in quite the right place BUT, hey, it does show dots and reminds us that of some of the code that we will need to fix up later. And we CAN write the proper reaction to dot our heads now before we ever get to beams and flags.

--add to Head show routine
  if(stem != null){
    int off = UC.AugDotOffset, sp = UC.AugDotSpacing;
    for(int i = 0; i < stem.nDot; i++) {
      g.fillOval(time.x + off + i*sp, y() - 3*H/2, H*2/3, H*2/3);
    }
  }
  
--add reaction to Head
  addReaction(new Reaction("DOT"){
    public int bid(Gesture g){
      int xh = x(), yh = y(), h = staff.fmt.H, w = W();
      int x = g.vs.xM(), y = g.vs.yM();
      if(x<xh || x > xh + 2*w || y<yh-h || y>yh+h){return UC.noBid;}
      return Math.abs(xh+w-x)+Math.abs(yh-y);
    }
    public void act(Gesture g){if(Head.this.stem != null){Head.this.stem.cycleDot();}}
  });

Joe Bob says, "Check it out!"

::S Flags
==Flags
We are already adjusting the length of the stems to make room for adding flags onto the end of a stem, so in order to get flags working all we need to do is add some reactions to the Stem class and modify the show routine in Stem to draw out the glyphs used for flags.

We have functions that return us yFirstHead and yBeamEnd in Stem. Which one of those two y values is lowest depends on the direction of the stem. We will add a couple helpers to the stem class.
--add to Stem class
  public int yLo(){return isUp ? yBeamEnd() : yFirstHead();}
  public int yHi(){return isUp ? yFirstHead() : yBeamEnd();}

We can use those helpers when we write the reactions to add flags to stems.
--add reactions to the Stem class
  addReaction(new Reaction("E-E"){ // inc FLAG on stem
    public int bid(Gesture g){
      int y = g.vs.yM(), x1 = g.vs.xL(), x2 = g.vs.xH();
      int xS = Stem.this.heads.get(0).time.x;
      if(x1 > xS || x2 < xS){return UC.noBid;}
      int y1 = Stem.this.yLo(), y2 = Stem.this.yHi();
      if(y < y1 || y > y2){return UC.noBid;}
      return Math.abs(y - (y1+y2)/2);
    }
    public void act(Gesture g){
     Stem.this.incFlag();  
    }
  });
  
  addReaction(new Reaction("W-W"){ // DEC FLAG on stem
    public int bid(Gesture g){
      int y = g.vs.yM(), x1 = g.vs.xL(), x2 = g.vs.xH();
      int xS = Stem.this.heads.get(0).time.x;
      if(x1 > xS || x2 < xS){return UC.noBid;}
      int y1 = Stem.this.yLo(), y2 = Stem.this.yHi();
      if(y < y1 || y > y2){return UC.noBid;}
      return Math.abs(y - (y1+y2)/2);
    }
    public void act(Gesture g){
      Stem.this.decFlag();
    }
  });
  
Does it bother you that the bid code is the same for these two functions. It should (well, maybe just a little) How would you fix that?. Extract the bid to a helper.

--Same reaction code refactored
  public static int bidLineCrossesStem(int y, int x1, int x2, Stem stem){
      int xS = Stem.this.heads.get(0).time.x;
      if(x1 > xS || x2 < xS){return UC.noBid;}
      int y1 = Stem.this.yLo(), y2 = Stem.this.yHi();
      if(y < y1 || y > y2){return UC.noBid;}
      return Math.abs(y - (y1+y2)/2);
  }
  
--Reaction code now looks like
  addReaction(new Reaction("E-E"){ // ADD FLAG to stem
    public int bid(Gesture g){
      return bidLineCrossesStem(g.vs.yMid(), g.vs.xLo(), g.vs.xHi(), Stem.this);
    }
    public void act(Gesture g){
     Stem.this.incFlag();  
    }
  });
  
  addReaction(new Reaction("W-W"){ // DEC FLAG to rest
    public int bid(Gesture g){
      return bidLineCrossesStem(g.vs.yMid(), g.vs.xLo(), g.vs.xHi(), Stem.this);
    }
    public void act(Gesture g){
      Stem.this.decFlag();
    }
  });

Is that refactored code actually better? Not a whole lot. It means that later IF we find ourselves needing to change the bid (because of competition with some other bid code) we will only need to make the change in one place. On the other hand, it means that when we are scrolling our way through the reactions looking at what we are doing, we are now forced to look somewhere else if we want the details. I have not made any effort so far to do this sort of refactoring on reaction code, and I will make no particular effort in the future. I just felt that it would be useful to point out that it is another directions in which you can further explore code reduction/refactoring.  
      
--add code to the Stem show routine    
  if(nFlag > 0){
    if(nFlag == 1){(isUp? Glyph.FLAG1D: Glyph.FLAG1U).showAt(g,h,x,yB);}
    if(nFlag == 2){(isUp? Glyph.FLAG2D: Glyph.FLAG2U).showAt(g,h,x,yB);}
    if(nFlag == 3){(isUp? Glyph.FLAG3D: Glyph.FLAG3U).showAt(g,h,x,yB);}
    if(nFlag == 4){(isUp? Glyph.FLAG4D: Glyph.FLAG4U).showAt(g,h,x,yB);}
  }

Note the names of the flags - an up stem has a flag that hangs down. 

In testing, I observed that if you have multiple dots on and up stem with a flag, the flag collides with the second dot. So I changed UC.AugDotOffset to 28 and UC.AugDotSpacing to 11 to stop that.
--change in UC
  public static final int AugDotOffset = 28;
  public static final int AugDotSpacing = 11;

::S Beams
==Beams
Beams are used to both indicate the number of flags that are on a stem as well as grouping several stems together which is visually a way of consolidating sub-divisions of time back into whole blocks to make the counting for the musician easier.

The way that they are traditionally drawn with ink on paper very much guides and informs the way that we will produce them in our application. 

A beamed group of four 16th notes adds up to a quarter, which is typically a single beat in a four four measure, (four four means four sets of quarter notes). The way that you would draw that is this. First you draw the 4 notes on their appropriate pitches one after the other, all without stems. Then you draw the stems on the first note and on the last note of the beamed group. You pretty much follow the conventional stem length rules, making them an octave long but leaving extra space if there are lots of flags on the group. 

Now that you know the two y values for beam ends, you can draw the first beam from the first note to the last note. With that beam in place, you join the two inner notes to that first beam, ignoring stem length rules.
Finally you draw in any of the other beams that make up this group.

We will build our reactions to follow that same plan. We already have in place many of the reactions. We can draw the heads. We can put stems on the first and the last notes. And now we need something new.

We need a reaction that crosses both of those stems. We will want to use an E-E reaction because drawing a beem between two stems really is the same as adding flags to both stems.

However, a simple E-E stroke like this would confilct with the E-E that we already have to add a flag to a single stem. How do you distinguish between beaming two stems and just flagging a single stem.

The answer has got to be context. We will need a routine that notices that a "beaming" gesture is crossing exactly two currently unbeamed stems, and when that happens, it wants to return a really low winning bid, lower than an E-E stroke that crossed only a single stem or that crossed several already beamed stems.

The fact is, an E-E stroke that crosses more than 2 beams is just what we need to add the second beam to that group of 4 sixteenth notes. So we will really want a routine that can take a single E-E gesture and return to me the complete list of all stems that were crossed by that single stroke. My reactions can then use that routine to get a list of stems to work with and the logic of detecting whether it was exactly two, or more or less becomes easy.

==Stem.List
Since we will need to iterate though a bunch of stems it means that somewhere we need to keep track of all the stems that are currently on screen. This is not too hard to do. Stems are essentially linked to Sys objects so it makes sense to keep an array list of all the stems "owned" by a Sys. As soon as we keep some other list like that, it means that we need to be careful when we delete a stem. We must remember to delete it not only from the layers but also from this list of stems.

It sure is sounding like we will need a Stem.List class that will keep this list of stems and allow us to iterate through it.

--add a new nested class to Stem
  //------------------------List-------------------------
  public static class List extends ArrayList<Stem>{
    public int yMin = 1000000, yMax = -1000000;
    public void addStem(Stem s){
      add(s);
      if(s.yLo()<yMin){yMin = s.yLo();}
      if(s.yHi()>yMax){yMax = s.yHi();}
    }    
  }
  
--add a List of Stems to the Sys class
  public Stem.List stems = new Stem.List();
  
--I want to add to stem constructor (but don't!)
  staff.sys.stems.addStem(this); // stems join the list of all stems in the Sys
  
Well, sadly, the above line is a BUG! as you would discover later if you put that code into the constructor. The reason is that is while you are constructing the stem there are No heads on it yet. And when you try to add it to the sys Stem.List, it tries to figure out the stem length by looking at the first head. CRASH! So, we DO need to make sure that every stem gets added to the Sys List, but we need to do it AFTER we have added all the heads. Fortunately we only add heads to a stem in one place. In the Time class we had a routine, stemHeads. Insert a line into that function at the end after the heads have been added.

-- add to stemHeads in Time
  s.staff.sys.stems.addStem(s);
  
--make sure that Stem function deleteStem() removes from stems
  public void deleteStem(){
    staff.sys.stems.remove(this);
    deleteMass();
  } 

There are two almost magic numbers up there in the List class that I threw in as a convenience, actually as an accelerator. Looking through a list of stems, comparing every single one to see if it crosses a single E-E gesture could be slow. What I am going to do to speed up that comparison is to create a FAST REJECT calculation. I simply keep track of the maximum and the minimum y values for the entire list of stems. If my E-E stroke is entirely out of range of those max and min values than I don't need to look at a single stem in the list. I KNOW that it won't cross any of them. 

The fact is, all the stems in one system will all essentially be drawn close to that system. All the stems in the next system will all be further down the page in another broad strip of y values. When I am looking for ALL the stems that cross a single gesture will be of benefit to quickly reject entire systems from consideration. Most likely we will only every go though one single sys's list of stems.

You will notice that I set the initial value of the min to a very HIGH value, a million, and the max to a very LOW value, negative one million. This is a very standard trick. It means that those numbers start out very wrong, but as soon as you enter that first real stem, the min value decreases from a rediculous high number to the actual min, and likewise, the max value moves up the the actual max value. Each successive stem addition always (potentially) DECREASES the min and INCREASES the max.

I trust that you will also notice that even though addStem updates these "fast reject" numbers,  I make NO EFFORT at all to recalculate those bounds when I remove a stem. I don't care if the bounds are TIGHT bounds. They are only there for a fast rejection of an entire system. I expect those bounds will quickly end up as the actualy y values that bound a system (possibly a little wider since stems CAN project up above the very top line of a staff or below the bottom line of the lowest staff in a system.) But I never expect those reject values to go much beyond those values.

--add fastReject to Stem.List
  public boolean fastReject(int y){return y>yMax || y<yMin;}

I could start writing the code to see when an E-E stroke crosses a stem BUT looking ahead, I will warn you that beamed groups can slant upwards and can slant downwards. The slope on that master beam MIGHT be big enough that you won't get a single horizontal line to cross the first stem and the last stem. As a result it will be safest if we can actually have 3 different reaction, E-E, NE-NE, SE-SE all trigering that same search for staff crossings. All this means is that instead of determining if a stem crosses a single y value, we must determine if a single stem crosses a slanted line.

This is by no means a hard calculation, you can just do it, BUT again looking just a bit ahead, one of the routines that we will need when we calculate the proper place to locate the BeamEnd for one of the interior stems it will need to land exactly on the sloped line which is the master beam.

This suggests that it would be beneficial to create one single routine that looks as a line segment (x1,y1,x2,y2) and when I supply it with an x value it can tell me the y value that is on that line segment. In other words, the line segment defines a linear function and we can then evaluate that function for any x.

We will be able to use that function in 3 places. 1) locating the beam end of an interior stem, 2) detecting if a stem crosses a sloped line which was a gesture, 3) drawing the beams themselves whenever they do NOT span the entire lenght from first stem to last stem.

Just talking about it make me want to write that function right now, BUT FIRST, where do we write it? Does this belong in the Stem.List class, the Stem class, or the Beam class (which we haven't even started to write yet). It is just a static math function that requires neither Stems nor Beams in order to work.

Remember - the PROPER place to locate any function is in the place that you will MOST LIKELY LOOK FIRST when you are looking for that function. By all means, most of the time a function adjusts or manipulates one primary object and thus properly belong in the class for that type of object. But here we have what is essentially a math function and it is used to deal with sloped Gestures and Stem crossings and Beam drawing.

In my head, Beams are the little fat line segments drawn between two stems. And we didn't need this function until we were trying to locate that master beam, and trying to draw beams so that is where I will put it, and I guess that means that we need a Beam class.

==Beam Class 

So what is a Beam object?

In the past, thinking as a musician, I thought of a beam as the actual polygon of black ink that you draw on the screen, but I got over that notion quickly. Yes, you draw several such stacked polygons on the screen to display a beamed group but when you get right down to it, the Beam object is actually a drawing machine that draws a pile of polygons on a list of stems. There are two special stems, the first and the last, but basically it is a list of all the stem that attach to the beam. The Beam object gets to look at all those stems (which have flag counts) and draw a pile of polygons that reflect those flag counts. 

--create Beam class
  package music; import graphics.*; import reaction.*;
  public class Beam extends Mass{ 
    public Stem.List stems = new Stem.List();
    
    public Beam(Stem f, Stem l){super("NOTE"); addStem(f); addStem(l);}
    
    public Stem first(){return stems.get(0);}
    public Stem last(){return stems.get(stems.size()-1);}
    
    public void deleteBeam(){
      for(Stem s : stems){s.beam = null;} // remove stem associations with beam.
      deleteMass(); // remove beam from layers
    }
    
    public void addStem(Stem s){
      if(s.beam == null){
        stems.add(s); // stem joins list in beam 
        s.beam = this; // stem now refers to this beam
        s.nFlag = 1; // if beamed stem has at least one flag
        stems.sort(); // stems should be sorted by increasing x value
      }
    }
  }

I will need to add a beam member to the Stem class.
  
I am also going to want all those stems that belong to a single beam to be sorted in order by their x values so that I can go through them in order as I draw polygons SO we need to go make Stems into an orderable class by having them implement Comparable<Stem>.

So we need to both add a beam member and a compareTo function to the Stem class. 

--add to Stem class
  public static class Stem extends Duration implements Comparable<Stem>{
    public Beam beam = null;  // default for stem is no Beam
    ...
    public int compareTo(Stem s){return  x() - s.x();}  

--add to Stem.List class
  public void sort(){Collections.sort(this);}
   
While it is true that a Stem.List can sort itself, this does not happen automatically. The big lists of stems, are those stem lists kept in systems which we don't bother to sort. We only sort the stems which belong to a beam.

Now that we have a Beam class, we can write that math function that we will need. It is static because it does not actually use a beam.

--add to Beam class
  public static int yOfX(int x, int x1, int y1, int x2, int y2){
    int dy = y2-y1, dx = x2-x1;
    return (x-x1)*dy/dx + y1;
  }

Is the math right? Should we test? Of course, BUT we can check that the math is right by the magic of linear functions. If the formula is linear and if it works for two points then it IS the correct linear function. Test it for x = x1. In that case the first term goes to zero and the result is just y1 and YES that is the correct value for x1. Test is for x = x2. Then the term (x-x1) becomes the same as dx and cancels with the denominator leaving only dy which is y2-y1 and that -y1 cancles with the +y1 so x2 yields y2 wich is correct.

I know in advance that I am going to get very tired of passing four arguments over and over to that routine, so I am going to go a step further and create a buffered version - KNOWING WELL IN ADVANCE THAT THIS IS DANGEROUS! It is dangerous because if you set values in a buffer and then call a routine that uses those values how do you KNOW that someone else did not overwrite those buffer values? Functional programmers are so afraid of ever making this particular mistake they NEVER buffer anything. Real programmer just buffer with care and caution.  

--add to Beam class
  public static int mx1,my1,mx2,my2; // coordinates for the Master Beam 
  public static int yOfX(int x){int dy = my2-my1, dx = mx2-mx1; return (x-mx1)*dy/dx + my1;}
  public static void setMasterBeam(int x1, int y1, int x2, int y2){mx1=x1; my1=y1; mx2=x2; my2=y2;}
  public void setMasterBeam(){mx1=first().x(); my1=first().yBeamEnd(); mx2=last().x(); my2=last().yBeamEnd();}

All this does is give me 4 static ints in Beam that will hold my x1,y1,x2,y2 line segment and use those for my yOfX claculations, and I also wrote two routines to set those values.

This helper is enough to let me fix the function yBeamEnd in the stem class so that it works for internal stems.
--add to front of yBeamEnd()
  if(isInternalStem()){beam.setMasterBeam(); return Beam.yOfX(x());}

And write the helper that tests if a stem is both on a beam and is neither the first nor the last Stem.
--add to Stem 
  public boolean isInternalStem(){
    if(beam == null){return false;} 
    if(this == beam.first() || this == beam.last()){return false;}
    return true;
  }


--Day 15
The next chunk of work is the couple of steps that we need to take on the way to painting beams. We will be building Polygons and then BeamStacks on our way to creating an actual Beamed Group. Here is a picture to have in your mind as we develop the code.
<img src="Cphoto/BeamStack.png" />

==Polygons
We will eventually need to draw polygons in order to actually draw a beam, so let us do a quick exploration to see if they will works the way that we want. We look up java polygons and find a constructor. We find that we can initialize it with an arry of x points and an array of y points. Seems easy enough. Let's try it out using the paintComponent routine

--add some static variables to MusicEd
  static int[] xPoly = {100, 200, 200, 100};
  static int[] yPoly = {50, 70, 80, 60};
  static Polygon poly = new Polygon(xPoly, yPoly, 4);

--add to paintComponent
  g.fillPolygon(poly);

Sho nuff, it draws a polygon. We wonder if we can change the components, i.e. we passed in an array of x and y coordinates and are wondering if it used those as a buffer or if it did something silly like make a safe copy of the original values so that we could not change our polygon later. Let's just change one of the values in paint component and the jiggle the window size to force a lot of changes

--add to paintComponent
  yPoly[3]++;
  
We shake it around and nothing changes. Well that's a bad sign. Let's print out that value and verify that it is changing enough that we ought to see something.

--add to paintComponent
  System.out.println(yPoly[3]);

We shake the window around and yPoly is quickly hundreds of pixels bigger than it was and the shape is not changing. Humm... looks like they did make a safe copy. I wanted to use it like a buffer. Ah - wait - the memebers of polygon are public. I should be changing poly.ypoints[3].

  poly.ypoints[3]++;

Yes, that works.

So now we know how to draw polygons. What I did NOT want to do was write code that thrashes our garbage collector. Every single beam polygon that we draw to the screen is a little parallelogram with exactly 4 points. I would much rather statically allocate a single beam polygon, and just change its values when every I want to redraw one, rather than call new and create a new polygons every time I call a show routine.

-- add to Beam
  public static Polygon poly;
  static {int[] foo = {0,0,0,0}; poly = new Polygon(foo,foo,4);} // construct poly as 4 point buffer
  public static void setPoly(int x1, int y1, int x2, int y2, int h){
    int[] a = poly.xpoints; a[0] = x1; a[1] = x2; a[2] = x2; a[3] = x1;
    a = poly.ypoints; a[0] = y1; a[1] = y2; a[2] = y2 + h; a[3] = y1 + h;      
  }
  
And now I can test that in paintComponent

    Beam.setPoly(100, 100+G.rnd(100), 200, 100+G.rnd(100), 8);
    g.fillPolygon(Beam.poly);

==Beam Stack
I want you to take a look at some notation that is NOT technically beams. It is a different music noation element, one that is used for bowed tremolos. (I mentioned this earlier when we put a forcedGlyph element into the Head class). Just google for "bowed tremolo" and you should see a wikipedia article on "tremolo", it has several visual examples of music notation.

You will notice that they have these things that look like beams but are drawn across single note stems. They have others examples that are drawn between stems but without touching either stem. They also have examples of just regular beams on that page. The thing to observe is that ALL these examples consist of a stack of polygons, each 1H tall, with a 1H gap in between them. They all line up with a master beam. Many examples have nothing but consistent x1,x2 values for the entire stack, but some have indents, i.e. the first beam (on line 0) spans all the way from the first stem to the next stem because it is a genuine beam but the successive beams (from line 1 to line 2 or 3) have indents on the x values so that they DON'T touch the stems.

We will find it convenient to build a single helper, drawBeamStack that can draw a single stack of polygons that all share common x1,x2 values and a set of lines to draw - however they don't necessarily start on the master beam which is line zero, they run from a range of y values. In the picture that I showed earlier there were just 3 black polygons running from 2 up to but not including 5.
--add to Beam a static helper function
  public static void drawBeamStack(Graphics g, int n1, int n2, int x1, int x2, int h){
    int y1 = yOfX(x1), y2 = yOfX(x2);
    for(int i = n1; i<n2; i++){
      setPoly(x1, y1+i*2*h, x2, y2+i*2*h, h);
      g.fillPolygon(poly);
    }
  }
  
We can test that function in the paintComponent code by hacking up the code that we used to test the polygon drawing.

--add to paintComponent
  int H = 8, x1 = 100, x2 = 200;
  Beam.setMasterBeam(x1, 100+G.rnd(100), x2, 100+G.rnd(100));
  g.drawLine(0,Beam.my1,x1,Beam.my1);
  Beam.drawBeamStack(g,0,1,x1, x2, H);
  g.setColor(Color.ORANGE);
  Beam.drawBeamStack(g,1,3,x1+10, x2-10, H);
   
This code draws one stack from 0 to 1 (meaning one beam in black and the index 0 means starting right on the masterBeam - I drew a line in from the left to show that coordinate) And a second orange stack running from 1 to 3 (meaning 2 more beam) and I indented those beam.

This replicates the sort of thing that you saw on the tremolo page. Furthermore, you should change H from 8 to -8 to see that the code inverts properly so that you can draw for both up and down stems.   
    
==Show Beams
With that drawBeamStack helper we are pretty close to being about to write the beam showing code. The beams are a list of stems in sorted order, and if they are correctly constructed they will have at least 2 stems. I said at the start that you mostly used the standard stem height code to figure out the beam ends of the first and the last stem. There are a couple of exceptions to this but I am not inclined to implement them at this time. I do however want to mention these other layout issues.

1) It would be BAD if the internal stems were so short that the heads on them crashed into the beams. You are supposed to leave at least 2*H space between any head and the beamed group. From a code standpoint this would mean that when you calculate the beam end for an internal stem you would NOTICE that the last head was too close to the beam end and you would shove the beams farther away. Not terribly hard but just a complication that I don't want to deal with.

2) "If the majority of the notes in a beamed group are on the same pitch then a horizontal beam MAY be used"

3) "If there's an extreme conflict in the direction of pitch change within a beamed note group then a horizontal beam MAY be used"

The quotes are paraphrased from Mark McGrain - "Music Notation". The emphaisis on the word "MAY" is mine. These are optional rules. What one is trying to do with beams is twofold, to help the musician see the individual notes (which break time into small detail) grouped back together as a single beat, but also to see the pitch contours. If a group of notes is ascending you want the beam to ascend. These optional rules are there to avoid conveying a shape that is not correct - to provide a neutral slope when either the notes are either all mostly on the same pitch OR if they are bouncing all over the place without a uniform contour.

So yes, we can skip those two rules because they are optional, but we do so at our peril - our code is making the choice of beam slope, NOT the musician. We have robbed our users of that choice. 

If we skip all those corrections to the beam angle we can proceed with our original outline - We allow the first and last stem to calculate their yBeamEnd just as before. And note, we DO need to change that Stem code slightly. A stem with a beam must now know whether it is an internal stem in its beam or if it is extremal one in order to compute the beam end. 

When you get right down to it, a stem with a beam actually should ask the beam where its end should be. That will allow beams to adjust their height as necessary and report that back to the stem. Once we know those two end points, x1,y1,x2,y2 we have the line segment (what I have been calling the Master Beam) that we can use to calculate both internal stem y values and all the beam y values.

However, before we can draw beams you need to know the notion of beamlets - small partial beams that instead of attaching from stem to stem, only attach to one stem. The name "beamlet" is not the standard name. The standard names (according to Gardner Reed) are to call full beams, "primary beams", and to call beamlets, "secondary beams". Well, my name is shorter and IMHO better. :)

Basically the rules for beams is that every stem MUST have enough beams or beamlets attached to it to make up the flag count for that stem. So if you had 3 stems with flag counts of 4,4,2 you would need 4 beams between the first two stems and 2 between the last two, no beamlets were needed. On the other hand, if you had 3,4,2 you need 3 between the first pair of stems (and you can have no more because the first stem only allows 3, and you need 2 between the second pair of stems because the last one can only have two and that means that you need a beamlet on that middle stem to bring it up to 4. You will need beamlets on any stem whose flag count exceeds the flag count of both of its neighbors. The number of full beams between one stem and the next will be the smaller of the two flag counts. 

Note also that a beamlet lies to one side or the other of a stem. It must lie to the right of the first stem, and it must lie to the left of the last stem (this is so the beamlet lies under the master beam - not sticking out to one side or the other). On intermal stems, if one side of the stems has more full beams than the other, then the beamlet must lie on the side that has more full beams. (For example on our 3,4,2 beam the beamlet on the middle stem must lie to the left - this makes the beamlet which is at slot 4 continue on from slot 3 rather than having an unsightly gap between slot 2 and 4 on the other side. If the two sides have an equal number of beams then the beamlet could lean either way, but technically should lean in the direction that suggests the meter. That criteria is sufficiently vague and is beyond the scope of what we will do in this course.

Because we need to look at 3 numbers, I use nPrev, nCur, and nNext to keep the flag count on the previous stem, the flag count on the current stem and the flag count on the next stem. Because we are drawing beam stacks that lie between the stems, there is one less stack than the number of stems in the beam, so I have elected to run my loop from cur = 1 to stems.size(), so the first stem in the loop is stem 1 and when I draw the stack associated with the cur, I am actually drawing the stack that spaned from previous to cur.

Although the beamStacks lie between the stems, the beamlets actually lie on the stems themselves, so although the loop runs one less than the number of stems, the beamlets must be processed for each stem SO, prior to the start of the loop is where I deal with the beamlets on stem 0, then when I am in the loop I deal with beamlets on the current stem.

If you look back at the picture that I drew, I showed in GREEN that particular BeamStacks that I would be drawing for the current stem, namely the full beams between the current stem and the previous stem, and the beamlet (which could lean either way) on the current stem.

So with that picture firmly in mind, we write the code to show a beamed group.

--Add to Beam class - show routine calls one massive helper
  public void show(Graphics g){ g.setColor(Color.BLACK); drawBeamGroup(g); }
  
  private void drawBeamGroup(Graphics g){
    setMasterBeam(); // defines master beam coords: mx1, my1, mx2, my2
    Stem firstStem = first();
    int H = firstStem.staff.fmt.H; int sH = firstStem.isUp ? H : -H; // signed H needed for beamStack
    int nPrev = 0, nCur = firstStem.nFlag, nNext = stems.get(1).nFlag; // flag count for 3 stems
    int px; int cx = firstStem.x(); // x location of previous stem and current stem
    int bx = cx + 3*H; // forward leanding beamlet on first stem runs from cx to bx
    if(nCur > nNext){drawBeamStack(g, nNext, nCur, cx, bx, sH);} // beamlets on first stem point right
    for(int cur = 1; cur <stems.size(); cur++){
      Stem sCur = stems.get(cur); px = cx; cx = sCur.x();
      nPrev = nCur; nCur = nNext; nNext = (cur <(stems.size()-1))? stems.get(cur +1).nFlag : 0;
      int nBack = Math.min(nPrev, nCur);
      drawBeamStack(g, 0, nBack, px, cx, sH); // draw beams back to previous stem.
      if(nCur > nPrev && nCur > nNext){ // we have beamlets on this stem.
        if(nPrev < nNext){  // beamlets lean toward side with more beams.
          bx = cx +3*H;
          drawBeamStack(g, nNext, nCur, cx, bx, sH);
        }else{
          bx = cx -3*H;
          drawBeamStack(g, nPrev, nCur, bx, cx, sH);
        }
      }
    }
  }
  
==Some Refactoring
Next thing to do is to create the reactions that will A) create a beamed group in the first place - this will be an E-E (or an NE-NE or a SE-SE) that crosses exactly two stems that are currently without beams. They will become the first and last beam of the group B) a S-S reaction that stems heads just like our previous reaction for creating heads, BUT that will notice that the S-S gesture also happened to cross a master beam, in which case the newly created stem will also be a part of that beam, and C) E-E and W-W gestures that will flag and unflag multiple stems in a single beamed group. (Note: this last one is an accelerator - we could have just required the user to flag each stem in the group independently which is what we currently have implemented and which should work just fine as is.

However when I look at that stemHeads code that lives over in the Time class. I find that I don't like it. Mostly, I don't like it in the Time class. True, the list of heads is in the time class, BUT this function is building a Stem. I also don't like that I had a bug in my Stem constructor when I tried to add a stem to the Sys list of stems because my stem was headless at the time of creation. So we are going to do a bit of refactoring.

I am going to build a factory method in Stem, getStem(Staff, Time, y1, y2, up), that will go though the heads at that time, see if there are any that cross the y1,y2 limits and if so, create the headlist for the stem and get me a stem. We will be changing the Stem constructor so that now we DON'T create stems without first having an array list of heads ready to hook onto it. 
 
This getStem method will also be able to call a helper to determine if the y values crossed an existing beam so that the stem is internal to an existing beam group.

--comment out the stemHeads class in Time
--comment out the routine joinStem in Head

-- add to Stem
  // factory method gets a stem IF there are heads that match the y values at the given time
  public static Stem getStem(Staff staff, Time time, int y1, int y2, boolean up){
    Head.List heads = new Head.List();
    for(Head h : time.heads){ int yH = h.y(); if(yH > y1 && yH < y2){heads.add(h);}}
    if(heads.size() == 0){return null;} // no stem created if no heads
    Beam b = internalStem(staff.sys, time.x, y1, y2); // possibly this is internal stem in beamed group
    Stem res = new Stem(staff, heads, up); // create the stem
    if(b!=null){b.addStem(res); res.nFlag = 1;} // if it was internal, then join the beam.
    return res;
  }
  
The above code changes the arguments to the Stem constructor so we need to fix that, and it refers to an unbuilt helper, !iinternalStem. 

In the constructor we should NOT assume that the joined heads were already unstemed. Any head on that list should first be removed from any previous stem and join this new one. And part of the reason for this rebuild was to get that stem added to the list of stems in the sys, so we can now do that in the constructor as we wanted.

--rebuild Stem Constructor
  public Stem(Staff staff, Head.List heads, boolean up){
    super();
    this.staff = staff;
    isUp = up;
    for(Head h : heads){h.unStem(); h.stem = this;} // heads leave previous stem and join this one.
    this.heads = heads;
    staff.sys.stems.addStem(this); // new stem goes into list kept by Sys
    setWrongSides();
    ... addReactions .... 
  }

--add to Stem
  public static Beam internalStem(Sys sys, int x, int y1, int y2){ // returns non-null IF we find a beam crossed by line
    for(Stem s : sys.stems){
      if(s.beam !=null && s.x()<x && s.yLo()<y2 && s.yHi()>y1){
        int bx = s.beam.first().x(), by = s.beam.first().yBeamEnd();
        int ex = s.beam.last().x(), ey = s.beam.last().yBeamEnd();
        if(Beam.verticalLineCrossesSegment(x,y1,y2,bx,by,ex,ey)){return s.beam;}
      }
    }
    return null;
  } 
  
The routine looking for an internal stem will make use of a helper (with a hideously long name) that we build in the Beam class. Basically in this stem construction process we had a gesture that was a vertical line, and we are detecting if it crossed the master beam for a beamed group. So this is ONE case when a vertical line might cross a sloped line. The OTHER case (that will eventually get added to the Beam class) will be when the user gestures with a sloped, nearly horizontal line that might have crossed several vertical stems. This Other case will be when we are either createing our first beam between exactly two stems OR when we are adding extra beams to a bunch of stems that are already in a single beamed group. Because the helper looks for intersections with a sloped line I make it a static function of the Beam class that is were we do ALL our sloped line calculations.

--add to Beam  
  public static boolean verticalLineCrossesSegment(int x, int y1, int y2, int bx, int by, int ex, int ey){
    if(x < bx || x > ex){return false;}
    int y = yOfX(x, bx, by, ex, ey);
    if(y1<y2){return (y1 < y && y<y2);} else {return (y2<y && y<y1);}
  }

==Beam Creation Reaction
We want to add the beam creation reaction to Sys. It is the Sys that keeps a list of Stems that we look through to see if our E-E stroke went through exactly 2 of them that are currently unbeamed.

  addReaction(new Reaction("E-E"){ // Beam Stems.
    public int bid(Gesture g){
      int x1 = g.vs.xL(), y1 = g.vs.yL(), x2 = g.vs.xH(), y2 = g.vs.yH(); // collect the gesture numbers
      if(stems.fastReject((y1+y2)/2)){return UC.noBid;} // reject if gesture does not overlap the list of stems
      ArrayList<Stem> temp = stems.allIntersectors(x1,y1,x2,y2); // possible overlap: find intersecting stems
      if(temp.size() < 2){return UC.noBid;} // crossing a single stem is a Stem reaction, not a Sys reaction
      System.out.println("Crossed "+temp.size()+" stems"); // debugging
      Beam b = temp.get(0).beam; //check if all crossed stems are owned by the same beam (including null!)
      for(Stem s : temp){if(s.beam != b){return UC.noBid;}} // different owners is reject
      System.out.println("all stems share owner"); // more debugging
      if(b == null && temp.size() != 2){return UC.noBid;} // only new Beam if exactly 2
      if(b==null && (temp.get(0).nFlag != 0 || temp.get(1).nFlag != 0)){return UC.noBid;} // only new if both are zero nFlag
      return 50; // this is either a create new Beam or flags a set of beams
    }
    
    public void act(Gesture g){
      int x1 = g.vs.xL(), y1 = g.vs.yL(), x2 = g.vs.xH(), y2 = g.vs.yH();
      ArrayList<Stem> temp = stems.allIntersectors(x1,y1,x2,y2);
      Beam b = temp.get(0).beam;
      if(b == null){
        new Beam(temp.get(0), temp.get(1));
      }else{
        for(Stem s : temp){s.incFlag();}
      }
    }
  }); 

The bid routine returna 50 when it succeeds, and that is NOT enough to out bid the existing E-E reaction that puts a flag on a single stem. So if you want the Beaming action to take precedence over the adding a single flag to a single stem, then you must bias the bid of that E-E reaction in Stem. I added 60 to the return value in Stem: bidLineCrossesStem

  return Math.abs(y - (y1+y2)/2) + 60; // allow Sys E-E reaction for beams to underbid at 50

The act routine above can (presumably) safely assume that that intersector list had at least 2 stems (or the bid would have rejected it) and also that if beamed, they all are part of a single beamed group. So we can use this reaction for dual purpose, both for Beaming between two initial stems OR for incrementing an entire set of stems that all share a beam.
   
The above code also made use of a helper, !iallIntersectors which belongs in the Stem.List class. It just looks at the y coordinates of each stem and sees if it crossed the x1,y1,x2,y2 of the Gesture.

--add to Stem.List

  public ArrayList<Stem> allIntersectors(int x1, int y1, int x2, int y2){
    ArrayList<Stem> res = new ArrayList<>();
    for(Stem s : this) {
      if(Beam.verticalLineCrossesSegment(s.x(),s.yLo(),s.yHi(),x1,y1,x2,y2)){
        res.add(s);
      }
    }
    return res;
  }

And finally we need to modify the action portion of the S-S reaction in Head that used to call the old Time stemHeads routine that we tossed out in favor of getStem. Note: we are still calling unStem heads when you draw past a group of heads. This should still work to remove unbeamed stems, but we have not done anything yet to fix the code to properly deal with stems that have beams. We will get to that work AFTER we debug our beam drawing routines.
  
--modify the Head S-S reaction to use getStem
  public void act(Gesture g){
    int x = g.vs.xM(), y1 = g.vs.yL(), y2 = g.vs.yH();
    Staff staff = Head.this.staff;
    Time time = Head.this.time;
    int W = Head.this.W();
    boolean up = x > (time.x + W/2);
    if(Head.this.stem == null){
      Stem.getStem(staff, time, y1, y2, up);
      //t.stemHeads(staff, up, y1, y2);
    }else {
      time.unStemHeads(y1, y2);
    }
  }

At this point, with that reaction to create an initial beam, we should be able to beam a group and debug all the beam drawing code.

There was a bug. I was still drawing flags on stems that were beamed. Easy fix for that. The show routine in Stem draws flags guarded by a test that nFlag > 0. That guard needs to be bumped up to only draw if(nFlag > 0 && beam == null)

Next up - fix the code to deal with the deletion of stems.
 

::S UnSteming Beams 
==Removing Stems from Beams  

Early on in this course when I was creating the Mass class I had you add in some code that redefined the equals() function and the hash() function in Mass with the comment that I would explain why I did that later. Well now is the time. This section is mostly a rant about the bug that I found at this point in my code, and the fix was those couple lines in Mass. So this section is historical in nature documenting the problem that I ran into when the code base did NOT have those few lines in Mass and how I determined that that was the proper thing to do.

--Historical Rant
I imagined that this would be a simple task, fixing a few routines to remove heads from stems, if the stem becomes empty, delete the stem. If the stem was required for a beam (i.e. was either the first or the last stem) then delete the beam (because we are not sure how we should fix it up).

What I found was code that curiously did not work as expected. I started debugging. The debugger didn't show me quite the detail that I wanted so I started writing toString methods for all my classes so that they could show me what was going on. The deadline of an approaching class where I was supposed to release this code was looming and still it did not work.

When I finally tracked down what was going on I was SHOCKED! It did not appear to be a bug in my code but rather in the library code for ArrayList. I traced my way down to a single line of code. I have an array list, a Layer, the NOTE layer, that holds Stems and Beams and head. I have a Stem that I know is on that list. list.contains(stem) is true. I print the contents of the list just to be SURE that the stem is on the list. I call list.remove(stem) and then print the contents of the list after the removal. Sure enough it has removed an element. It removed a Beam! It does NOT remove the stem that I told it to remove. WTF?

OK - so now I know WHAT is going wrong, I just don't know WHY. I do have some suspicions and with some more careful reading of the documentation for ArrayLists I verify that what is going wrong is that .equals for the classes that I am passing in is failing - i.e. I can write code and verify that beam.equals(stem) is true. WHY that is, I still do not know, and a part of me does not really care because now that I know what is wrong I can fix it. There is of course another part of me that will continue to probe because without haveing identified WHY I don't know what other bugs are lurking waiting to happen.

I know that this discussion tells you nothing. I haven't shown you the problem. I will do that, but my concern is that since I don't actually KNOW what caused the problem I am not sure that it will fail on your machine the way that it did on mine.

HOWEVER, since this is a mid-level Java course, I do get to use the fact that I tripped over a nasty bug to talk to you about a CLASSIC intermediate level concern for the Java language, and I will do it all here in general terms so that you can understand the problem BEFORE I write the code that seemed to have fixed that problem on my machine.

I learned of this CLASSIC problem years ago when I read the book "Effective Java" by Joshua Bloch. The book is MOST excellent, the best book I have ever read about Java. BUT it is not really a book for beginners. Fortunately you are not ALL beginners so I can recommend the book. The primary advantage of the book is that Joshua Bloch was one of the guys at Sun that WROTE all the Collections code in the Java Library so when he tells you HOW it WORKS, he KNOWS!

It is entirely possible that you have heard the comment in one of your Java courses, "If you ever override equals you must also override hashcode if you want Maps to work correctly." What we are dealing with is connected to that advice. You were also told that, "When you are comparing two strings you need to use .equals and not ==". So here is the skinny on that.

The expression == is very primitive, by design. When used between two objects its meaning is, "do the pointers to these two objects have the same value i.e. are they both pointing to the exact same memory address and thus the same object."

If you write code like this:

   String foo = "Bob"; String bar = "Bob"
   
And then you test if foo == bar you will find that it is TRUE! This is an accident! It is the result of an optimization that the Java compiler did for you without telling you. Furthermore it is an optimization that EVERY java compiler does for you automatically because it is a REQUIREMENT of the java language. When the compiler sees the string constant "Bob" It create a string that holds the exact letters "Bob" and it points foo to that string AND it remembers in local compiler string space that it KNOWS an address for a string with the value "Bob". In the very next line, when it assigns a different variable bar to the string "Bob" the compiler REMEMBERS that it already knows a string with those letters and it sets bar to point to that same string. SO == is true, both foo and bar point to the same String.

However if you write code like this:

  String foo = "Bob"; String bar = "B" + "ob";

The compiler is NOT required to notice that the concatination of two different strings just HAPPENS to match one that it has previously seen. So it is entirely possible that when you test if foo == bar that you will now get false, they are NOT pointing to exactly the same object. They are pointing to two different objectS that just happen to hold the same letters. Two different objects that just happen to have the same VALUE. 

So if you want to test whether two different String objects have the same value you must use .equals which does the slow test of comparing every single letter in one string with every single letter in the other string. == is fast test, it just compares two numerical pointers.

The job of the function !iequals is to compare two VALUE objects and see if they have the same VALUE.

I do believe that !iequals is defined in the Object class, and thus every object has a default !iequals method and I also believe that that default method is just defined to be the same as ==. So !iequals and == are actually the same function at the lowest level. Now clearly someone overrode that default !iequals when they built the String class because in the String class they knew that Strings were lists of letters and that they wanted to compare each and every character.

Anytime you create a value class, where you WANT the same sort of behavior that you get out of String, where you want two different physical objects that just happen to hold the same value to be considered identical, you OVERRIDE !iequals and define it the way that you want it to behave.

AND AS SOON AS YOU DO THAT - you must override !ihashCode as well. Why? Because hashing and equality testing are closely connected behaviors and hashing is required for Maps.

To remind you, hashing is just a method for speeding up equality testing. If you take one long string of letters and grind them all up into a single integer value, that is the hash code for that string. Presumably if you grind up a second DIFFERENT long string of letters, you will get a different integer value. This gives you a fast rejection - IF hash(A) != hash(B) then it is impossible that A == B. IF the hashes match, well, they might be different or they might be the same.

The default verions of hashCode(Object o), way back in the Object class, just returns an integer that is essentially a pointer to the Object o. This hash method is CONSISTENT with the default definition of equals. Two pointers that are identical are declared to be equal and sho nuff the hash codes are identical if the pointers are identical.

When you change definition of !iequals to something that involves looking at every single character in the string, then your hash code needs to respect that. Just returning pointers will take two object with the same value and return different hashes. If you want a HashMap<String, SomeClass> to return the same identical SomeClass regardless of whether you look up map.get("Bob") or map.get("B"+"ob") then !ihashCode for String MUST be consistent with !iequals for String. 

This is the reason for the advice that "if you override equals then remember to also override hashCode"  

Now I am ready to get down to some of the details of the problem that I was having and that you MAY have on your machine as well (then again you may not). We had a routine in Mass to deleteMass from the layers.

--old deleteMass code
  public void deleteMass(){
    clearAll(); // remove all the reactions for this mass from itself and from the Reactions byShape list
    layer.remove(this);
  }

My problem was that the remove(this) line was failing.

So I modified this routine to call layer.removeItem(this) and went and implemented removeItem in the layer class where I put in lots of debugging statements surrounding the actual removal from the list.

--add to Layer
  public void removeItem(I.Show item){
    ..System.out.println("removing: "+item); // you must implement toString for heads and stems and beams
    ..System.out.println("Before removing: " + this); // you must implement to Sting in Layer to show all items
    remove(item);
    ..System.out.println("After removing: " + this); // you must implement to Sting in Layer to show all items
  }
  
When I ran the system and deleted a Stem, I had the bad behavior that it instead deleted a Beam.

I tested if the list .contains(item), and yes, it did contain the item. I used indexOf(item) and it would return the index of a Beam instead of the indes of a Stem. I tried to locate the item myself using a loop

  int foundAt = -1;
  for(int i = 0; i<this.size(); i++){if(get(i) == item){foundAt = i;}}
  
And that worked! !ifoundAt was set to the correct index, the index of the Stem that I was trying to delete instead of the Beam.

I looked again at the documentation for ArrayList and YES, Array list does NOT use ==, instead it uses !iequals to locate elements, both for indexOf and for remove. So my problem was with equals. I tested that by adding the lines
  int k = indexOf(item);
  if(k>=0 && foundAt>=0){System.out.println("item:" + item + " indexOf" + get(k) +" equals" + item.equals(get(k)));}

Indeed - it told me that the  stem.equals(beam)! There is something wrong with equals in the my Mass class.

Oh yes, by the way, before I did any more exploring trying to track down the problem, I developed the work around. Since foundIt WAS finding the thing that I wanted to deleet, I just stuffed in the line

  if(foundIt >= 0){remove(foundIt);}
  
and that fixed my problem.

Reading up on ArrayList&lt;Foo&gt;, I saw that ArrayList depends on how !iequals is implemented in the Foo class since that is what we are comparing, and of course here, in Layers, I am comparing things that are of type I.Show. All that they have in common is that they match an interface. I would think that as a result they should fall back to the Object definition of !iequals, but maybe not. Maybe there is some other !iequals that they are finding that is failing.

I got to wondering if perhaps, by declaring both Stems and Heads as implementing Comparable that there was something that was screwing up !iequals. So I modified both my Stem and my Head class to use Comparator, where you explicitly pass an comparator into the Collections.sort routine instead of modifying either the Head class or the Stem class. The problem persisted. I was still printing my error messages.

I printed out the hashCode for the two items, the Beam and the Stem, that it was declaring were equal and their hashCodes were both 1. Now THAT does not look like a decent hashCode to me! A random number between 1 and 4 billion just HAPPENS to be 1? The chances of that are just about, let's see, one in four billion! NOW I KNOW for a fact that NOWHERE in my code have I overridden hashCode, have I? So WHY is is broke? I don't know. BUT let me go fix !iequals and !ihashCode directly in the Mass class and see if that doesn't get rid of my error messages.

-- add to Mass
  private int hashCode = G.rnd(100000000);
  public boolean equals(Object o){return this == o;} // set equals back to default as it should be
  public int hashCode(){return hashCode;} // nice and bogus, just like returning a pointer, consistent with ==

And my error messages when deleting Stems from layers goes away.

So I have considered boiling this code down to a minimal example that exhibits the problem and posting it to StackOverflow to see if "real programmer" can tell me what is wrong. Remember, I am not a "real programmer" any more. I am a teacher. I don't write code 10 hours a day and talk with other programmers daily. I will admit that my first thought, when I tripped over my mistake, (not when I tripped over the bug mind you but when I realized that my problem was with equals) was: "Why am I wasting my time teaching noobs how to program? If I spent ALL my time doing NOTHING by PROGRAMMING I just might REMEMBER how to do it and not have to continually look this stuff up!". 

But I have calmed down since then. I have little doubt that if I boiled this down, trying to find a test case that I could post to StackOverflow which still does the wrong thing but does NOT involve over a thousand lines of code, I would discover what I did that caused the problem, and would just end up smacking my head again and wondering why I am so STUPID! I don't need that. I am FAR better off, and you will be too if you heed my advice, "NEVER forget, ALL your tools, the java language, the compiler, the library, the IDE you develop in, your debugger, your operating system, your file system, the graphics subsystem that draws lines on the screen - is ALL CODE - it was all built by Humans and it is FULL of bugs!" There is NO solid ground! Every once in a while, you trip over a bug in some other piece of code that you DEPEND on. So discover what the problem is and then WORK AROUND IT! Where did that bogus hashCode routine come from. I do not know and I do not care. 

As a noob - you are continually confronted with the FACT that ALL the mistakes that you ever see are your own fault. They are all mistakes that YOU have made. You didn't understand what you were doing. You didn't understand your tools. You just made a mistake. You learn that ALL bugs are your own. As you become a more seasoned programmer, you make fewer mistakes, but still ALL the mistakes that you see are your own.

Well that is NOT the truth. The truth is that NEARLY ALL the mistakes that you will ever see are your own fault - BUT NOT ALL. At some point, when you work with ANY device made by someone else or use ANY code written elsewhere there will be bugs that are outside of your scope, which you do not and can not understand.
--End of Rant

And now with that RANT out of my system. Let us write some code to properly remove stems and beams. 
 
First of all, let me further isolate us from problems that may be caused by our multi-threaded Swing code looking at partially formed structures, because as we start deleting heads from stems and start deleting stems from beams we COULD get mal-formed structures.

--modify x(), yFirstHead(), and yBeamEnd in Stem
  public int x(){
    if(heads.size()==0){return 100;} // guard empty stems
    Head h = firstHead();return h.time.x + (isUp ? h.W() : 0);
  }
  
  public int yBeamEnd(){
    if(heads.size() == 0){return 100;}// guard empty stems
    ...
  
  public int yFirstHead(){
    if(heads.size()==0){return 200;} // guard empty stems
    ...
   
I have just returned bogus coordinates for x values and y values if the stem is malformed. I SHOULD have done this earlier. Guess what happens if you have some bad stem that did NOT get properly deleted and it is still hanging around in the layers but it has no heads on it. Guess what happens if you have a beam that didn't properly get rid of a stem - you see everything drawing suddenly at a single fixed point on the screen. You are better off if a genuinly malformed structure DOES draw something on the screen so that you can SEE that it isn't constructed correctly.

Next we fix a bug in the stem crossing reactions for adding and removing flags. We wrote that code back when time.x was the location of a stem. Now stems have a proper .x() function so call that instead. This happens in both the E-E and the W-W reactions.

--modify the Stem reactions
  int xS = x();

As a convenience would like to show stemless heads differently, using color so that the user can tell that a head is unstemmed.  

--add to Head.show()
  g.setColor(stem == null ? Color.RED : Color.BLACK); 

And to make that work correctly, you need to remove the line in Glyph.showAt() that forced the color of all glyphs to be black.

--remove from Glyph.showAt()
  g.setColor(Color.BLACK);
    
We need to fix deleteStem() in Stem to deal with the deletion of a beamed stem.

  --update Stem.deleteStem()
  public void deleteStem(){// only call if heads is empty
    if(heads.size() != 0){System.out.println("wtf? - deleting stem that had heads on it");}
    staff.sys.stems.remove(this); // get out of the sys list
    if(beam != null){beam.removeStem(this);} // tell the beam that you are leaving
    this.deleteMass();
  }   
  
That update used a routine that we have not written yet.

--add removeStem() to Beam class
  public void removeStem(Stem s){
    if(s == first() || s == last()){deleteBeam();} else {stems.remove(s); stems.sort();}
  }

I have decided that we don't want to deal with fixing up a beam that has lost one of its supporting stems so if the stem that is going away was either the first or the last, we will just delete the entire beam.

You should already have deleteBeam in the Beam class. I decided to add a comment to it as I was reviewing whther or not the code would work.

--add to  Beam.deleteBeam()
  // Note: stems still exist, flags and dots still exist.. 
  //..we have just removed the beams from those stems.

We are almost ready to test unbeaming. The place that we need to fix things by calling deleteBeam() is this: Suppose I am removing flags with a W-W gesture from a beamed group and I reduce the number of flags on any beamed stem to 0. When that happens, that stem cannot belong to a beamed group any more. You have broken that beamed group. So we are going to modify that W-W reaction in Stem that called decFlag to see if nFlag has gone to zero and if so, to delete the beam. It is a single line added to the act routine. Here is the entire act routine for that W-W reaction in stem.

--update Stem W-W reaction act()
  public void act(Gesture g){
    Stem.this.decFlag();
    if(nFlag == 0 && beam != null){beam.deleteBeam();}
  }

With that change you should be able to build a beamed group with 3 elements in it, and if you unflag any stem down to 0, the notes and dots and flags remain as they were but the beam goes away and you are back to just having isolated flags on stems.

::S Clefs
==Clefs
Clefs are markers that are used to assign "pitch" values to the lines that show up in the staff. The most common clefs (the two used for piano music and for lots of other instrumental music as well) are the G clef and the F clef.

The G clef is for higher pitched notes, placing "middle C" at line # 10, one ledger below the staff, and the F clef is for lower pitched notes, placing middle-C at line # -2, one ledeger line above the staff. Thus notes directly above middle-C are on a G staff and the notes directly below middle-C are on an F staff.

In common practice music notation, you MUST have a clef on a staff so that the musician can tell what the piteches of the notes are, and thus EVERY staff of every system of every pages must have have a clef sign as the first visible element on the staff. In addition to those required elements, a composer may at any time override the previous clef on a staff line with some other clef, and that override remains in effect until the composer either changes it back or changes it to something else.

It is this feature, of continuing the previously defined value, that will define our design for the clef system.

Each staff will a Clef.List clefs (which can be null) indicating whether any clefs have been added to that particular staff. They will be sorted in order of x so that it is easy to find the last clef that was added to a staff. And each staff will also have a function so that it can got to the previous staff and look up whatever the last clef (which could have been the initial clef) on that previous staff so it can use that as its initial clef. In that way each staff starts out in the same state as the previous staff.

Clearly the initial clef has to be defined somewhere and we will make the decision that it will be the first clef in the clefs list for the very first staff, i.e. the staff that has no previous staff.

==UI
The User interface, for Clefs, will be fairly simple. We will use the gesture SE-SW, (which looks like "&GT;") to create an F-Clef on a staff. The gesture should start roughtly on the top line of a staff and end on the bottom line of a staff. The G-Clef will use the SW-SE gestrue (a "Less Than" sign) also starting at the top line of a staff and ending at the bottom line.

That gesture would normally create a Clef object that sits on the staff at the x location where the gesture was drawn on the staff. There is however one exception: if we have never defined any clefs ever on the chain of previous staffs, then this clef will be the very first initial clef for that staff chain and should go into the clefs list for the very first staff in the chain.

So from a UI standpoint, the first clef that you draw on any completely empty staff become the initial clef for the entire contiguous chain of staffs. After that, any clef change made on a staff that does have an initial staff defined, will show up at the location where it was drawn and will be propagated forward as the new initial clef for the staff that follows.

==Design
Since the inital clef for each staff is defined by a functional call to look at what state the previous staff was left in, we will NOT be drawing the initial clefs with a stored data object, with a Mass. We will just modify the show routine for Staff so that it queries for the intial cleff and does the drawing in the Staff show routine.

As a result there is a tricky thing that I will do with that initial clef that we DO put into the Clef list in that first staff. We will set the x for that first clef in that first staff to some negative score like -300 so that the show routine for that Clef does NOT draw itself as a Mass to the screen. The initial clefs that show up on every staff are not visible as Mass objects, they are instead a side effect of drawing the Staff. Every other Clef object is a true change of clef notation with a genuine x value and thus does draw itself.

In most music, on most pages, clef changes are rare. So in this design, most Clef Lists on most staffs are null. The only clefs that were defined were those initial clefs, which get propagated from staff to staff.

So let us start by modifying the Staff class so that It has the function to navigate to the previous Staff.
--add to Staff
  public Staff previousStaff(){
    return sys.iSys == 0 ? null : sys.page.sysList.get(sys.iSys-1).staffs.get(iStaff);
  }

That function is NOT correct for a multi-page system but will work in our demo. In a multi-page system, you can't just return null because you are at the top system of the page where iSys is zero, you would need to back up to the previous page.

We will need to keep a Clef list of all the changes that happen on a single staff
--add to Staff
  public Clef.List clefs = null; // most staffs do NOT define clefs.

Of course we have not yet defined a Clef class let alone a Clef.List class yet. Let's do that.
--define Clef in music 
  package music; import reaction.Mass;import java.awt.*;import java.util.ArrayList;
  
  public class Clef extends Mass implements Comparable<Clef>{
    public Glyph glyph;
    public int x;
    public Staff staff;
  
    public Clef(Staff staff, int x, Glyph glyph){
      super("NOTE");
      this.staff = staff; this.x = x; this.glyph = glyph;
    }
      
    public void show(Graphics g){glyph.showAt(g,staff.fmt.H,x,staff.yOfLine(4));}
    
    @Override
    public int compareTo(Clef c){return x-c.x;}
    
    //--------------------List---------------
    public static class List extends ArrayList<Clef>{}
  }

Next we write the routines in Staff that let us querry for the initialClef
--in Staff add 
  public Clef lastClef(){return clefs == null ? null : clefs.get(clefs.size()-1);}
  public Clef firstClef(){return clefs == null ? null : clefs.get(0);}
  public Clef initialClef(){ // can return null if no clef has ever been set
    Staff s = this, ps = previousStaff();
    while(ps != null && ps.clefs == null){s = ps; ps = s.previousStaff();}
    return ps == null ? s.firstClef() : ps.lastClef();
  }

We modify the show routine in Staff so that it will show the initial clef
--Add at the end of Staff.show()
  Clef clef = initialClef();
  int x = sys.page.margins.left + UC.initialClefOffset;
  if(clef != null){clef.glyph.showAt(g, fmt.H, x, yOfLine(4));}
  
That routine required a new UC definition
--add to UC
  public static final int initialClefOffset = 30;

==Gestures
We will add two new reactions to Staff. They are virtually identical, the only different is that one of them uses a "SW-SE" and encodes a G-CLEF, and the other uses a "SE-SW" and encodes an F-CLEF. 

--in Staff constructor add
  addReaction(new Reaction("SW-SE"){ // add G Clef
    public int bid(Gesture g){
      int dTop = Math.abs(g.vs.yL() - yTop()), dBot = Math.abs(g.vs.yH() - yBot());
      if(dTop+dBot>60){return UC.noBid;}
      return dTop+dBot;
    }
    public void act(Gesture g){
      if(Staff.this.initialClef() == null){
        setInitialClef(Glyph.CLEF_G);
      } else {
        addNewClef(Glyph.CLEF_G, g.vs.xM());
      }
    }
  });
  
  addReaction(new Reaction("SE-SW"){ // add F Clef
    public int bid(Gesture g){
      int dTop = Math.abs(g.vs.yL() - yTop()), dBot = Math.abs(g.vs.yH() - yBot());
      if(dTop+dBot>60){return UC.noBid;}
      return dTop+dBot;
    }
    public void act(Gesture g){
      if(Staff.this.initialClef() == null){
        setInitialClef(Glyph.CLEF_F);
      } else {
        addNewClef(Glyph.CLEF_F, g.vs.xM());
      }
    }
  });

Both of those reactions made calls in their act routines to helpers that I haven't written yet.
--in Staff add 
  public void setInitialClef(Glyph glyph){
    Staff s = this, ps = previousStaff();
    while(ps != null){s=ps; ps = s.previousStaff();} // find base of this staff
    s.clefs = new Clef.List();
    s.clefs.add(new Clef(s,-900,glyph)); // negative so doesn't show
  }
  
  public void addNewClef(Glyph glyph, int x){
    if(clefs == null){clefs = new Clef.List();}
    clefs.add(new Clef(this, x, glyph));
    Collections.sort(clefs);
  }

Test it out! Be sure that you test that I did the sorting in the proper order. I mean, go change the order of the negation in the CompareTo routine and see how bad it is when you are reversing the sort and changing what the first Clef in that first list does.

::S Key Signatures
==Key Signatures
Clefs are one of the things that show up at the front of a musis staff to orient the musician and one of the other things is the key signature. The key signature looks like a big pile of either sharps or flats that come immediately after the initial clef OR if you are changing key in the middle of a staff, the pile of sharps and flats show up immediately after a double bar line. In fact, that is the prupose of a double bar line, to indicate that you are changing the key of the music at that point.

Key Signatures are similar to clefs in that they propagate from system to system. The initial key on any staff is the same as whatever the key was on the previous staff. The big difference is that while each staff can have a different clef, the key spans an entire system. When you change the key at a double barline, it changes for every staff at that barline.

There are 7 different sharp keys, 7 different flat keys, and 1 that has neither sharps and flats. The way that you draw a key with 3 sharps is you draw 3 different sharp signs on the 3 lines that represent the notes that you want to sharp. The composer gets to choose what key they want to write in, 1 sharp, or 3 sharps, or 2 flats, but they get NO choice on which notes will be sharped or flatted. If you have one sharp it is always F, if you have 3 it is always F,C and G in that order. If you have 2 flats the first is always B, the second is always E. The patterns are fixed.

Since the clefs on a staff change which note is assignend to which line, which lines you draw your sharps or flats on for a particular key depend on the clef that is assigned to a staff.

While it is possible to write code that will calculate where you should draw the elements of a key signature, it is generally easier and shorter to just define the locations in little static data structures. The ONLY drawback to defining them in data is that you have a heavier testing obligation, you must test that every single number was defined correctly.

==Design
We could do something very similar to what we just did for Clefs. Keys do propagate from one system to the next, you can change them at any location. If we were going to do the same thing, we would need to keep a list of measure bars, where the keys could change in each systerm, sorted by x so that we could find the last key defined on a system.

This would be a retro-fit. We wrote the bar code some time ago and never collected them into lists. This is not really a problem, and we COULD do it that way, but I have decided to NOT do it that way for the simple reaons that this course is all User Interface design and I want you to see that there is not always a right way to do things. We have options and we are going to do something different here.

What I am thinking is this. We will add a key field to bars, it will just be an integer indicating that the key has changed to a new key. We need to set the number between -7 and 7. How do we do that? I think it can work much like flags, you draw an E-E horizontal gesture across a double barline  to increment the key count and a W-W gesture to decrement the key count. You then draw the appropriate key signature on that double bar, however, unlike clefs that key will not propagate anywhere, it is just a mark on the page. When you get to the next system, it falls back to being the key that matches the initial key of the previous system.

If the user wanted that key to continue on as the new key, the user can change the initial key signature. How would they do that? Well, although there is no double bar object at the front of a Sys, but there is a left margin and we could just add a Sys reaction that tests whether the user is doing an E-E  or a W-W that crosses that left margin and use that to increment the Sys initial key.

In short we are acting as if there are two different key systems. There is a system of initial keys defined at the Sys level, and we have a second system of keys that are marks drawn at double bars, and the two systems don't interact with one another. The user is expected to keep them in synch.

I know, it is a little bogus to make the user do work that we could/should be doing for them. And it would be even more bogus IF we were building an actual application where we needed to cut music from one place and paste it into another where we would probably need to keep track of where the barlines are. Good thing this is just a demo so our goals can be a little more flexible. 

We are trying to get MOST of the BANG for as little BUCK as possible, so by implementing this code just a bit differently from what we just did with Clefs we get to see if the code simplifies by pushing just a bit of the work onto the user. Not the right choice for an application but maybe the right choice for a demo.

In the first version, I will NOT include any members in our Key class. It will just be static functions, helpers, that will draw piles of glyphs on the proper lines for the different clefs. We will test those first by hacking up our paint proc to see if they look right, then we will figure out what members we need for the two places that we need to have keys, namely Systems and Bars.

--create Key class
  package music; import java.awt.*;
    
  public class Key{
    
    public static int[]  // line# for sharps and flats in G-clef and F-clef 
        sG = {0,3,-1,2,5,1,4},
        fG = {4,1,5,2,6,3,7},
        sF = {2,5,1,4,7,3,6},
        fF = {6,3,7,4,8,5,9};
    
    public static void drawOnStaff(Graphics g, int n, int[] lines, int x, Glyph glyph, Staff staff){
      int gap = gapForGlyph(glyph, staff);
      for(int i=0;i<n;i++){glyph.showAt(g,staff.fmt.H,x+i*gap, staff.yOfLine(lines[i]));}
    }
    
    public static int gapForGlyph(Glyph glyph, Staff staff){
      int h = staff.fmt.H;
      if(glyph==Glyph.SHARP){return 22*8/h;} // approximate width of #
      if(glyph==Glyph.FLAT){return 18*8/h;} // approximate width of b
      return 16*8/h; // approxiamte width of natural sign
    }
  }

When I first typed this in, I discovered that I had not defined SHARP and FLAT in the Glyph class. I used the Mac FontBook to discover that the glyphs were located in the font shortly after REST_4F. I did not know what the proper hot spot for them was so I just assumed that I could use the REST_4F as a template for all of them. So I located them (NATURAL, FLAT, SHARP, DFLAT, DSHARP) from 61511 up to 61515. 

In order to test this, we don't really need to test all 4*7 possible combinations, because when you draw out 7 sharps, you first draw out 6. So add this code to the paint proc in MusicEd

  if(PAGE != null){
    Staff staff = PAGE.sysList.get(0).staffs.get(0);
    Key.drawOnStaff(g,7,Key.sG,110,Glyph.SHARP,staff);
  }

I quickly discovered that I was WRONG in my assumption that the REST_4F was a proper template. The sharps were off in y value so I changed that. And as I went through the remaining tests I adjusted the Ys for several of the Glyphs. The result was that I added this to the Glyph class:

--Add to Glyph
  public static Glyph NATURAL = new Glyph((char)61511, 16, 0, 5);
  public static Glyph FLAT = new Glyph((char)61512, 16, 0, 4);
  public static Glyph SHARP = new Glyph((char)61513, 16, 0, 5);
  public static Glyph DFLAT = new Glyph((char)61514, 16, 0, 4);
  public static Glyph DSHARP = new Glyph((char)61515, 16, 0, 7);

I next tried sF. I Switched the SHARP to NATRUAL to see that we got the gap spacing correct for the natural sign. Next I switched to fG and FLAT, and finally looked at fF with FLAT. You would of course be comparing ALL of these with what google tells you is the proper arrangement for key signatures on the different clefs. 

Also, you should draw a clef on that first staff to verify that the magic number 110 that we used for x gives us a nice arrangement for the key after the clef. 

When done testing do remove the test code from the paint proc.

--Key members
We probably want to add a couple members to the Key class. The main one will be an integer that can range from -7 to 7, representing flats with negative numbers, sharps with positive numbers and neither with 0. However we do need another member to indicate what glyph we will be drawing. 

You might think that the number alone would tell us but that is not quite right. The problem is that in traditional music notation, if you had an initial key that has 2 sharps in it (that is the key of D) and you want to put in a double bar line and set the key to C (which would be no sharps or flats) you can't just put in an empty double bar line. Too easy for the musician to miss that you have changed the key. When you drop to zero sharps or flats you turn off the two sharps with two naturals written in the same arrangement that they were in the original key signature.

This active turning them off only happens at bar lines. You never draw natrual signs for the initial key signature so we will need to treat initial keys (that will need to be a Key member that we add to the System class) a bit differently than we treat the Key member that we will be adding to the Bar class, but that will be easy because we will need two different reactions to deal with those two cases.

--add members to Key 
  public int n; // ranges from -7 to 7 for flats and sharps
  public Glyph glyph; // flat, or sharp, or natural

--add Key member to System
  public Key initialKey = new Key();
  
--add Key member to Bar
  public Key key = null; // null because most bars do NOT define key  

I am going to need a function that will iterate through all the staffs on a Sys (which can be different clefs) and draw the appropriate key signature on each staff. This can be used either for drawing the initial key sig in the Sys show code or for drawing key changes in Bar show code.  

--add drawOnSys() to Key
  public void drawOnSys(Graphics g, Sys sys, int x){
    for(Staff staff: sys.staffs){
      if(n==0){return;} // nothing to draw
      int[] arr;
      boolean isG = staff.clefAtX(x) == Glyph.CLEF_G;
      if(n>0){arr = isG ? sG:sF;}else{arr = isG ? fG:fF;}
      drawOnStaff(g, Math.abs(n), arr ,x, glyph, staff);
    }
  }

Now that code above made use of a function that we haven't written yet, staff.clefAtX(). Because the clef can change at any time somewhere in the middle of a single staff, any bar that shows a key change after that clef change should show the key change using the current clef. This is a pretty straightforward chunk of code. 

--add clefAtX() to Staff
  public Glyph clefAtX(int x){ // can return null
    Clef iClef = initialClef();
    if(iClef == null){return null;}
    Glyph ret = iClef.glyph;
    if(clefs != null){
      for(Clef clef:clefs){if(clef.x <= x){ret = clef.glyph;}} // last clef before x
    }
    return ret;
  }

I need to add a call to the drawOnSys() function in the Sys show code to display the initial Key.

--add to Sys.show()
  int xKey = x + UC.marginKeyOffset;
  initialKey.drawOnSys(g,this,xKey);

which required that I define a UC.marginKeyOffset; I set it to 60.

--add to UC
  public static final int marginKeyOffset = 60;

And in order to test it before I write any reactions, I decided to initialize the n in my Key class to 7 (so that the default key is 7 sharps).

I run that code and it immediately crashes! Null pointer. Of course, I never initialized the glyph in the key class. Can't show a null glyph. So I set it to SHARP.

That seems to work, at least for the initial Key sig. We want a similar call to draw key added to the bar show code. We will add it now but won't test it right away because we don't have any code yet to allow us to add a key to a bar.

--add at end of Bar.show()
  if(barType==1 && key != null){key.drawOnSys(g,sys,x+UC.barKeyOffset);}

That code is guarded by two things. The bar type must be a double bar, which is encoded as 1 and the key must be null. The key will normally be null for bars and we will need a gesture applied to the bar itself to create or edit the key on a bar.

Now we can add some reactions to Bar. I will used E-E to increment the Key and W-W to decrement the key. The stroke needs to cross over the bar line. You will see that the action routines call two routines, incKey() and decKey() that we will need to add to Bar as well. Those are NOT in key because they are Bar specific. I will discuss the differences after I write the reactions.

--add to Bar constructor
  addReaction(new Reaction("E-E"){ // increment key on double bar
    public int bid(Gesture g){
      if(barType != 1){return UC.noBid;} // you can only increment Key on double bar
      int x1 = g.vs.xL(), x2 = g.vs.xH(); // Bar.this.x == x
      if(x1 > x || x2 < x){return UC.noBid;}
      int y = g.vs.yM();
      if(y < sys.yTop() || y > sys.yBot()){return UC.noBid;}
      // here if gesture crossed a barline inside the system bounds
      return Math.abs(x - (x1+x2)/2); // how far is gesture midpoint from x
    }
    
    public void act(Gesture g){
      Bar.this.incKey();
    }
  });
  
  addReaction(new Reaction("W-W"){
    public int bid(Gesture g){
      if(barType != 1){return UC.noBid;} // you can only decrement Key on double bar
      int x1 = g.vs.xL(), x2 = g.vs.xH(); // Bar.this.x == x
      if(x1 > x || x2 < x){return UC.noBid;}
      int y = g.vs.yM();
      if(y < sys.yTop() || y > sys.yBot()){return UC.noBid;}
      // here if gesture crossed a barline inside the system bounds
      return Math.abs(x - (x1+x2)/2); // how far is gesture midpoint from x
    }
  
    public void act(Gesture g){
      Bar.this.decKey();
    }
  });

Normally, increment and decrement would do just that, move the number n in the key up and down and insure that it never gets out of bounds. However, we need a way to let the user indicate that they want to cancel 2 sharp signs with naturals or cancle 3 flats with naturals. I decided rather arbitrarily that they UI I would use would work like this: As long as n is positive (and in bounds) AND the glyph was SHARP, you are just doing the normal increment. You can increment your way up to 2 or 3 easily BUT if you suddenly switch to decrement, (i.e. you do a dec when your glyph was SHARP), you are declaring that you want n left where it was and you are switching to NATURAL. Once you have set the glyph to NATURAL you are done. So how do you change out of Naturals? Essentially having 2 or 3 naturals being drawn was a way of reminding the musician that n was actually 0. So we treat an inc or a dec as moving to 1 sharp or to one flat.

The UI may seem tricky but it is easy to use and the code is fairly simple.

--add to Bar
  public void incKey(){
    if(key == null){key = new Key();}
    if(key.glyph == Glyph.NATURAL){key.glyph = Glyph.SHARP; key.n=1; return;}
    if(key.glyph == Glyph.FLAT){key.glyph = Glyph.NATURAL; return;}
    // else was sharp key
    if(key.n<7){key.n++;}
  }
  
  public void decKey(){
    if(key == null){key = new Key();}
    if(key.glyph == Glyph.NATURAL){key.glyph = Glyph.FLAT; key.n=-1; return;}
    if(key.glyph == Glyph.SHARP){key.glyph = Glyph.NATURAL; return;}
    // else was flat key
    if(key.n>-7){key.n--;}
  }

Build a standard piano system with both a treble and a bass clef, add in a double bar and test out the UI.

The only thing left is to add the reactions so that we can do those same gestures on the left margin and have them modify the initialKey in the Sys.

--add reactions to Sys constructor
  addReaction(new Reaction("E-E"){ // increment key on double bar
    public int bid(Gesture g){
      int x = page.margins.left;
      int x1 = g.vs.xL(), x2 = g.vs.xH(); // Bar.this.x == x
      if(x1 > x || x2 < x){return UC.noBid;}
      int y = g.vs.yM();
      if(y < yTop() || y > yBot()){return UC.noBid;}
      return Math.abs(x - (x1+x2)/2); // how far is gesture midpoint from x
    }
    public void act(Gesture g){
      Sys.this.incKey();
    }
  });
  
  addReaction(new Reaction("W-W"){
    public int bid(Gesture g){
      int x = page.margins.left;
      int x1 = g.vs.xL(), x2 = g.vs.xH(); // Bar.this.x == x
      if(x1 > x || x2 < x){return UC.noBid;}
      int y = g.vs.yM();
      if(y < yTop() || y > yBot()){return UC.noBid;}
      return Math.abs(x - (x1+x2)/2); // how far is gesture midpoint from x
    }
    public void act(Gesture g){
      Sys.this.decKey();
    }
  });

They are almost exactly like the ones that we had in Bar. And now we add the simpler inc and dec to Sys.

--add incKey and decKey to sys
  public void incKey(){
    if(initialKey.n<7){initialKey.n++;}
    initialKey.glyph = initialKey.n >= 0 ? Glyph.SHARP : Glyph.FLAT;
  }
  public void decKey(){
    if(initialKey.n>-7){initialKey.n--;}
    initialKey.glyph = initialKey.n >= 0 ? Glyph.SHARP : Glyph.FLAT;
  }

In your testing do intersperse some clef changes with the barlines to verify that the clefAtX() routine that we wrote is working as expected.

::S Accidentals
==Accidentals
Accidentals are alterations of the pitch of a note. Shifting it up is a SHARP and lowering it is a FLAT. Like many of the other music notation problems, this is simple in principle and complicated in practice. And once again, in the spirit of a demo to see if we can build a gestural interface, we will ignore most of the complicated music problems and do something that will work for many situation.

The simple thing is that there are 5 different accidental symbols in the Glyph class. We located where those are in the Sinfonia font in the previous section on Key Signatures. When you want to alter a note head you just write one of those Glyphs in front of the head. That is the code that we will write.

However I will comment on why drawing the accidental in front of the note is not quite the right thing, and this is a list of things that you CAN test when we finish the code to see that the code we produce is TOO simple. 

The first problem is that accidentals have a Y span that is larger than the span of a single note head, so If you have two notes on a single stem, one over the other, you can't be sure that the two accidentals can stack one over the other the same way the notes do. Basically you are forced to create 2 columns or even 3, and if you can't fit one accid under another in a single column you must displace it to another column so that the accides don't collide.

Secondly, where the columns are located in certainly in front of the note heads, but it might possibly need to be in front of ALL the heads on the stem some of which may have been displaced to the wrong side. On an upStem a note that has been placed on the WrongSide if further to the right, so no problem, but on a down stem, a note on the wrong side sticks out to the left and could thus collide with an accidental that was also placed to the left of a note head. Thus you can't just look at the location of the Head that you are attaching the accidental to, you must look up and down the stack to see if there are any collisions in the y direction.

Lastly, from a layout standpoint, there is a convention that just adds to the problems. The convention is that IF you have two notes on the same stem that just HAPPEN to be one octave apart, and IF they both have been altered in the same way, (for example both have been sharped - not required by certainly common) then you are required to draw the accidental for both of them in the same column.

Again, this is not a hideous problem, it just means that simple code like we wrote to displace heads to the wrong side is not as simple and just running a single loop from one head to the next on the stack. 

As I said we will just ignore these problems at this time.

Let us start by writing a class to hold the actuall accidental and the Head that it uses to know its x and y values. Create a class named Accid 

  public class Accid extends Mass{
    public static int FLAT=1, NATURAL=2, SHARP=3;
    public static Glyph[] GLYPHS = {Glyph.DFLAT, Glyph.FLAT, Glyph.NATURAL, Glyph.SHARP, Glyph.DSHARP};
    public int iGlyph; 
    public Head head;
    
    public Accid(Head head, int iGlyph){super("NOTE");this.head = head; this.iGlyph = iGlyph;}
    
    public void show(Graphics g){GLYPHS[iGlyph].showAt(g,head.staff.fmt.H,x(),head.y());}
    
    public int x(){return head.x() - UC.headAccidOffset;}
  }

We need to define UC.headAccidOffset 
  public static final int headAccidOffset = 25;

Next we will need to add a member to the Head class so that heads can know that they have an accid attached to them.

--in Head add
  public Accid accid = null;

We will then need some reaction in Head to see if we want to add an accidental to them. I decided that since we are basically raising and lowering the pitch of a note that the appropriated gestures would be an up arrow, NE-SE, and a down arrow, SE-NE for those two actions.

--add to Head constructor    
  addReaction(new Reaction("NE-SE"){ // upArrow create # (or raises)
    public int bid(Gesture g){
      int x = g.vs.xM(), y = g.vs.yL(); // center top is gesture hot spot 
      int hx = Head.this.x()+Head.this.W()/2, hy=Head.this.y(); // head center
      int dx = Math.abs(x-hx), dy = Math.abs(y-hy), diff = dx+dy;
      System.out.println(dx+ "Head NE-SE: "+diff+ " ("+hx+","+x+")");
      return (diff < 50) ? diff : UC.noBid;
    }
    public void act(Gesture g){
      Head.this.accidUp();
    }
  });
  
  addReaction(new Reaction("SE-NE"){ // dnArrow create b (or lowers)
    public int bid(Gesture g){
      int x = g.vs.xM(), y = g.vs.yH(); // center top is gesture hot spot 
      int hx = Head.this.x()+Head.this.W()/2, hy=Head.this.y(); // head center
      int diff = Math.abs(x-hx) + Math.abs(y-hy);
      return (diff < 50) ? diff : UC.noBid;
    }
    public void act(Gesture g){
      Head.this.accidDn();
    }
  });

Those actions will require a pair of functions to shift up and to shift Down

--in Head add 
  public void accidUp(){
    if(accid == null){accid = new Accid(this,Accid.SHARP); return;}
    if(accid.iGlyph<4){accid.iGlyph++;}
  }
  public void accidDn(){
    if(accid == null){accid = new Accid(this,Accid.FLAT); return;}
    if(accid.iGlyph>0){accid.iGlyph--;}
  }

At this point you can test it and see that you can now add accidentals with all the drawing problems that we chose to ignore. We could just leave it at that, but there is something else that we could have done a while ago but have not delt with yet. The time has come to introduce deletion.

Well, ALMOST time to introduce deletion. As I did my testing and verified that there were problems with accid placement that I had decided to skip, I decided that the bad placement was just TOO UGLY and I could not live with a demo that would NOT let you fix those bad alignments. I still don't want to write the code that does all the proper vertical layout BUT it is pretty easy to add in a single reaction that will allow the user to tweek the layout of a single Accid. We can let the user DOT on an accid that is colliding with another one and push it just a bit to the left. And we can make that a cycle so if you push it too far it reverts back to the original bad placement.

--Add a new member to Accid
  public int left = 0; // adjust location slightly Left

--Add a DOT reaction to Accid constructor
  addReaction(new Reaction("DOT"){
    public int bid(Gesture g){
      int x=g.vs.xM(), y=g.vs.yM();
      int xA = Accid.this.x(), yA = head.y();
      int dx=Math.abs(x-xA), dy = Math.abs(y-yA), dist = dx+dy;
      return (dist>50) ? UC.noBid: dist;
    }
    public void act(Gesture g){left += 10; if(left > 50){left = 0;}}
  });  

--update the x() in Accid to use Left
  public int x(){return head.x() - UC.headAccidOffset - left;}

And there you go. If you want to move an accid slightly left, click on it.

Now we can move on to deletions.

::S Deletion
==Deleting Objects
Most editors require that you ought to be able to change your mind and delete things that you used to have. We could have, should have, had the ability to delete Heads and Accids and Bars. To be honest the primary thing that brought this to mind was the Accid code that I just wrote. When I added a new member to Head, where it knew it's Accid and where the Accid knows its head, I found myself thinging, "I need to modify the Head delete routine to also remove the accid that was on it."

Deleting an Accid should not remove the head, but deleting the head must remove the accid. So I went to modify the deleteHead function and, oops, we never wrote one.

Since we will want to do deletion for several different objects is it a good idea to have a uniform gesture that we can use pretty uniformly for doing those deletions. We have not used S-N for anything yet and I decided that it should mean delete for the user. The hot spot for the gesture should be the initial x,y so you just click down on the object that you want to delete and then do a quick sweep down and then up.

Doing this for several different objects means that you need to add reactions to all those objects. We will start with the Accid class that we just wrote.

==Delete Accids

--Add Reaction to Accid constructor
  addReaction(new Reaction("S-N"){
    public int bid(Gesture g){
      int x = g.vs.xM(), y = g.vs.yL();
      int ax = Accid.this.x() + head.W()/2, ay = Accid.this.head.y();
      int dx = Math.abs(x-ax), dy = Math.abs(y-ay), diff = dx+dy;
      return diff > 50 ? UC.noBid : diff;
    }
    public void act(Gesture g){
      Accid.this.deleteAccid();
    }
  });

And yes, you are right, I SHOULD have actually defined the width of the actual accidental instead of just guessing that it was pretty close to the width of the head that it is sitting on, but hey, I was in a hurry and besides the way we layout accids is all wrong any way. We will eventually throw out all this code. 

We also need to write the little action routine

-- Add deleteAccid() to Accid
  public void deleteAccid(){
    head.accid = null; // remove the accid from its head
    deleteMass(); // and delete from the layers
  }

Test it our and you should find that you can delete accidentals. Please note that it looks like undo, but it is not. It really is a delete and it works properly with undo, meaning you can draw a note, add an accidental, delete the accidental and then do an undo and the accidental that you deleted comes back.

== Delete Heads

Next we do the same thing for heads. It is a bit more complicated because heads connect to things  other than accids. They also connect to stems. Similar to the way that a head remains if you remove an accid from it, a stem could remain after you delete a head from it BUT the stem should be deleted if the very last head was removed from it, and deleting a stem could also cascade into deleting a Beam if the stem was one of the supporting members for the Beam. (Presumably that code has already been written, we will get to see if it works correctly now!)

First add a reaction to the Head class 

--add to Head constructor
  addReaction(new Reaction("S-N"){ // Delete
    public int bid(Gesture g){
      int x = g.vs.xM(), y = g.vs.yL();
      int ax = Head.this.x() + Head.this.W()/2, ay = Head.this.y();
      int dx = Math.abs(x-ax), dy = Math.abs(y-ay), diff = dx+dy;
      return diff > 50 ? UC.noBid : diff;
    }
    public void act(Gesture g){
      Head.this.deleteHead();
    }
  });

And then make sure that you clean up everything that you need to from Head. And yes, we had done some of this already in unStem().  

--add deleteHead() to Head 
  public void deleteHead(){
    if(accid != null){accid.deleteAccid();} // remove my accid
    unStem(); // remove my stem and possibly delete stem as well
    deleteMass();
  }

== Delete Barlines

I don't really find myself needing to delete barlines often but then again, it helps to test the entire reaction architecture that there are many different types of objects all competing to win that bid for the S-N stroke. As before we start with a recaction in the Bar class. The main difference between this and the others is that they were all glyph based, and glyphs are fairly small and thus have a well defined and easy to visualize center. Bars on the other hands are just vertical lines. They do have a center, but if they span multiple staffs we can really expect the user to accurately target the center dot. If we just used the previous code the delta y calculated could be quite a bit off and I would not want someoe that tries to delete a bar be so far off in the y that they would instead delete some other object that was near the gesture. SO we have modified the code slightly.

--add Reactions to Bar constructor
  addReaction(new Reaction("S-N"){ // Delete
    public int bid(Gesture g){
      int x = g.vs.xM(), y = g.vs.yL();
      int y1 = Bar.this.sys.yTop(), y2 = Bar.this.sys.yBot();
      if(y < y1 || y > y2){return UC.noBid;}
      int ax = Bar.this.x;
      int dx = Math.abs(x-ax), diff = dx+ 16; // little bias for the missing y
      return diff > 50 ? UC.noBid : diff;
    }
    public void act(Gesture g){
      Bar.this.deleteBar();
    }
  });

The deleteBar code looks like this:

--add deleteBar() to Bar
  public void deleteBar(){deleteMass();}

== Delete Clef
I think one more deletion should about do it. We should be able to remove clefs. They are glyphs so the code that we used for Heads and Accids where we target the center of the glyph should work fine. As a result the reactions are pretty much what we would expect.

--add reaction to Clef constructor
  addReaction(new Reaction("S-N"){ // Delete
    public int bid(Gesture g){
      int x = g.vs.xM(), y = g.vs.yL();
      int ax = Clef.this.x + staff.fmt.H*2, ay = staff.yOfLine(4);
      int dx = Math.abs(x-ax), dy = Math.abs(y-ay), diff = dx+dy;
      return diff > 50 ? UC.noBid : diff;
    }
    public void act(Gesture g){
      Clef.this.deleteClef();
    }
  });

The action code to deletClef that I first wrote seemed simple but testing showed that it had a bug. Here's what I wrote first.

--add deleteClef() to clef
  public void deleteClef(){
    staff.clefs.remove(this);
    Collections.sort(staff.clefs);
    deleteMass();
  }

I remembered to remove the Clef from the list of clefs in the Staff, and I remembered to sort the clef list (because it must be sorted before use and if you remove something it won't necessarily still be sorted - you don't know how they rearrange things after a removal.

The bug I got when I started adding and deleting clefs was strange. It was telling me that lastClef() generated an index out of bounds error and was failing on the line 

  clefs.get(clefs.size()-1);

And I foolishly thought, "How could that fail! We're looking at the last clef on the list? That index is in bounds!" Well it is in bounds if the list is not empty, and I was deleting clefs and, oops, I WAS deleting clefs and emptied the list. Sho nuff, my tests in get initialClef() all assumed that cleffs was null and remained null until I put something it and then it wasn't empty. That is all valid until you start removing things. So the fix is simple. Just set it back to null if you ever do clear out clefs.  

How could that happen?
-- change deleteClef in Clef
  public void deleteClef(){
    staff.clefs.remove(this);
    if(staff.clefs.size()==0){
      staff.clefs = null;
    } else{
      Collections.sort(staff.clefs);
    }
    deleteMass();
  }

I did not include a deletion for the initial clef. We could put that in. It would need to be a staff reaction all the way over at the left hand side where we draw the initial clef. (Remember that clef is NOT an object. It is NOT a Mass. It does not live in the layers. It is just a drawing of a clef that the Staff performs.) 

However do you really want to delete the initial clef? I suppose you could treat an initial clef deletion as a request to wipe out all the clefs on all the related staffs so that you can redefin the clef structure. I will leave that up to your discression.

::S Summary
== Summary
  
We now have an app in about 25 classes which probably amounts to a couple thousand lines of code. It makes for a decent demo. It uses all the gesture recognition classes that we have implemented and it shows: Systems, Staffs, Barlines (in 3 varieties) Heads (in 3 varieties), Stems,Flags, Beams, Rests, Clefs, and KeySignatures. We can dot both heads and flags. We can stem and unstem notes, increase and decrease the number of flags on a stem.

There is a lot of music that can be represented with this system.

There is MUCH that we are missing. We have no Time Signatures, no Accidentals, no Ties, no Dynamics, no accents etc. Not to mention some very critical things that any real application MUST have, like the ability to save and load files, or the ability to print, or to have multiple pages.

This is NOT an application. It is a Demo, but it is a GOOD demo. Presumably if you have made it to this point, you would find no particular dificulty in implementing some or even all of the missing music features that I just mentioned. Much of the UI work consists of deciding which gesture would be a good one to tell the system what you want to do, then you build a class to do that new thing, to show that new thing, and you build reactions that call the constructors for that new thing.

We will probably not press on (in the course that I teach) and build some of these other features. However, I may add to these notes and cover a few things that I will not do in class.

It is also worthwhile to remind you that we have written this code in something like 16 days of 2 hour long classes i.e. 32 actual hours of sitting at the screen. This is less than one 40 hour work week. Now it is true that you do NOT get to sit at the screen for 8 hours a day writing code during your work week. You must go to meetings and talk to your boss and co-workers etc. Also you did not have to spend ANY time in design because you had someone showing you what to do next at all stages. BUT it is not incorrect to say that this demo is the sort of thing that COULD be built in a week or two once you understand all the fundamental concepts that make up the design.

We have reached an important mile-stone here. When you build REAL demos for REAL applications, part of what you are doing is sketching out the classes and the overall architecture to see if it WILL enable you to build the application that you are thinking of building. While this is far from a complete application, we should at this point have confidence that the UI design choice, the Reaction Architecture that we started with, does in fact HELP us build a music notation application.

For me, back when I did this years ago, this demo convinced me that the reaction architecture is a useful way to think about building a gesture based application.

::S Refactoring
==Refactoring

Time to break up our Music1 class, which had dozens of nested classes into actual classes. When we started that last sprint, to put notes and stems and beams and rests into a single class, it sounded simple. The class grew to a thousand lines and editing it involved WAY TOO MUCH scrolling up and down to find things. We fix that now.

The positive spin that I will attmept to place on this is just that refactoring is a fact of life in the programming world. You do NOT ever have everything in the right place. You often find yourself in a project where you wished you had things organized differently. This ususally happens just before you ship version 1. The initial organization seemed fine but in the final push to get things finished the team added people and they wrote code and it all spralled out of control and you are just dying to rewrite it and do it the way that it SHOULD have been done in the first place, .... BUT YOU CAN'T because you GOT to ship version 1! DEATH-MARCH!

Now we start on version 2, we can forget all about version 1, well, except that we want to steal all the good code.

--Step 1
Way back in the early days we built a folder named Music and it has one single class, Glyph in it. We are going to create new java classes in that Music folder, each one corresponding to a class that we copy from Music1 and paste into its new home. We will end up with the following classes:

Bar, Beam, Duration, Glyph, Head, Page, Rest, Staff, Stem, Sys, Time

When you paste them in, if you are using Idea, you are told that the code you are pasting in relies on imports that you will need. DO not just click and say, "Sure, fix it". The trouble is that that Stem code that uses Beam is actually sandbox.Music1.Stem code that refered to sandbox.Music1.Beam code. You don't want the new class in Music.Stem to reference back to Music1.Beam you want it to reference Music.Beam that you just haven't created yet. 

You can and should allow it to fix imports to java.awt, and java.util and things like that. You can also import just one single reactions class like, Gesture and then change it to

  import marlin.reactions.*;

so that it gives you access to everything in the reactions package.

You will also need to remove the word "static" from all your class definition headers.

--Step 2
During our initial development we made everything public so that we could get at it. We COULD have, probably SHOULD have marked everything as private. It wouldn't have mattered in the least. Java does NOT enforce public and private restriction between nested classes. Anything in one single file can see Anything else in that same file. Privacy is actually a FILE level notion not a class level notion.

We are going to take the rewrite as an opportunity to make a privacy sweep over everything. Go through every file and make all the public members private. (OK so I didn't actually make all the static members private - typically those were intended to be public. I just never looked at the static members.)

This will cause lots of access problems between the file. This is GOOD! Now we get to go through and fix them

--Step 3
Look at every access violation and ask yourself whether you want to A) make the member public again so that someone can get at it or B) build something like a getter or a setter to allow external access to a class memeber.

Specific examples:

The Time class used to do this in the constructor:

  sys.times.add(this); // adding a time to the list of times in Sys
  
It can't, now that you have made !itimes into a private member. But you can write a routine in Sys:

  public void addTime(Time time){times.add(time);}
  
and now you can modify the Time constructor to call that helper:

  sys.addTime(time);

We have several lists tucked inside classes where you can modify the access to the list by inserting a helper. I ended up writing the following helpers in the following classes

--add to Sys
  public void addTime(Time time){times.add(time);}
  public int addStaff(Staff staff){staffs.add(staff); return staffs.size()-1;}
  public Staff getStaff(int ndx){return staffs.get(ndx);}
  public void addStem(Stem s){stems.addStem(s);}
  public void removeStem(Stem s){stems.removeStem(s);}

--add to Time
  public void addHead(Head head){heads.add(head);}
  public void removeHead(Head head){heads.remove(head);} // not currently used


And with those helpers in place, you can replace two lines in the Staff constructor with a single one:
  this.ndx = sys.addStaff(this); // both adds the staff to the sys AND tells us where it was added.

--Step 4

On the other hand, there are some values that should remain public. For example Time was created for the sole purpose of allowing the music routines to share and x value. It seems silly to then hide that x value behind getters and setters. I take much the same attitude about many of my value classes - A Head has a line and a stem and is either on the wrong side or not. Anyone should be able to see (or even change) those values. Some purists would argue otherwise, that all members should hide behind getters and setters. I won't stop you from writing code that way if you feel that you must.

This business of converting from public to private back to public is something that modern IDEs make easy, because they flag all the access errors by making such a change. It is not a bad idea to do this occasionally as you edit your code. Make every thing public so anyone can change anything. Them make them all private, break a lot of stuff and remind yourself of how interconnected everything is. Build some helpers to allow things to be remain private and convert everything else back to public. Building getters and setters (and keeping everything private) should not be seen as an alternative to making the decision of what should be public and what should be private. If everything has a getter and a setter then you have made everything public which is not very much along the lines of "division of responsibility" which is part of what you classes were supposed to be doing for you.  
  
However there are some things that defy the simplistic notion that there is just one good place to locate code. We have a routine in Head to unStem a head. It needs to remove a head from the heads in the stem. Well, that is something that a Stem should be doing, because if the last head comes off a stem the stem should delete itself which really is a Stem responsibility. On the other hand. When you remove a stem from the head there are several Head fields, namely !istem and !iwrongSide, that need to be updated which certainly seems to be a Head function.

We could and in fact will have two routines, unstem() in the Head class and removeHead() over in the Stem class. The unstem function will call the removeHead function. We could DIVIDE the responsibility between these two routines. Let the removeHead function take the head off the list in Stem and make the unstem function update the two Head fields, stem and wrongSide - the notion being that each class takes responsibility for its own members, but there is a risk in doing it that way. The problem is that you will one day forget what you did. (I mean after you have written thousands of functions for thousands of classes) and someday, when you are back patching this code you will see a nice public function in the Stem class called, "removeHead" and you will assume that you can call it and remove a head from a stem, forgetting that part of the task of removing a head from a stem involved changing values directly in the Head object.  

You see, if we divide the responsibility and some of the required work is done in the function unstem, then unstem in Head does it all, but removeHead is just a helper and should not be directly called, except by unstem. In a case like this, I prefer to make both routines do everything so that they are both safe to call to perform the documented action, namely removing a head froma stem. So in this particular case, I make removeHead do ALL the work and then I put comments over in the unstem routine. This way when if I look at the code in Head I don't spend time wondering why it isn't updating the variables that it should. Here is what I did:
 
--add to Stem
  public void removeHead(Head h){
    heads.remove(h);
    if(heads.size() == 0){deleteStem();}
    h.stem = null;
    h.wrongSide = false;
  } 

--modify in Head
  public void unStem(){
    if(stem != null){
      stem.removeHead(this); // this will delete stem (and beam) if necessary
      // remove Head in stem also does the following
      // stem = null;
      // wrongSide = false;
    }
  } 

--Step 5
There were several variables, namely PAGE, SYSFMT, & SYSTEMS that were Application level variables that do NOT belong down in a Music package, and yet they do have variables and values that our Music classes need to know. Now that we have much of the drawing done, we can see that the classes that reference these items are just the 3 classes: Bar, Staff, & Sys

A little bit of thinking, which we could have perhaps done at the start of the project, allows us to restructure these references. We created 3 singltons in our App, restricting ourselves to a single PAGE a single SYSFMT and a single list of all the SYSTEMS. We will now modify that notion into the following. Even though we are not (yet anyway) building a multi-page music notation system, we can recognize that probably a single page would have but a single sysfmt for that page and certainly every page should have a list of all the systems that are on that page. So we can fold two of our singlton constants into being members of a Page object.

--add to Page
  public ArrayList<Sys> systems = new ArrayList<>();
  public Sys.Fmt sysfmt;
  // Page Constructor
  public Page(Sys.Fmt sysfmt){this.sysfmt = sysfmt;}
  public int addSys(Sys sys){systems.add(sys); return systems.size()-1;}

Next we upgrade Sys so that each Sys know what page it is on, and thus any Sys which used to be on a list SYSTMES is now on a list page.systems. Likewise, where it used to refer to the single SYSFMT it can refer to page.sysfmt. 

The classes Bar and Staff both knew which Sys they belonged to so the can get at these notions as well by using sys.page.systems or sys.page.sysfmt if they need access.

Unfortunately, even with those changes we are still have some classes, namely Sys.Fmt and Staff.Fmt that refer to those application singltons. Some of these are easy to fix. For example: Staff.Fmt has a show at routine that requires a page notion, in particular it needs to know the page margins. Since a Staff.Fmt object could be shared by many pages, we do NOT want to put a Page member directly into the Staff.Fmt class, however there is nothing wrong with passing a Page ARGUMENT into the showAt routine so that it can show that single format on that particular page.

--modify Staff.Fmt showAt routine
  public void showAt(Graphics g, int y, Page page){
    for(int i = 0; i < nLines; i++) {
      int yy = y + 2*i*H;
      g.drawLine(page.left, yy, page.right, yy);
    }
  }

--Similarly modify the Staff.Fmt constructor to get a Page as an argument
  public Fmt(int dy, Page page){
    this.dy = dy;
    this.H = page.sysfmt.maxH;
    page.sysfmt.add(this);
  }
 
Notice that I moved the initialization of the H value into the constructor when I have reference to a page.

--modify Sys.Fmt showAt to use a Page Argument
  public void showAt(Graphics g, int y, Page page){
    for(Staff.Fmt sf : this) {
      sf.showAt(g, y + sf.dy, page);
    } // show all the staffs at the proper delta
  }

There is one more issue in Sys.Fmt. We have a routine addNewStaff, that does two things, a) it adds a new Staff.Fmt into the Sys.Fmt and then it propogates that changed Sys.Fmt to every Sys that is in the Systems array. Well, in a multi-page model, we no longer have A sysfmt, we possibly have many. In order to fix all the systems that refer to that Sys.Fmt, now that every single page has a different systems list, we will need to iterate though all the pages, locate those that use the particular Sys.Fmt that we just updated and fix all those systems. Outline of the fix looks like this:

--modify addNewStaff in Sys.Fmt
  public void addNewStaff(Page page, int y){
    new Staff.Fmt(y - page.top, page); // first create the Staff.Fmt which will join the SYSFMT list
    for(Page p: ALL_PAGES) {
      if(p.sysfmt == page.sysfmt){
        for(Sys s : p.systems) {
          s.makeStaffsMatchSysfmt();
        }
      }
    }
    ; // every existing system must be udated
  }

BUT...I say outline because I have just refered to something that doesn't exist, namely ALL_PAGES. Where do we get a list of all the pages?

And that is the one tricky step that remains. Somehow it is the application that is the one that decides IF we are running a multi-page system or not. It is the application that should be responsible for managing the pages. 

Basically we need some way for our application to communicate its decision on how to deal with pages to our music package and yet if our music subsystem is going to work with multiple apps it can NOT make references to something that is in the App.  And this is of course what interfaces are for. They are essentially a contract for how two subsystems can interact.

When I think about how I want pages to work in a genuine multi-page application there are many unresolved issues. For example, we have already built a Page class in the music package with 4 ints representing the margins; top, left, right, bot. Do we really want to lug that data around on every single page? Almost always in any real multi-page publication the margins are pretty consistent across the entire document. So it is probably time to trash that Page class the way it was. That Page class was really was just a place holder for our first Single Page application. Let us now try to expose the information that was in that class as an interface.

--add some more interfaces to I
  interface Margins{
    public int top();
    public int left();
    public int right();
    public int bot();
  }  
  interface Page extends Margins{
    public Sys.Fmt sysfmt();
    public ArrayList<Sys> systems();
  }
  interface MusicApp{
    public ArrayList<Page> pages();
    public Sys.Fmt sysfmt(page);
    public ArrayList<Sys> systems(page);
  }
 
This gets us access to everything that we used to have in the class Page except for sysGap. We will move that from being a page notion to being a Sys.Fmt notion. 

Next we want to create the physical way that an application, which implements MusicApp, can be discovered and refered to by our music package. We will create a new class, APP, in the music package whose job is to hold one single static member that will be of type MusicApp.

--add to music package a java class
  class APP{public static I.MusicApp get;}
  
Yes, the names are strange. They were selected to make references to application specific notions from any music class look like this:
  APP.get.pages();
  APP.get.sysfmt(page);
  ..
  
It will now be the responsibility of the application to create some class that implements I.MusicApp and shove that object into APP.get. Of course, it will probably just make Music2 directly implement I.MusicApp and then the constructor of Music2 will have a single line.
   APP.get = this;
   
--Step 6
When we switch to this way of dealing with pages, we will eventually delete the Page class.

First we make it obsolete by changing everything that used to be of type Page to be of type I.Page. This will break lots of stuff. page.top USED to be valid. That is NOT valid for an I.Page. Those need to be converted to page.top(). Fix all the things that you broke by converting to I.Page.

When all the references to Page are gone you will be able to delete the class music.Page

--Last step
Create a Music2 app in the sandbox by copying the front part of Music1.

--make Music2 implement I.MusicApp
  public Sys.Fmt sysfmt(I.Page page){return SYSFMT;}
  public ArrayList<Sys> systems(I.Page page){return SYSTEMS;}
  public ArrayList<I.Page> pages(){return PAGES;} 

We will create the variable PAGES in just a moment

--Add a nested class to be the single I.Page
  public static class M2Page implements I.Page{
    public int top = 50;
    public int top(){ return top; }
    public int left(){ return 50; }
    public int right(){ return UC.mainWindowWidth - 50; }
    public int bot(){return UC.mainWindowHeight - 50; }
    public Sys.Fmt sysfmt(){ return SYSFMT; }
    public ArrayList<Sys> systems(){return SYSTEMS; }
  } 

Now we can replace the single Page that we created, and can create the PAGES ArrayList
--add and update our old Singltons
  public static I.Page PAGE = new M2Page();
  public static Sys.Fmt SYSFMT; // set by initialAct
  public static ArrayList<Sys> SYSTEMS = new ArrayList<>();
  public static ArrayList<I.Page> PAGES = new ArrayList<>();
  static{PAGES.add(PAGE);}  // this app runs with a single page 
  
--Finally fix the reactions that call new Sys() and addNewPage()
Both of those functions now require and I.Page as an argument so pass in PAGE.

--Last but NOT LEAST
Do remember to change Main to run Music2 instead of Music1. I forgot this step and was amazed that all that editing that I had done ran perfectly the first time. It looked EXACTLY like Music1!

When I remembered to swich over to Music2, I immediatly got a null pointer error. I had forgotten to add the one line that I mentioned in the Music2 constructor to set the value of APP.get, so it was null the first time one of the Music functions tried to get something from the App.

The other mistake that I made was that in the beginning of this conversion, I suggested that you add a helper to PAGE, addSys(), that would let us set up index. Then, when I decided to THROW AWAY the Page class, I lost that helper and when I "fixed" the Sys constructor, I forgot to set up ndx properly

--add to Sys Constructor:
    ArrayList<Sys> systems = APP.get.systems(page);
    systems.add(this);
    ndx = systems.size()-1;
    
That fixed it and the Music2 was running just like Music 1 had been.

For the next section I will list all the Music code after it is been broken into individual files.
::S Music2.java
==Music2.java
  public class Music2 extends Window implements I.MusicApp{
    static{
      new Layer("BACK");
      new Layer("NOTE");
      new Layer("FORE");
    }
    
    public Sys.Fmt sysfmt(I.Page page){return SYSFMT;}
    public ArrayList<Sys> systems(I.Page page){return SYSTEMS;}
    public ArrayList<I.Page> pages(){return PAGES;}
    
    public static class M2Page implements I.Page{
      public int top = 50;
      public int top(){ return top; }
      public int left(){ return 50; }
      public int right(){ return UC.mainWindowWidth - 50; }
      public int bot(){return UC.mainWindowHeight - 50; }
      public Sys.Fmt sysfmt(){ return SYSFMT; }
      public ArrayList<Sys> systems(){return SYSTEMS; }
    }
    
    public static I.Page PAGE = new M2Page();
    public static Sys.Fmt SYSFMT; // set by initialAct
    public static ArrayList<Sys> SYSTEMS = new ArrayList<>();
    public static ArrayList<I.Page> PAGES = new ArrayList<>();
    static{PAGES.add(PAGE);}  // this app runs with a single page
    
    public Music2(){
      super("Music 2 - Layout", UC.mainWindowWidth, UC.mainWindowHeight);
      APP.get = this; // make this application accessible to the music classes.
      Reaction.initialAct = new I.Act(){
        public void act(Gesture g){
          SYSFMT = null;
        }
      };
      
      Reaction.initialReactions.addReaction(new Reaction("E-E"){ // add New Staff to SYSFMT
        public int bid(Gesture g){
          if(SYSFMT == null){
            return 0;
          } // always bid for E-E on an empty page
          int y = g.vs.yMid();
          if(y > PAGE.top() + SYSFMT.height() + 15){
            return 100;
          } // only bid if y is below last staff in first sys
          return UC.noBid;
        }
        
        public void act(Gesture g){
          int y = g.vs.yMid();
          if(SYSFMT == null){
            ((M2Page)PAGE).top = y;
            SYSFMT = new Sys.Fmt();
            SYSTEMS.clear();
            new Sys(PAGE);
          }
          SYSFMT.addNewStaff(PAGE, y);
        }
      });
      
      Reaction.initialReactions.addReaction(new Reaction("E-W"){ // SYSFMT finished, add new System.
        public int bid(Gesture g){
          if(SYSFMT == null){
            return UC.noBid;
          } // don't add sys if there is no SYSFMT yet
          int y = g.vs.yMid();
          if(y > SYSTEMS.get(SYSTEMS.size() - 1).yBot() + 15){
            return 100;
          } //..if y is BELOW last System
          return UC.noBid;
        }
        
        public void act(Gesture g){
          int y = g.vs.yMid();
          if(SYSTEMS.size() == 1){ // when first system is finished we are defining sysGap
            SYSFMT.sysGap = y - (PAGE.top() + SYSFMT.height());
            //PAGE.nSys = (PAGE.bot() - PAGE.top())/(SYSFMT.height() + PAGE.sysGap); // unused in this app
            //System.out.println("nSys: " + PAGE.nSys);
          }
          new Sys(PAGE);
        }
      });
    }//----end of Music 2 constructor
    
    public void paintComponent(Graphics g){
      G.fillBackground(g, Color.WHITE);
      g.setColor(Color.BLACK);
      Ink.BUFFER.show(g);
      Layer.ALL.show(g);
    }
    
    public void mousePressed(MouseEvent me){
      Gesture.AREA.dn(me.getX(), me.getY());
      repaint();
    }
    
    public void mouseDragged(MouseEvent me){
      Gesture.AREA.drag(me.getX(), me.getY());
      repaint();
    }
    
    public void mouseReleased(MouseEvent me){
      Gesture.AREA.up(me.getX(), me.getY());
      repaint();
    }
  }

::S The Music Package
==Music Package
When we are done with the refactoring, this is the code that belongs in the music package, supporting the Music2 application.

==APP.java
  public class APP{
    public static I.MusicApp get; // NOTE: your actual application should initialize this variable!
  }

==Bar.java
  public class Bar extends Mass{
    private static final int FAT = 2, RIGHT = 4, LEFT = 8; // bits in barType
    /* 0=single; 1=double; 2or3=fine; if either of bits RIGHT or LEFT are set it is a repeat
       i.e. repeats dominate any of the lower bits.
       Intended reactions - S-S on empty space creates Bar, S-S on existing bar cycles between types.
       DOT to the right or left of Bar, toggles Dots (repeats) on that particular side.
    */
    private Sys sys;
    private int x, barType = 0;
    
    public Bar(Sys sys, int x){
      super("BACK");
      this.sys = sys;
      this.x = x;
      if(Math.abs(sys.page.right() - x) < UC.barToMarginSnap){
        this.x = sys.page.right();
      }
      barType = 0;
      
      addReaction(new Reaction("S-S"){ // cycle this Bar
        public int bid(Gesture g){
          int x = g.vs.xMid();
          if(Math.abs(x - Bar.this.x) > UC.barToMarginSnap){
            return UC.noBid;
          }
          int y1 = g.vs.yLo(), y2 = g.vs.yHi();
          if(y1 < Bar.this.sys.yTop() - 20 || y2 > Bar.this.sys.yBot() + 20){
            return UC.noBid;
          } // y1 && y1 both in sys range
          return Math.abs(x - Bar.this.x);
        }
        
        public void act(Gesture g){
          Bar.this.cycleType();
        }
      });
      
      addReaction(new Reaction("DOT"){ // Dot this Bar
        public int bid(Gesture g){
          int x = g.vs.xMid();
          int y = g.vs.yMid();
          if(y < Bar.this.sys.yTop() || y > Bar.this.sys.yBot()){
            return UC.noBid;
          }
          int dist = Math.abs(x - Bar.this.x);
          //if(dist > 3*sys.page.sysfmt.maxH){
          if(dist > 3*APP.get.sysfmt(sys.page).maxH){
            return UC.noBid;
          }
          return dist;
        }
        
        public void act(Gesture g){
          if(g.vs.xMid() < Bar.this.x){
            Bar.this.toggleLeft();
          }else {
            Bar.this.toggleRight();
          }
        }
      });
    }
    
    public void cycleType(){ barType++; if(barType > 2){barType = 0;} }
    public void toggleLeft(){barType = barType ^ LEFT;}
    public void toggleRight(){barType = barType ^ RIGHT;}
    
    public void show(Graphics g){
      g.setColor(Color.BLACK);
      Sys.Fmt SYSFMT = APP.get.sysfmt(sys.page);
      int yTop = sys.yTop(), H = SYSFMT.maxH, y1 = 0, bot; // y1,bot mark top and bot of connected component
      boolean justSawBreak = true; // signals when we are at the top of a new connected component
      //for(Staff.Fmt sf : sys.page.sysfmt) {
      for(Staff.Fmt sf : SYSFMT) {
        int top = yTop + sf.dy; // top of this staff
        bot = top + sf.height();  // bottom of this staff
        if(justSawBreak){
          y1 = top;
        } // remember start of connected component
        justSawBreak = !sf.barContinues;
        if(justSawBreak){ // we now have a connected component from y1 to y2
          if(y1 == bot){
            y1 -= 2*H;
            bot += 2*H;
          } // this is a fix for isolated drum, single line staffs.
          //.. without that fix, you can't see staff lines on a drum staff.
          drawLines(g, x, y1, bot);  // lines show only at end of connected components
        }
        if(barType > 3){
          drawDots(g, x, top);
        }
      }
    }
    
    public void drawLines(Graphics g, int x, int y1, int y2){
      int H = APP.get.sysfmt(sys.page).maxH;
      if(barType == 0){ thinBar(g, x, y1, y2); }
      if(barType == 1){ thinBar(g, x, y1, y2);thinBar(g, x - H, y1, y2); }
      if(barType == 2){ fatBar(g, x - H, y1, y2, H);thinBar(g, x - 2*H, y1, y2); }
      if(barType >= 4){
        fatBar(g, x - H, y1, y2, H); // all repeats have fat bar
        if((barType & LEFT) != 0){ thinBar(g, x - 2*H, y1, y2);wings(g, x - 2*H, y1, y2, -H, H); }
        if((barType & RIGHT) != 0){ thinBar(g, x + H, y1, y2);wings(g, x + H, y1, y2, H, H); } }
    }
    
    public void drawDots(Graphics g, int x, int top){ // from top of single staff
      int H = APP.get.sysfmt(sys.page).maxH;
      if((barType & LEFT) != 0){
        g.fillOval(x - 3*H, top + 11*H/4, H/2, H/2);
        g.fillOval(x - 3*H, top + 19*H/4, H/2, H/2);
      }
      if((barType & RIGHT) != 0){
        g.fillOval(x + 3*H/2, top + 11*H/4, H/2, H/2);
        g.fillOval(x + 3*H/2, top + 19*H/4, H/2, H/2);
      }
    }
    
    public static void wings(Graphics g, int x, int y1, int y2, int dx, int dy){
      g.drawLine(x, y1, x + dx, y1 - dy);
      g.drawLine(x, y2, x + dx, y2 + dy);
    }
    
    public static void fatBar(Graphics g, int x, int y1, int y2, int dx){
      g.fillRect(x, y1, dx, y2 - y1);
    }
    
    public static void thinBar(Graphics g, int x, int y1, int y2){
      g.drawLine(x, y1, x, y2);
    }
  }

==Beam.java
  public class Beam extends Mass{
    private Stem.List stems = new Stem.List();
    
    public Beam(Stem a, Stem b){
      super("NOTE");
      stems.add(a); stems.add(b);
      a.beam = this; b.beam = this;
      a.nFlag = 1; b.nFlag = 1;
      stems.sort();
    }
    
    public String toString(){return " Beam ";}
    
    public Stem first(){return stems.get(0);}
    public Stem last(){return stems.get(stems.size()-1);}
    public void setMasterBeam(){ // use static master beam buffer for yOfx calculations
      mx1 = first().x(); my1 = first().yBeamEnd(); mx2 = last().x(); my2 = last().yBeamEnd();
    }
    
    public void deleteBeam(){
      for(Stem s : stems){s.beam = null;} // remove stem associations with beam.
      // stems still exist, flags and dots still exist, we just remove the beams.
      deleteMass(); // remove beam from layers
    }
    
    public void addStem(Stem s){ // stem joins this beam
      if(s.beam == null){
        stems.add(s); s.beam = this;
        stems.sort();
      }
    }
    
    public void removeStem(Stem s){
      if(s == first() || s == last()){deleteBeam();} else {stems.remove(s); stems.sort();}
    }
    public void show(Graphics g){ g.setColor(Color.BLACK); drawBeamGroup(g); }
    
    private void drawBeamGroup(Graphics g){
      setMasterBeam(); // defines master beam coords: mx1, my1, mx2, my2
      Stem firstStem = first();
      int H = firstStem.staff.H(); int sH = firstStem.isUp ? H : -H; // signed H needed for beamStack
      int nPrev = 0, nCur = firstStem.nFlag, nNext = stems.get(1).nFlag; // flag count for 3 stems
      int px; int cx = firstStem.x(); // x location of previous stem and current stem
      int bx = cx + 3*H; // forward leanding beamlet on first stem runs from cx to bx
      if(nCur > nNext){drawBeamStack(g, nNext, nCur, cx, bx, sH);} // beamlets on first stem point right
      for(int cur = 1; cur <stems.size(); cur++){
        Stem sCur = stems.get(cur); px = cx; cx = sCur.x();
        nPrev = nCur; nCur = nNext; nNext = (cur <(stems.size()-1))? stems.get(cur +1).nFlag : 0;
        int nBack = Math.min(nPrev, nCur);
        drawBeamStack(g, 0, nBack, px, cx, sH); // draw beams back to previous stem.
        if(nCur > nPrev && nCur > nNext){ // we have beamlets on this stem.
          if(nPrev < nNext){  // beamlets lean toward side with more beams.
            bx = cx +3*H;
            drawBeamStack(g, nNext, nCur, cx, bx, sH);
          }else{
            bx = cx -3*H;
            drawBeamStack(g, nPrev, nCur, bx, cx, sH);
          }
        }
      }
    }
    // ----------static variables and function ---------
    public static int mx1,my1,mx2,my2; // coordinates of THE master beam
    public static Polygon poly; // buffer to hold the polygon that makes up a single beam
    static {int[] foo = {0,0,0,0}; poly = new Polygon(foo,foo,4);}
    
    
    // math function to find y on a sloped line segment one is buffered one is just arguments.
    public static void setMasterBeam(int x1, int y1, int x2, int y2){ // use static master beam buffer for yOfx calculations
      mx1 = x1; my1 = y1; mx2 = x2; my2 = y2;
    }
    public static int yOfX(int x){int dy = my2-my1, dx = mx2-mx1; return ((x-mx1)*dy)/dx + my1;}
    public static int yOfX(int x, int x1, int y1, int x2, int y2){
      int dy = y2-y1, dx = x2-x1;
      return ((x-x1)*dy)/dx + y1;
    }
    
    public static boolean verticalLineCrossesSegment(int x, int y1, int y2, int bx, int by, int ex, int ey){
      if(x < bx || x > ex){return false;}
      int y = yOfX(x, bx, by, ex, ey);
      if(y1<y2){return (y1 < y && y<y2);} else {return (y2<y && y<y1);}
    }
    
    // draws from n1 to n2 using  segment x1,y1, x2,y2
    public static void drawBeamStack(Graphics g, int n1, int n2, int x1, int x2, int h){
      int y1 = yOfX(x1), y2 = yOfX(x2);
      for(int i = n1; i<n2; i++){ // draw the full beams
        setPoly(x1, y1+i*2*h, x2, y2+i*2*h, h);
        g.fillPolygon(poly);
      }
    }
    
    public static void setPoly(int x1, int y1, int x2, int y2, int h){
      int[] a = poly.xpoints; a[0] = x1; a[1] = x2; a[2] = x2; a[3] = x1;
      a = poly.ypoints; a[0] = y1; a[1] = y2; a[2] = y2 + h; a[3] = y1 + h;
    }
  } 

==Duration.java
  public abstract class Duration extends Mass{ // used for Rests and for Stems
    public int nFlag = 0, nDot = 0;
    
    public Duration(){super("NOTE");}
    
    abstract public void show(Graphics g); // Rests and Stems must implement this
    
    public void incFlag(){if(nFlag < 4){nFlag++;} }
    public void decFlag(){if(nFlag > -2){nFlag--;}}
    public void cycleDot(){nDot++; if(nDot > 3){nDot = 0;}}
  }  

==Glyph.java
  public class Glyph{
    // Offsets & Scales for Sinfonia True Type Font
    public static String fontName = UC.FontName;
    
    public static Glyph BRACE = new Glyph((char)61473, 16, 0, 4);
    
    public static Glyph CLEF_G = new Glyph((char)61479, 16, -3, 1);
    public static Glyph CLEF_F = new Glyph((char)61480, 16, -3, 4);
    public static Glyph CLEF_C = new Glyph((char)61481, 16, -3, 4);
    public static Glyph CLEF_TAB = new Glyph((char)61581, 10, -1, 1);
    public static Glyph CLEF_G8 = new Glyph((char)61639, 16, -3, 1);
    
    public static Glyph HEAD_HALF = new Glyph((char)61485, 16, 0, 7);
    public static Glyph HEAD_Q = new Glyph((char)61486, 16, 0, 7);
    public static Glyph HEAD_W = new Glyph((char)61484, 16, 0, 7);
    
    public static Glyph FLAG1D = new Glyph((char)61487, 16, 0, 8);
    public static Glyph FLAG1U = new Glyph((char)61488, 16, 0, 1);
    public static Glyph FLAG2D = new Glyph((char)61489, 16, 0, 8);
    public static Glyph FLAG2U = new Glyph((char)61490, 16, 0, 1);
    public static Glyph FLAG3D = new Glyph((char)61491, 16, 0, 8);
    public static Glyph FLAG3U = new Glyph((char)61492, 16, 0, -1);
    public static Glyph FLAG4D = new Glyph((char)61493, 16, 0, 8);
    public static Glyph FLAG4U = new Glyph((char)61494, 16, 0, -3);
    
    public static Glyph REST_W = new Glyph((char)61499, 16, 0, 6);
    public static Glyph REST_H = new Glyph((char)61499, 16, 0, 7);
    public static Glyph REST_Q = new Glyph((char)61501, 16, 0, 5);
    public static Glyph REST_1F = new Glyph((char)61502, 16, 0, 6);
    public static Glyph REST_2F = new Glyph((char)61503, 16, 0, 6);
    public static Glyph REST_3F = new Glyph((char)61504, 16, 0, 4);
    public static Glyph REST_4F = new Glyph((char)61505, 16, 0, 4);
    
    public static int theSize = -1;
    public static Font theFont;
    
    public char code;
    public double scale, dx, dy;
    
    private Glyph(char code, double scale, double dx, double dy){
      this.code = code;
      this.scale = scale; this.dx = dx; this.dy = dy;
    }
    
    public void showAt(Graphics g, int H, int x, int y){
      int size = (int)scale*H;
      if(size != theSize){
        theFont = new Font(fontName, 0, size);
        theSize = size;
      }
      Font f = g.getFont(); // fetch old font so that we can restore it
      //g.setColor(Color.BLACK);
      g.setFont(theFont);
      g.drawString(""+code, x + (int)Math.floor(dx*H), y + (int)Math.floor(dy*H));
      //g.setColor(Color.RED);
      //g.drawRect(x, y, H, H);
      g.setFont(f); // restore old font
    }
  }

==Head.java
  public class Head extends Mass implements Comparable<Head>{
    public static Comparator<Head> orderByY = new Comparator<Head>(){
      public int compare(Head h1, Head h2){
        return (h1.staff.ndx != h2.staff.ndx) ? h1.staff.ndx - h2.staff.ndx : h1.line - h2.line;
      }
    };
    
    private Glyph forcedGlyph = null; // set this to override normalGlyph()
    public Staff staff;
    public int line; // line is a yCoord in disguise. Line 0 is top line, line 1 is first space, line 2 is next line down.
    public Stem stem = null;
    public Time time;
    public boolean wrongSide = false; // set by stem
    
    public String toString(){return " Head:"+line;}
    
    public Head(Staff staff, int x, int y){
      super("NOTE");
      this.staff = staff;
      this.line = staff.lineOfY(y);
      time = staff.sys.getTime(x); // get the time for this head.
      time.addHead(this);
      
      addReaction(new Reaction("S-S"){ // Stem or unStem heads
        public int bid(Gesture g){
          int x = g.vs.xMid(), y1 = g.vs.yLo(), y2 = g.vs.yHi();
          int W = Head.this.W(), yH = Head.this.y();
          if(yH<y1 || yH>y2){ return UC.noBid; }
          int hLeft = Head.this.time.x, hRight = hLeft + W; // left and right side of Head.
          if(x < hLeft - W || x > hRight + W){ return UC.noBid; } // must be reasonably close to a head.
          if(x < (hLeft + W/2)){ return hLeft - x; }
          if(x > (hRight - W/2)){ return x - hRight; }
          return UC.noBid;
        }
        
        public void act(Gesture g){
          int x = g.vs.xMid(), y1 = g.vs.yLo(), y2 = g.vs.yHi();
          Staff staff = Head.this.staff;
          Time time = Head.this.time;
          int W = Head.this.W();
          boolean up = x > (time.x + W/2);
          if(Head.this.stem == null){
            Stem.getStem(staff, time, y1, y2, up);
            //t.stemHeads(staff, up, y1, y2);
          }else {
            time.unStemHeads(y1, y2);
          }
        }
      });
      
      addReaction(new Reaction("DOT"){
        public int bid(Gesture g){
          int xh = Head.this.x(), yh = Head.this.y(), h = Head.this.staff.H(), w = Head.this.W();
          int x = g.vs.xMid(), y = g.vs.yMid();
          if(x < xh || x > xh + 2*w || y < yh - h || y > yh + h){
            return UC.noBid;
          }
          return Math.abs(xh + w - x) + Math.abs(yh - y);
        }
        
        public void act(Gesture g){
          if(Head.this.stem != null){
            Head.this.stem.cycleDot();
          }
        }
      });
    }
    
    public void show(Graphics g){
      int H = staff.H();
      g.setColor(stem == null ? Color.RED : Color.BLACK);
      //if(wrongSide){g.setColor(Color.CYAN);}
      Glyph glyph = Glyph.HEAD_Q;
      (forcedGlyph != null ? forcedGlyph : normalGlyph()).showAt(g, H, x(), y());
      if(stem != null){
        int off = UC.restFirstDotOffset, sp = UC.dotSpacing;
        for(int i = 0; i < stem.nDot; i++) {
          g.fillOval(time.x + off + i*sp, y() - 3*H/2, H/2, H/2);
        }
      }
    }
    
    
    public Glyph normalGlyph(){
      if(stem == null){ return Glyph.HEAD_Q; }
      if(stem.nFlag == -1){ return Glyph.HEAD_HALF; }
      if(stem.nFlag == -2){ return Glyph.HEAD_W; }
      return Glyph.HEAD_Q;
    }
    
    public int W(){ return 24*staff.H()/10; } // Width of a note head, RIGHT = LEFT + W();
    
    public int y(){ return this.staff.yLine(line); }
    
    public int x(){
      int res = time.x;
      if(wrongSide){ res += (stem != null && stem.isUp) ? W() : -W(); }
      return res;
    }
    
    public void unStem(){
      if(stem != null){
        stem.removeHead(this); // this will delete stem if necessary
        // remove Head in stem also doe the following
        // stem = null;
        // wrongSide = false;
      }
    }
    
    public int compareTo(Head h){
      return (staff.ndx != h.staff.ndx) ? staff.ndx - h.staff.ndx : line - h.line;
    }
  }

==Rest.java
  public class Rest extends Duration{
    private Staff staff;
    private int line = 4; // default location of rest is on center line
    private Time time;
    
    public Rest(Staff staff, Time t){
      super();
      this.time = t;
      this.staff = staff;
      addReaction(new Reaction("E-E"){ // ADD FLAG to rest
        public int bid(Gesture g){
          int y = g.vs.yMid(), x1 = g.vs.xLo(), x2 = g.vs.xHi(), x = Rest.this.time.x;
          if(x1 > x || x2 < x){
            return UC.noBid;
          }
          return Math.abs(y - Rest.this.staff.yLine(4));
        }
        
        public void act(Gesture g){
          Rest.this.incFlag();
        }
      });
      
      addReaction(new Reaction("W-W"){ // DEC FLAG to rest
        public int bid(Gesture g){
          int y = g.vs.yMid(), x1 = g.vs.xLo(), x2 = g.vs.xHi(), x = Rest.this.time.x;
          if(x1 > x || x2 < x){
            return UC.noBid;
          }
          return Math.abs(y - Rest.this.staff.yLine(4));
        }
        
        public void act(Gesture g){
          Rest.this.decFlag();
        }
      });
      
      addReaction(new Reaction("DOT"){
        public int bid(Gesture g){
          int xr = Rest.this.time.x, yr = Rest.this.y();
          int x = g.vs.xMid(), y = g.vs.yMid();
          if(x < xr || x > xr + 40 || y < yr - 40 || y > yr + 40){
            return UC.noBid;
          }
          return Math.abs(x - xr) + Math.abs(y - yr);
        }
        
        public void act(Gesture g){
          Rest.this.cycleDot();
        }
      });
    }
    
    public int y(){
      return staff.yLine(line);
    }
    
    public void show(Graphics g){
      g.setColor(Color.BLACK);
      int H = staff.H(), y = y();
      if(nFlag == -2){ Glyph.REST_W.showAt(g, H, time.x, y); }
      if(nFlag == -1){ Glyph.REST_H.showAt(g, H, time.x, y); }
      if(nFlag == 0){ Glyph.REST_Q.showAt(g, H, time.x, y); }
      if(nFlag == 1){ Glyph.REST_1F.showAt(g, H, time.x, y); }
      if(nFlag == 2){ Glyph.REST_2F.showAt(g, H, time.x, y); }
      if(nFlag == 3){ Glyph.REST_3F.showAt(g, H, time.x, y); }
      if(nFlag == 4){ Glyph.REST_4F.showAt(g, H, time.x, y); }
      int off = UC.restFirstDotOffset, sp = UC.dotSpacing;
      for(int i = 0; i < nDot; i++) {
        g.fillOval(time.x + off + i*sp, y - 3*H/2, H/2, H/2);
      }
    }
  }

==Staff.java
  public class Staff extends Mass{
    public Sys sys; // Every staff belongs to a system
    public int ndx; // index on staff list - basically sys.staffs.get(ndx) should be this staff
    
    public Staff(Sys sys){
      super("BACK");
      this.sys = sys;
      ndx = sys.addStaff(this);
      
      addReaction(new Reaction("S-S"){ // create Bar
        public int bid(Gesture g){
          int x = g.vs.xMid(), y1 = g.vs.yLo(), y2 = g.vs.yHi();
          if(x < sys.page.left() || x > (sys.page.right() + UC.barToMarginSnap)){
            return UC.noBid;
          }
          int d = Math.abs(y1 - Staff.this.yTop()) + Math.abs(y2 - Staff.this.yBot());
          return (d < 30) ? (d + 20) : UC.noBid; // bias of 20 allows Bar Cycle gesture to outbid this
        }
        
        public void act(Gesture g){
          new Bar(Staff.this.sys, g.vs.xMid());
        }
      });
      
      addReaction(new Reaction("S-S"){ // toggle BarContinues
        public int bid(Gesture g){
          if(Staff.this.sys.ndx != 0){
            return UC.noBid;
          } // we only change bar continues in first system
          int y1 = g.vs.yLo(), y2 = g.vs.yHi();
          if(Staff.this.ndx == sys.page.sysfmt().size() - 1){
            return UC.noBid;
          } // last staff in sys can't continue
          if(Math.abs(y1 - Staff.this.yBot()) > 20){
            return UC.noBid;
          }
          Staff nextStaff = sys.getStaff(ndx + 1);
          if(Math.abs(y2 - nextStaff.yTop()) > 20){
            return UC.noBid;
          }
          return 10;
        }
        
        public void act(Gesture g){
          sys.page.sysfmt().get(Staff.this.ndx).toggleBarContinues();
        }
      });
      
      addReaction(new Reaction("SW-SW"){ // add Note to Staff
        public int bid(Gesture g){
          int x = g.vs.xMid(), y = g.vs.yMid();
          if(x < sys.page.left() || x > sys.page.right()){
            return UC.noBid;
          }
          int H = Staff.this.H(), top = Staff.this.yTop() - H, bot = Staff.this.yBot() + H;
          if(y < top || y > bot){
            return UC.noBid;
          }
          return 10;
        }
        
        public void act(Gesture g){
          new Head(Staff.this, g.vs.xMid(), g.vs.yMid());
        }
      });
      addReaction(new Reaction("W-S"){ // add Q Rest
        public int bid(Gesture g){
          int x = g.vs.xLo(), y = g.vs.yMid();
          if(x < sys.page.left() || x > sys.page.right()){
            return UC.noBid;
          }
          int H = Staff.this.H(), top = Staff.this.yTop() - H, bot = Staff.this.yBot() + H;
          if(y < top || y > bot){
            return UC.noBid;
          }
          return 10;
        }
        
        public void act(Gesture g){
          Time t = Staff.this.sys.getTime(g.vs.xLo());
          new Rest(Staff.this, t);
        }
      });
      addReaction(new Reaction("E-S"){ // add E Rest
        public int bid(Gesture g){
          int x = g.vs.xLo(), y = g.vs.yMid();
          if(x < sys.page.left() || x > sys.page.right()){
            return UC.noBid;
          }
          int H = Staff.this.H(), top = Staff.this.yTop() - H, bot = Staff.this.yBot() + H;
          if(y < top || y > bot){
            return UC.noBid;
          }
          return 10;
        }
        
        public void act(Gesture g){
          Time t = Staff.this.sys.getTime(g.vs.xLo());
          (new Rest(Staff.this, t)).nFlag = 1;
        }
      });
      
    }
    
    public void show(Graphics g){/* Staff line drawing done in System class*/}
    
    public int yTop(){return sys.yTop() + sys.page.sysfmt().get(ndx).dy; }
    public int yBot(){ return yTop() + sys.page.sysfmt().get(ndx).height(); }
    public int yLine(int n){ return yTop() + n*H(); }
    
    public int lineOfY(int y){
      int H = sys.page.sysfmt().get(ndx).H;
      int Bias = 100;  // because integer truncation rounds toward 0 ..
      int top = yTop() - H*Bias;  // .. we move the origin to a number like -100
      return (y - top + H/2)/H - Bias; // .. calculate a big number then remove that Bias
    }
    
    public int H(){
      return sys.page.sysfmt().get(ndx).H;
    }
    
    // ------ Staff.Fmt --------
    public static class Fmt{
      public int H; // half the space between staff lines = thickness of whole and half rest
      public int nLines = 5; // most music is 5 lines, but there are exceptions
      public int dy; // technically a Sys.Fmt notion - how far from the sys.topY you should draw this staff.
      public boolean barContinues = false; // does bar though this staff continue onto the next staff
      
      public void toggleBarContinues(){
        barContinues = !barContinues;
      }
      
      public Fmt(int dy, I.Page page){
        this.dy = dy;
        this.H = page.sysfmt().maxH;
        page.sysfmt().add(this);
      }
      
      public void showAt(Graphics g, int y, I.Page page){
        for(int i = 0; i < nLines; i++) {
          int yy = y + 2*i*H;
          g.drawLine(page.left(), yy, page.right(), yy);
        }
      }
      
      public int height(){
        return 2*H*(nLines - 1);
      }
    }
  }

==Stem.java
  public class Stem extends Duration implements Comparable<Stem>{
    /*
    public static Comparator<Stem> orderByX = new Comparator<Stem>(){
      public int compare(Stem s1, Stem s2){return s1.x()-s2.x(); }
    };
    */
    public Staff staff;
    public Beam beam = null;  // default for stem is no Beam
    private ArrayList<Head> heads;
    public boolean isUp = true;
    
    public Stem(Staff staff, ArrayList<Head> heads, boolean up){
      super();
      this.staff = staff;
      isUp = up;
      for(Head h : heads){h.unStem(); h.stem = this;} // heads leave previous stem and join this one.
      this.heads = heads;
      staff.sys.addStem(this);
      setWrongSides();
      addReaction(new Reaction("E-E"){ // ADD FLAG to stem
        public int bid(Gesture g){
          int y = g.vs.yMid(), x1 = g.vs.xLo(), x2 = g.vs.xHi();
          int xS = Stem.this.x();
          if(x1 > xS || x2 < xS){ return UC.noBid; }
          int y1 = Stem.this.yLo(), y2 = Stem.this.yHi();
          if(y < y1 || y > y2){ return UC.noBid; }
          return Math.abs(y - (y1 + y2)/2) + 60;
        }
        
        public void act(Gesture g){
          Stem.this.incFlag();
        }
      });
      
      addReaction(new Reaction("W-W"){ // DEC FLAG to rest
        public int bid(Gesture g){
          int y = g.vs.yMid(), x1 = g.vs.xLo(), x2 = g.vs.xHi();
          int xS = Stem.this.x();
          if(x1 > xS || x2 < xS){ return UC.noBid; }
          int y1 = Stem.this.yLo(), y2 = Stem.this.yHi();
          if(y < y1 || y > y2){ return UC.noBid; }
          return Math.abs(y - (y1 + y2)/2) + 60;
        }
        
        public void act(Gesture g){
          Stem.this.decFlag();
        }
      });
      
    }
    
    // factory method gets a stem IF there are heads that match the y values at the given time
    public static Stem getStem(Staff staff, Time time, int y1, int y2, boolean up){
      ArrayList<Head> heads = new ArrayList<>();
      for(Head h : time.heads){ int yH = h.y(); if(yH > y1 && yH < y2){heads.add(h);}}
      if(heads.size() == 0){return null;} // no stem created if no heads
      Beam b = internalStem(staff.sys, time.x, y1, y2); // possibly this is internal stem in beamed group
      Stem res = new Stem(staff, heads, up); // create the stem
      if(b!=null){b.addStem(res); res.nFlag = 1;} // if it was internal, then join the beam and gets one flag.
      return res;
    }
    
    public static Beam internalStem(Sys sys, int x, int y1, int y2){ // returns non-null IF we find a beam crossed by line
      for(Stem s : sys.stems){
        if(s.beam !=null && s.x()<x && s.yLo()<y2 && s.yHi()>y1){
          int bx = s.beam.first().x(), by = s.beam.first().yBeamEnd();
          int ex = s.beam.last().x(), ey = s.beam.last().yBeamEnd();
          if(Beam.verticalLineCrossesSegment(x,y1,y2,bx,by,ex,ey)){return s.beam;}
        }
      }
      return null;
    }
    
    public void show(Graphics g){
      if(nFlag >= -1 && heads.size() > 0){
        int x = x(), h = staff.H(), yH = yFirstHead(), yB = yBeamEnd();
        g.setColor(Color.BLACK);
        //g.setColor(beam == null ? Color.RED : Color.BLUE); // for debugging missing beams
        if(nFlag > -2){
          g.drawLine(x, yFirstHead(), x, yB);
        }
        if(nFlag > 0 && beam == null){
          if(nFlag == 1){(isUp ? Glyph.FLAG1D : Glyph.FLAG1U).showAt(g, h, x, yB); }
          if(nFlag == 2){(isUp ? Glyph.FLAG2D : Glyph.FLAG2U).showAt(g, h, x, yB); }
          if(nFlag == 3){(isUp ? Glyph.FLAG3D : Glyph.FLAG3U).showAt(g, h, x, yB); }
          if(nFlag == 4){(isUp ? Glyph.FLAG4D : Glyph.FLAG4U).showAt(g, h, x, yB); }
        }
      }
    }
    
    
    public Head firstHead(){return heads.get(isUp ? heads.size() - 1 : 0); }
    public Head lastHead(){return heads.get(isUp ? 0 : heads.size() - 1);}
    public int yFirstHead(){
      if(heads.size()==0){return 200;} // gauard empty stems
      Head h = firstHead();return h.staff.yLine(h.line);
    }
    
    public int yBeamEnd(){
      if(heads.size() == 0){return 100;}// gauard empty stems
      if(beam == null || beam.first() == this || beam.last() == this){
        Head h = lastHead();
        int line = h.line;
        line += (isUp ? -7 : 7); // adjust one octave from last head toward the beam
        int flagInc = nFlag > 2 ? 2*(nFlag - 2) : 0; // positive or zero
        line += (isUp ? -flagInc : flagInc); // add 2 lines for every flag over 2
        if((isUp && line > 4) || (!isUp && line < 4)){ line = 4; } // meet center line if we must
        return h.staff.yLine(line);
      }else{
        beam.setMasterBeam();
        return Beam.yOfX(x());
      }
    }
    
    public int x(){
      if(heads.size()==0){return 100;} // guard empty stems
      Head h = firstHead();return h.time.x + (isUp ? h.W() : 0);
    }
    public int yLo(){return isUp ? yBeamEnd() : yFirstHead();}
    public int yHi(){return isUp ? yFirstHead() : yBeamEnd();}
    
    public String toString(){
      String res = "Stem:" + (isUp ? "^[" : "v[");
      for(Head h : heads) { res += "," + h.line;
      }
      return res+"]";
    }
    
    public void removeHead(Head h){
      heads.remove(h);
      if(heads.size() == 0){deleteStem();}
      h.stem = null;
      h.wrongSide = false;
    }
    
    public void deleteStem(){// only call if heads is empty
      if(heads.size() != 0){System.out.println("wtf? - deleting stem that had heads on it");}
      staff.sys.removeStem(this);
      if(beam != null){beam.removeStem(this);}
      //System.out.println("Deleting "+this);
      this.deleteMass();
    }
    
    public void setWrongSides(){ // called by Time.stemHeads
      //Collections.sort(heads, Head.orderByY); // using comparator
      Collections.sort(heads);
      int i, last, next;
      if(isUp){ i = heads.size() - 1; last = 0; next = -1;}else {i = 0; last = heads.size() - 1;next = 1;}
      Head ph = heads.get(i); ph.wrongSide = false; // first head is always right
      while(i != last) {
        i += next;
        Head nh = heads.get(i);
        nh.wrongSide = ((ph.staff == nh.staff) && Math.abs(nh.line - ph.line) <= 1 && !ph.wrongSide);
        ph = nh;
      }
    }
    
    public int compareTo(Stem s){return x() - s.x();}
    
    //------------- Stem.List
    public static class List extends ArrayList<Stem>{
      private int yMin = 1000000, yMax = -1000000;
      
      public void addStem(Stem s){
        add(s);
        int yF = s.yFirstHead(), yB = s.yBeamEnd();
        if(yF < yMin){ yMin = yF; }
        if(yF > yMax){ yMax = yF; }
        if(yB < yMin){ yMin = yB; }
        if(yB > yMax){ yMax = yB; }
      }
      
      public void showMinMax(Graphics g){
        g.setColor(Color.ORANGE);
        g.drawLine(0,yMin, 100, yMin);
        g.drawLine(0,yMax, 100, yMax);
      }
      
      public void removeStem(Stem s){remove(s);}
      
      public void sort(){Collections.sort(this); }
      
      // true if there is no possible instesection between any stem in this list and the y range
      public boolean fastReject(int y1, int y2){return y1>yMax || y2<yMin ;}
      
      public ArrayList<Stem> allIntersectors(int x1, int y1, int x2, int y2){
        ArrayList<Stem> res = new ArrayList<>();
        for(Stem s : this) {
          int x = s.x(), y = Beam.yOfX(x, x1, y1, x2, y2);
          if(x>x1 && x<x2 && y > s.yLo() && y < s.yHi()){
            res.add(s);
          }
        }
        return res;
      }
    }
  }

==Sys.java
  public class Sys extends Mass{
    public I.Page page;
    public int ndx; // number of sys on the page
    private ArrayList<Staff> staffs;
    public Stem.List stems = new Stem.List();
    private Time.List times;
    
    public Sys(I.Page page){
      super("BACK");
      this.page = page;
      staffs = new ArrayList<Staff>();
      ArrayList<Sys> systems = APP.get.systems(page);
      systems.add(this);
      ndx = systems.size()-1;
      makeStaffsMatchSysfmt(); // populate the staffs list
      times = new Time.List(this);
      
      addReaction(new Reaction("E-E"){ // Beam Stems.
        public int bid(Gesture g){
          int x1 = g.vs.xLo(), y1 = g.vs.yLo(), x2 = g.vs.xHi(), y2 = g.vs.yHi(); // collect the gesture numbers
          if(stems.fastReject(y1, y2)){return UC.noBid;} // reject if gesture does not overlap the list of stems
          ArrayList<Stem> temp = stems.allIntersectors(x1,y1,x2,y2); // possible overlap: find intersecting stems
          if(temp.size() < 2){return UC.noBid;} // crossing a single stem is a Stem reaction, not a Sys reaction
          System.out.println("Crossed "+temp.size()+" stems"); // debugging
          Beam b = temp.get(0).beam; //check if all crossed stems are owned by the same beam (including null!)
          for(Stem s : temp){if(s.beam != b){return UC.noBid;}} // different owners is reject
          System.out.println("all stems share owner"); // debugging
          if(b == null && temp.size() != 2){return UC.noBid;} // only new Beam if exactly 2 null beamed stems
          // .. also, only new if both stems currenly have zero nFlag
          if(b==null && (temp.get(0).nFlag != 0 || temp.get(1).nFlag != 0)){return UC.noBid;}
          return 50; // this is either a create new Beam or flags a set of beams
          // NOW go bias single stem E-E reactions to over 50 so they DON'T win a multiple stem crossing gesture
        }
        
        public void act(Gesture g){
          int x1 = g.vs.xLo(), y1 = g.vs.yLo(), x2 = g.vs.xHi(), y2 = g.vs.yHi();
          ArrayList<Stem> temp = stems.allIntersectors(x1,y1,x2,y2);
          Beam b = temp.get(0).beam;
          if(b == null){
            new Beam(temp.get(0), temp.get(1));
          }else{
            for(Stem s : temp){s.incFlag();}
          }
        }
      });
    }
    
    void makeStaffsMatchSysfmt(){
      while(staffs.size() < APP.get.sysfmt(page).size()) {
        new Staff(this);
      }
    }
    
    public Time getTime(int x){
      return times.getTime(x);
    }
    
    public void show(Graphics g){
      int yTop = yTop(), yBot = yBot();
      //System.out.println("Sys:" + this + " y=" + yTop);
      g.setColor(Color.BLACK);
      APP.get.sysfmt(page).showAt(g, yTop, page);
      g.drawLine(page.left(), yTop, page.left(), yBot); // draw line grouping all staffs in sys
      stems.showMinMax(g);
    }
    
    public int yTop(){
      return page.top() + ndx*(page.sysfmt().height() + page.sysfmt().sysGap);
    }
    
    public int yBot(){
      return yTop() + page.sysfmt().height();
    }
    
    public void addTime(Time time){times.add(time);}
    public int addStaff(Staff staff){staffs.add(staff); return staffs.size()-1;}
    public Staff getStaff(int ndx){return staffs.get(ndx);}
    public void addStem(Stem s){stems.addStem(s);}
    public void removeStem(Stem s){stems.removeStem(s);}
    
    //---------Sys.Fmt ---------
    public static class Fmt extends ArrayList<Staff.Fmt>{
      public int maxH = UC.defaultStaffH;
      public int sysGap = 0; // set by gesture when second system is added to a page.
      
      public void showAt(Graphics g, int y, I.Page page){
        for(Staff.Fmt sf : this) {
          sf.showAt(g, y + sf.dy, page);
        } // show all the staffs at the proper delta
      }
      
      public int height(){
        Staff.Fmt last = get(size() - 1);
        return last.dy + last.height();
      }
      
      public Staff.Fmt getLast(){
        return get(size() - 1);
      }
      
      
      public void addNewStaff(I.Page page, int y){
        new Staff.Fmt(y - page.top(), page); // first create the Staff.Fmt which will join the SYSFMT list
        for(I.Page p: APP.get.pages()) {
          if(p.sysfmt() == page.sysfmt()){
            for(Sys s : p.systems()) {
              s.makeStaffsMatchSysfmt();
            }
          }
        }
        ; // every existing system must be udated
      }
    }
  }

==Time.java
  public class Time{ // essentially an x value
    public int x;
    public ArrayList<Head> heads = new ArrayList<>();  //.. this is ALL heads at this time
    
    private Time(Sys sys, int x){
      this.x = x;
      sys.addTime(this);
    }
    
    public void addHead(Head head){heads.add(head);}
    public void removeHead(Head head){heads.remove(head);}
    
    public void unStemHeads(int y1, int y2){
      for(Head h : heads) {
        int y = h.y();
        if(y > y1 && y < y2){
          h.unStem();
        }
      }
    }
    // ------------List------------------------
    public static class List extends ArrayList<Time>{
      public List(Sys sys){
        this.sys = sys;
      }
      
      public Sys sys; // lists of times are shared across a single sys
      
      public Time getTime(int x){
        if(size() == 0){
          return new Time(sys, x);
        }
        Time t = getClosestTime(x);
        return (Math.abs(x - t.x) < UC.snapTime) ? t : new Time(sys, x);
      }
      
      public Time getClosestTime(int x){
        Time res = get(0);
        int bestSoFar = Math.abs(x - res.x);
        for(Time t : this) {
          int dist = Math.abs(x - t.x);
          if(dist < bestSoFar){
            res = t;
            bestSoFar = dist;
          }
        }
        return res;
      }
    }
  }

::C Appendix
::S Splines
==Splines
One of the standard features that is often required in an application like this one is the ability to draw smooth curves. In our music application we need these curves in order to draw braces, ties, slurs, trills (essentially straight lines that wiggle back and forth as they go from here to there). 

We have so far done two types of graphics to get something drawn on the screen. We have used the geometric objects supported by the awt package, things like lines, rectangles, circles, and ovals and we have also use the font mechanism in order to place some uniform complex shapes onto the screen. Now we look at a third graphic mechanism that allows us to draw smooth curves.

The notion of a spline is fairly simple, you choose some points on the screen that you want the curve to go through. At each point you choose a tangent (a line direction) for the curve at that point, so the final curve will go exactly through the point and will be going in the tangent direction right at the moment that it is going through that point. The job of the spline code is to choose points, intermediate to the ones that you supplied that will also be on the curve and will have tangents that are in some sense intermediate to the ones that you supplied for your choosen points (which are sometimes known as "knots").

The most commonly used method is a BSpline or a Bezier Spline which is a cubic spline, though there are many different splines for different purposes. I often use a Parabolic spline because the code is easier. The difference being that a cubic spline gives the user more independent control points which is good IF you are having human users manipulating a spline on the screen. Since most of what I do is write code that draws curves parabolic is typically good enough. 

Also from a teaching standpoint, I think it is easier to see the Bezier Cubic as an extension of the simple parabolic spline code, though in fact I will teach them side by side because they are SO similar.

Generally, I think geometrically, and draw pictures first and then show you the code. In this case just to be different I am going to just develop the code, let you write it and you can have your computer draw you the pictures.

==Parabolic (Quadratic) Spline

So my spline code will conceptually look like this:

  void spline(Point A, Point B, Point C){
    // draw from point A to point C using B as a control point.
  }
  
The point B will NOT be on the curve. What the point B is doing is supplying the routine with the two required tangents, one at the initial point A and one at the final point C. In particular, the tangent at the point A is EXACTLY the line AB and the tangent at the line C is EXACTLY the line BC. As a result the curve starts out at A going exactly toward B but then starts to bend away from B and heads toward C "looking as if" it came directly from B. the point B will NOT be on the curve but the curve certainly heads "towards" B.

When we get to the code for cubic splines it looks and behaves very similarly, instead of one single "control" point B that simultaneously expresses two tangents, you provide 2 control points, B and C. This is what gives you the flexibility, you get independent control of the tangent at A and the tagnent at D.

  void cubicSpline(Point A, Point B, Point C, Point D){
    // curve goes from A - tangent at A is line AB
    // curve ends at D - tangent at D is line CD
  }

I also say, "conceptually" because in reality you might actually write code like this:

  void Spline(Graphics g, int xa, int ya, int xb, int yb, int xc, int yc){...}
  
Or possibly, you write the spline routine so that it does not Directly draw a spline, instead it writes a polygon into a buffer which you then output later. More like this:

  static Polygon poly = new Polygon();
  void Spline(int xa, int ya, int xb, int yb, int xc, int yc){...}// writes into poly
  g.drawPolygon(poly);

We will get to details after the conceptual/psuedo code.

Back to our simple parabolic spline. Our parabolic spline code is recursive. We will use the 3 given arguments, to compute a point, M, that is midway through the spline process. That point, M, (unlike B) IS exactly on the spline, and then recursively we will first spline from A to the midpointm M, and then spline from M to the final point C.

We are pretty much ready to write the final code.

  void spline(Point A, Point B, Point C){
    // first thing in EVERY recursive routine is the trivial case that short cuts the recursion.
    if( A and C are essentially very close together){ draw line segment from A to C; return}
    Point AB = midPoint(A,B), BC = midPoint(B,C), ABC = midPoint(AB,BC); // compute 3 intermediate points
    spline(A, AB, ABC); // ABC is our midpoint between A and C, AB is the control point for this spline
    spline(ABC, BC, C);
  }

Why do those points work? Well, the important feature is that ABC was the midpoint of a line that went from AB to BC. Notice that the first spline call ends with ..AB, ABC (so it it heading from AB toward ABC) and the second line begins with ABC, BC ... (so it is heading from ABC toward BC). However AB-ABC-BC are co-linear. The tangent going into the mid point matches the tangent comming out of the mid point. THAT is what makes it a smooth curve. Why is it a parabola? I did the math once (a little calculus some algebra) The math is beautiful, messy and absolutely unnecessary because you don't really care if it is a parabola, or a hyperbola, or agnasi's witch. You just wanted a smooth curve.

 This code was developed in the early history of computers when multiplication and division were slow and floating point pretty much non-existant. Part of the beauty is that the mid-point between A and B is essentially (A+B)/2 and division by 2 was a shift instruction in binary - very fast compared to an actual division.

And now that you have seen it with just 3 points, here is the same conceptual code with 4 points to get a cubicSpline

  void cubicSpline(Point A, Point B, Point C, Point D){
    if(close(A,B,C,D)){drawLine(A,D); return;}
    Point AB = midPoint(A,B), BC = midPoint(B,C), CD = midPoint(C,D);
    Point ABC = midPoint(AB,BC), BCD = midPoint(BC,CD);
    Point ABCD = midPoint(ABC,BCD); // this is our actual midpoint
    cubicSpline(A,AB,ABC,ABCD);
    cubicSpline(ABCD,BCD,CD,D);
  }

==Actual Code
I have been waving my hands at a magic routine that determines WHEN the spline that we have been asked to draw is SO CLOSE to being flat that we can just draw as single short line instead of doing another level of recursion. The actual trade offs that you must make when writing a general routine for a graphics library can be tricky. You save a lot of work whenever you short cut a recursion. On the other hand, if you are too agressively trying to declare things flat, you don't get a smooth curve which is the whole point of drawing splines. Also, if you perform a nice VERY ACCURATE calculation telling you whether or not to keep recursing you are paying that calcualtion cost every single time whether or not you short cut.

In this case, however, we know in advance that we are typically going to be using this spline in two cases. 1) in trills which are very tiny curves on very small wiggles on a possibly long line. (not much recursion needed in that case because the points were close together) and 2) slurs and ties which are long curves (half the screen width) but they don't bend much (again not much recursion needed because they were essentially nearly flat to start with).

So what we are going to do is to NOT even look at whether A is close to C (or D) but to instead pass in a small integer like 4, and decrement it each time we recurse. This is essentially the same as deciding in advance that we will be using 2^4 = 16 intermediate points to draw our spline.

Since splines are just a general graphics drawing tool, the proper location of our spline routine is in the graphics class G.

--Add to G
  public static Polygon poly = new Polygon();
  public static void pSpline(int xa,int ya, int xb, int yb, int xc, int yc, int n){
    if(n == 0){poly.addPoint(xa, ya); poly.addPoint(xc, yc); return;}
    int xab = (xa + xb)/2, yab = (ya+yb)/2, xbc = (xb + xc)/2, ybc = (yb+yc)/2;
    int xabc = (xab + xbc)/2, yabc = (yab + ybc)/2;
    pSpline(xa, ya, xab, yab, xabc, yabc, n-1);
    pSpline(xabc, yabc, xbc, ybc, xc, yc, n-1);
  }

Notice that we have elected to do the business of writing our spline into a buffer. This is convenient in that it allows us to write one spline into the buffer, then append a different spline, append some straight lines, then append another spline and finally, fill the entire polygon that we just created. If we had built it in a "draw as you go" manner we wouldn't have generated a shape that we could come back and fill later.

As we have done previously, let us test this routine by just drawing a single spline in the paintComponent of Music 2.

--Add to Music2.paintComponent
  int xa = 100, ya = 300;
  int xb = xa + 50 + G.rnd(300), yb = ya + G.rnd(2000)-1000;
  int xc = xa +500, yc =ya ;
  G.poly.reset();
  G.pSpline(xa,ya,xb,yb,xc,yc,4);
  g.fillPolygon(G.poly);

If you shake the window you will see that we draw a random parabolic hill.


::S Not Yet
==Not Yet

I am writing these notes while I am teaching the class. Presumably material after this point is stuff that I have not yet covered in class. You are free to read ahead. It is what I think I will be doing next but who knows. 

::S UnderConstruction
==UnderConstriction

Still writing this course!

</script>
</body></html>